
\chapter{Factorials and gamma functions}
Factorials and factorial-like sums and products are basic tools of combinatorics and number theory. Much like the exponential function is fundamental to differential equations and analysis in general, the factorial function (and its extension to complex numbers, the
gamma function) is fundamental to difference equations and functional equations.

\vpara
A large selection of factorial-like functions is implemented in mpFormulaPy. All functions support complex arguments, and arguments may be arbitrarily large. Results are numerical approximations, so to compute exact values a high enough precision must be set manually:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15; mp.pretty = True
>>> fac(100)
9.33262154439442e+157
>>> print int(_)    # most digits are wrong
93326215443944150965646704795953882578400970373184098831012889540582227238570431
295066113089288327277825849664006524270554535976289719382852181865895959724032
>>> mp.dps = 160
>>> fac(100)
93326215443944152681699238856266700490715968264381621468592963895217599993229915
608941463976156518286253697920827223758251185210916864000000000000000000000000.0
\end{lstlisting}
The gamma and polygamma functions are closely related to Zeta functions, L-series and polylogarithms. See also q-functions for q-analogs of factorial-like functions.


%\section{Factorials, Pochhammer Symbol, and Binomial Coefficient}
%%\label{GammaFunctionA4Math}
%
%\subsection{Factorial}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{FactorialMpMath? mpNum? the factorial $n! = \Gamma(n+1) = n \times (n-1) \times \cdots \times 1$.}
%	{n? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{Double Factorial}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{DoubleFactorialMpMath? mpNum? the double factorial $n!!$.}
%	{n? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%For even $n<0$ the result is $\infty$. For positive $n$ the double factorial is defined as
%
%\begin{equation}
%	n!!=\begin{cases}
%		1 \cdot 3 \cdot 5 \cdots n  & \text{ if } n \text{ is odd.}\\
%		2 \cdot 4 \cdot 6 \cdots n  & \text{ if } n \text{ is even.}
%	\end{cases}
%\end{equation}
%
%
%
%\subsection{Logarithm of factorials}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LogFactorialMpMath? mpNum?  $\ln(n!)$. If $n$ is negative the result is $\infty$.}
%	{n? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Binomial coefficient}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{BinomialCoefficientMpMath? mpNum? the binomial coefficient.}
%	{n? mpNum? An integer.}
%	{k? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The binomial coefficient ("$n$ choose $k$") is defined as
%\begin{equation}
%	\binom{n}{k} = \frac{n(n-1) \cdots (n-k+1)}{k(k-1) \cdots (1)}
%\end{equation}
%for $k \geq 0$.
%
%
%
%
%\subsection{Pochhammer symbol}
%\label{PochhammerSymbolMpMath}
%%\nomenclature{$(a)_n$}{Pochhammer symbol}
%\label{PochhammerSymbol}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{PochhammerMpMath? mpNum? the Pochhammer symbol.}
%	{a? mpNum? An integer.}
%	{x? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Pochhammer symbol is defined as
%\begin{equation}
%	(a)_x = \frac{\Gamma(a+x)}{\Gamma(a)}.
%\end{equation}
%In the special case that $x=n$ is a positive integer, $(a)_n = a(a+1)(a+2) \cdots (a+n-1)$ is often called "`rising factorial"'. By convention $(a)_0 = 1$.
%
%

\section{Factorials}

\subsection{Factorial}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{Factorial? mpNum? the factorial, $x!$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{fac? mpNum? the factorial, $x!$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}



Computes the factorial, $x!$. For integers $n>0$, we have $n!=1\cdot 2 \cdots (n-1) \cdot n$ and more generally the factorial is defined for real or complex $x$ by $x!=\Gamma(x+1)$.

Examples

Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for k in range(6):
...     print("%s %s" % (k, fac(k)))
...
0 1.0
1 1.0
2 2.0
3 6.0
4 24.0
5 120.0
>>> fac(inf)
+inf
>>> fac(0.5), sqrt(pi)/2
(0.886226925452758, 0.886226925452758)
\end{lstlisting}

fac() supports evaluation for astronomically large values:
\lstset{language={Python}}
\begin{lstlisting}
>>> fac(10**30)
6.22311232304258e+29565705518096748172348871081098
\end{lstlisting}


\subsection{Double factorial}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{fac2? mpNum? the double factorial $x!!$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}



Computes the double factorial $x!!$, defined for integers $x>0$ by

\begin{equation}
  x!!=\begin{cases}
    1\cdot 3 \cdots (x-2) \cdot x & \text{for }x \text{ odd}\\
    2\cdot 4 \cdots (x-2) \cdot x & \text{for }x  \text{ even}
  \end{cases}
\end{equation}

and more generally by [1]

\begin{equation}
x!! = 2^{x/2}\left(\frac{\pi}{2}\right)^{(\cos(\pi x)-1)/4} \Gamma \left(\frac{x}{2}+1 \right)
\end{equation}


Examples

The integer sequence of double factorials begins:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> nprint([fac2(n) for n in range(10)])
[1.0, 1.0, 2.0, 3.0, 8.0, 15.0, 48.0, 105.0, 384.0, 945.0]
\end{lstlisting}

With the exception of the poles at negative even integers, fac2() supports evaluation for arbitrary complex arguments. The recurrence formula is valid generally:

\lstset{language={Python}}
\begin{lstlisting}
>>> fac2(pi+2j)
(-1.3697207890154e-12 + 3.93665300979176e-12j)
>>> (pi+2j)*fac2(pi-2+2j)
(-1.3697207890154e-12 + 3.93665300979176e-12j)
\end{lstlisting}




\newpage
\section{Binomial coefficient}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{binomial? mpNum? the binomial coefficient.}
	{n? mpNum? A real or complex number.}
	{k? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}



%\subsection{binomial(n,k)}
%Computes the binomial coefficient

\begin{equation}
\binom{n}{k}=\frac{n!}{k!(n-k)!}.
\end{equation}

The binomial coefficient gives the number of ways that $k$ items can be chosen from a set of $n$ items. More generally, the binomial coefficient is a well-defined function of arbitrary real or complex $n$ and $k$, via the gamma function.

Examples

Generate Pascal's triangle:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(5):
...     nprint([binomial(n,k) for k in range(n+1)])
...
[1.0]
[1.0, 1.0]
[1.0, 2.0, 1.0]
[1.0, 3.0, 3.0, 1.0]
[1.0, 4.0, 6.0, 4.0, 1.0]
\end{lstlisting}

binomial() supports large arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> binomial(10**20, 10**20-5)
8.33333333333333e+97
>>> binomial(10**20, 10**10)
2.60784095465201e+104342944813
\end{lstlisting}




\newpage
\section{Pochhammer symbol, Rising and falling factorials}
\label{PochhammerSymbol}


\subsection{Relative Pochhammer symbol}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{RelativePochhammerMpMath? mpNum? the relative Pochhammer symbol.}
	{a? mpNum? An integer.}
	{x? mpNum? An integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The relative Pochhammer symbol defined as
\begin{equation}
	\text{poch1}(a,x) = \frac{(a)_x - 1}{x},
\end{equation}
accurate even for small $x$. If $|x|$ is small, cancellation errors are avoided by using an expansion by Fields and
Luke with generalized Bernoulli polynomials. For $x = 0$ the value  $\psi(a)$ is returned, otherwise the result is calculated from the definition.




In mathematics, the Pochhammer symbol introduced by Leo August Pochhammer is the notation $(x)_n$, where $n$ is a non-negative integer. Depending on the context the Pochhammer symbol may represent either the rising factorial or the falling factorial as defined below. Care needs to be taken to check which interpretation is being used in any particular article.

\subsection{Rising factorial}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{rf? mpNum? the rising factorial.}
	{x? mpNum? A real or complex number.}
	{n? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


Computes the rising factorial,

\begin{equation}
	x^{(n)} = x(x+1) \cdots (x+n-1) = \frac{\Gamma(x+n)}{\Gamma(x)}
\end{equation}

where the rightmost expression is valid for nonintegral $n$.

Examples

For integral $n$, the rising factorial is a polynomial:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(5):
...     nprint(taylor(lambda x: rf(x,n), 0, n))
...
[1.0]
[0.0, 1.0]
[0.0, 1.0, 1.0]
[0.0, 2.0, 3.0, 1.0]
[0.0, 6.0, 11.0, 6.0, 1.0]
\end{lstlisting}

Evaluation is supported for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> rf(2+3j, 5.5)
(-7202.03920483347 - 3777.58810701527j)
\end{lstlisting}



\subsection{Falling factorial}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{ff? mpNum? the falling factorial.}
	{x? mpNum? A real or complex number.}
	{n? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


The falling factorial is defined as,

\begin{equation}
	x_{(n)} = x(x-1) \cdots (x-n+1) = \frac{\Gamma(x+1)}{\Gamma(x-n+1)}
\end{equation}


where the rightmost expression is valid for nonintegral $n$.

Examples

For integral $n$, the falling factorial is a polynomial:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(5):
...     nprint(taylor(lambda x: ff(x,n), 0, n))
...
[1.0]
[0.0, 1.0]
[0.0, -1.0, 1.0]
[0.0, 2.0, -3.0, 1.0]
[0.0, -6.0, 11.0, -6.0, 1.0]
\end{lstlisting}

Evaluation is supported for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> ff(2+3j, 5.5)
(-720.41085888203 + 316.101124983878j)
\end{lstlisting}




\newpage
\section{Super- and hyperfactorials}
\subsection{Superfactorial}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{superfac? mpNum? the superfactorial.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


The superfactorial is defined as the product of consecutive factorials:

\begin{equation}
\text{sf}(n) = \prod_{k=1}^n k!
\end{equation}

For general complex $z$, $\text{sf}(n)$ is defined in terms of the Barnes G-function (see barnesg()).

Examples 

The first few superfactorials are (OEIS A000178):

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(10):
...     print("%s %s" % (n, superfac(n)))
...
0 1.0
1 1.0
2 2.0
3 12.0
4 288.0
5 34560.0
6 24883200.0
7 125411328000.0
8 5.05658474496e+15
9 1.83493347225108e+21
\end{lstlisting}

Superfactorials grow very rapidly:

\lstset{language={Python}}
\begin{lstlisting}
>>> superfac(1000)
3.24570818422368e+1177245
>>> superfac(10**10)
2.61398543581249e+467427913956904067453
\end{lstlisting}

Evaluation is supported for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 25
>>> superfac(pi)
17.20051550121297985285333
>>> superfac(2+3j)
(-0.005915485633199789627466468 + 0.008156449464604044948738263j)
>>> diff(superfac, 1)
0.2645072034016070205673056
\end{lstlisting}

\subsection{Hyperfactorial}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{hyperfac? mpNum? the hyperfactorial.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

%\subsection{hyperfac(z)}

The hyperfactorial is defined for integers as the product

\begin{equation}
H(n) = \prod_{k=1}^n k^k
\end{equation}


The hyperfactorial satisfies the recurrence formula $H(z)=z^z H(z-1)$. It can be
defined more generally in terms of the Barnes G-function (see barnesg()) and the gamma function by the formula.

\begin{equation}
H(z)=\frac{\Gamma(z+1)^z}{G(z)}.
\end{equation}

The extension to complex numbers can also be done via the integral representation

\begin{equation}
H(z)=(2\pi)^{-z/2} \exp \left[\binom{z+1}{2} + \int_0^z \log(t!) dt \right].
\end{equation}



Examples

The rapidly-growing sequence of hyperfactorials begins (OEIS A002109):

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(10):
...     print("%s %s" % (n, hyperfac(n)))
...
0 1.0
1 1.0
2 4.0
3 108.0
4 27648.0
5 86400000.0
6 4031078400000.0
7 3.3197663987712e+18
8 5.56964379417266e+25
9 2.15779412229419e+34
\end{lstlisting}

Some even larger hyperfactorials are:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyperfac(1000)
5.46458120882585e+1392926
>>> hyperfac(10**10)
4.60408207642219e+489142638002418704309
\end{lstlisting}

Evaluation is supported for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyperfac(0.5)
0.880449235173423
>>> diff(hyperfac, 1)
0.581061466795327
>>> hyperfac(pi)
205.211134637462
>>> hyperfac(-10+1j)
(3.01144471378225e+46 - 2.45285242480185e+46j)
\end{lstlisting}


\subsection{Barnes G-function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{barnesg? mpNum? the Barnes G-function.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The Barnes G-function generalizes the superfactorial (superfac()) and by extension also the hyperfactorial (hyperfac()) to the complex numbers in an analogous way to how the gamma function generalizes the ordinary factorial.

\vpara
The Barnes G-function may be defined in terms of a Weierstrass product:

\begin{equation}
G(z+1)=(2\pi)^{z/2} e^{[z(z+1)+\gamma z^2]/2} \prod_{n=1}^{\infty}\left[ \left(1+\frac{z}{n}  \right)^n  e^{-z+z^2 /(2n)} \right]
\end{equation}

For positive integers $n$, we have have relation to superfactorials $G(n)=\text{sf}(n-2) = 0! \cdot 1! \cdots (n-2)!$.

REF: Whittaker \& Watson, A Course of Modern Analysis, Cambridge University Press,
4th edition (1927), p.264s

Examples

Some elementary values and limits of the Barnes G-function:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> barnesg(1), barnesg(2), barnesg(3)
(1.0, 1.0, 1.0)
>>> barnesg(4)
2.0
>>> barnesg(5)
12.0
>>> barnesg(6)
288.0
>>> barnesg(7)
34560.0
>>> barnesg(8)
24883200.0
>>> barnesg(inf)
+inf
>>> barnesg(0), barnesg(-1), barnesg(-2)
(0.0, 0.0, 0.0)
\end{lstlisting}





\newpage
\section{Gamma functions}

\subsection{Gamma function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{gamma? mpNum? the gamma function, $\Gamma(x)$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The gamma function is a shifted version of the ordinary factorial, satisfying $\Gamma(n)=(n-1)!$ for integers $n>0$. More generally, it is defined by 

\begin{equation}
\Gamma(x)=\int_0^{\infty} t^{x-1} e^{-t} dt
\end{equation}

for any real or complex $x$ with $\Re(x)>0$ and for $\Re(x)<0$ by analytic continuation.

Examples

Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for k in range(1, 6):
...     print("%s %s" % (k, gamma(k)))
...
1 1.0
2 1.0
3 2.0
4 6.0
5 24.0
>>> gamma(inf)
+inf
>>> gamma(0)
Traceback (most recent call last):
...
ValueError: gamma function pole
\end{lstlisting}

gamma() supports arbitrary-precision evaluation and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 50
>>> gamma(sqrt(3))
0.91510229697308632046045539308226554038315280564184
>>> mp.dps = 25
>>> gamma(2j)
(0.009902440080927490985955066 - 0.07595200133501806872408048j)
\end{lstlisting}


Arguments can also be large. Note that the gamma function grows very quickly:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15
>>> gamma(10**20)
1.9328495143101e+1956570551809674817225
\end{lstlisting}


\subsection{Reciprocal of the gamma function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{rgamma? mpNum? the reciprocal of the gamma function, $1/\Gamma(z)$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}




This function evaluates to zero at the poles of the gamma function, $z=0,-1,-2,\ldots$.

Examples

Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> rgamma(1)
1.0
>>> rgamma(4)
0.1666666666666666666666667
>>> rgamma(0); rgamma(-1)
0.0
0.0
>>> rgamma(1000)
2.485168143266784862783596e-2565
>>> rgamma(inf)
0.0
\end{lstlisting}



\subsection{The product / quotient of gamma functions}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{gammaprod? mpNum?  the  product / quotient of gamma functions.}
	{a? mpNum? A real or complex iterables.}
	{b? mpNum? A real or complex iterables.}	
\end{mpFunctionsExtract}


\vpara
Given iterables $a$ and $b$, gammaprod(a, b) computes the product / quotient of gamma functions:

\begin{equation}
\frac{\Gamma(a_0) \Gamma(a_1) \cdots \Gamma(a_p)}{\Gamma(b_0) \Gamma(b_1) \cdots \Gamma(b_p)}
\end{equation}

Unlike direct calls to gamma(), gammaprod() considers the entire product as a limit and evaluates this limit properly if any of the numerator or denominator arguments are nonpositive integers such that poles of the gamma function are encountered. That is, gammaprod() evaluates

\begin{equation}
\lim_{\epsilon \to 0}   \frac{\Gamma(a_0 +\epsilon) \Gamma(a_1+\epsilon) \cdots \Gamma(a_p+\epsilon)}{\Gamma(b_0+\epsilon) \Gamma(b_1+\epsilon) \cdots \Gamma(b_p+\epsilon)}
\end{equation}


In particular:

If there are equally many poles in the numerator and the denominator, the limit is
a rational number times the remaining, regular part of the product.

If there are more poles in the numerator, gammaprod() returns +inf.

If there are more poles in the denominator, gammaprod() returns 0.

Examples

The reciprocal gamma function $1/\Gamma(x)$ evaluated at $0$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15
>>> gammaprod([], [0])
0.0
\end{lstlisting}

A limit:

\lstset{language={Python}}
\begin{lstlisting}
>>> gammaprod([-4], [-3])
-0.25
>>> limit(lambda x: gamma(x-1)/gamma(x), -3, direction=1)
-0.25
>>> limit(lambda x: gamma(x-1)/gamma(x), -3, direction=-1)
-0.25
\end{lstlisting}


\subsection{The log-gamma function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{loggamma? mpNum? the principal branch of the log-gamma function, $\ln\Gamma(z)$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

Unlike $\ln(\Gamma(z))$, which has infinitely many complex branch cuts, the principal log-gamma function only has a single branch cut along the negative half-axis. The principal branch continuously matches the asymptotic Stirling expansion

\begin{equation}
\ln \Gamma(z) \approx \frac{\ln(2\pi)}{2} + \left(z-\frac{1}{2} \right) \ln(z)-z+O(z^{-1}) 
\end{equation}

The real parts of both functions agree, but their imaginary parts generally differ by $2n\pi$ for some $n \in \mathbb{Z}$. They coincide for $z \in \mathbb{R}, z>0$.

Computationally, it is advantageous to use loggamma() instead of gamma() for extremely large arguments.

Examples

Comparing with :

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> loggamma('13.2'); log(gamma('13.2'))
20.49400419456603678498394
20.49400419456603678498394
>>> loggamma(3+4j)
(-1.756626784603784110530604 + 4.742664438034657928194889j)
>>> log(gamma(3+4j))
(-1.756626784603784110530604 - 1.540520869144928548730397j)
>>> log(gamma(3+4j)) + 2*pi*j
(-1.756626784603784110530604 + 4.742664438034657928194889j)
\end{lstlisting}

Note the imaginary parts for negative arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> loggamma(-0.5); loggamma(-1.5); loggamma(-2.5)
(1.265512123484645396488946 - 3.141592653589793238462643j)
(0.8600470153764810145109327 - 6.283185307179586476925287j)
(-0.05624371649767405067259453 - 9.42477796076937971538793j)
\end{lstlisting}


%
%\newpage
%
%
%\section{Gamma Functions}
%\label{GammaFunctionMpMath}
%
%Detailed review of the gamma function can be found in \cite{pugh_2004} and \cite{Luschny2012}.
%
%The implementation is based on \cite{boost_math}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary function }\Gamma(1+x)-1$}{ Tgamma1pm1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Tgamma1pm1MpMath? mpNum? $\Gamma(1 + x) - 1$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns $\Gamma(1 + x) - 1$ accurate even for $x \approx 0$. The function returns $-\gamma x$ if $|x| < \epsilon(x)$. For $x < -0.5$ or $x > 2$ the result is computed directly from the definition, otherwise expm1, ln1p, and lngamma small are used.
%
%
%
%\subsection{\texorpdfstring{$\text{Gamma function }\Gamma(x)$}{TGamma}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TgammaMpMath? mpNum? the gamma function for $x \neq 0, -1, -2,\ldots$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The gamma function for $x \neq 0, -1, -2,\ldots$ is defined by
%\begin{equation}
%	\Gamma(x)  = \int_{0}^{\infty} t^{x-1} e^{-t} dt \quad (x>0),
%\end{equation}
%and by analytic continuation if $x<0$, using the reflection formula
%\begin{equation}
%	\Gamma(x) \Gamma(1-x)  = \pi / \sin(\pi x).
%\end{equation}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Temme's regulated gamma function }\Gamma^*(x)$}{ TemmeGamma}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TemmeGammaMpMath? mpNum? Temme's regulated gamma function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns Temme's regulated gamma function, defined by
%\begin{equation}
%	\Gamma(x)=\sqrt{2\pi} e^{-x} x^{x-1/2} \Gamma^{*}(x), \quad x>0.
%\end{equation}
%
%
%\subsection{\texorpdfstring{$\text{Logarithm of }\Gamma(x)$}{Lgamma}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LgammaMpMath? mpNum? the logarithm of the gamma function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes $\ln|\Gamma(x)|$ for $x \neq 0, -1, -2, \ldots$. If $x<0$ the function uses the logarithm of the reflection formula.
%
%
%
%\subsection{\texorpdfstring{$\Gamma(1+x)$}{TgammaP1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TgammaP1MpMath? mpNum? $\Gamma(1+x)$ with increased accuracy for $x \approx 0$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Reciprocal of }\Gamma(x)$}{ReciGamma}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ReciGammaMpMath? mpNum? the reciprocal of the gamma function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This routine calculates the reciprocal gamma function $1/\Gamma(x)$, which is an entire function with simple zeros at the points $x=0$ and the negative integers.
%
%
%
%\subsection{\texorpdfstring{$\text{Sign of }\Gamma(x)$}{SgnGamma}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{SgnGammaMpMath? mpNum? the sign of the gamma function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the sign of $\Gamma(x)$, which is $+1$ if $x>0$ or if $\left\lfloor x \right\rfloor$ is even, $-1$ otherwise.
%
%
%
%\subsection{\texorpdfstring{$\text{Logarithm and sign of }\Gamma(x)$}{LnSgnGamma}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LnSgnGammaMpMath? mpNumList[2]? the logarithm and sign of $\Gamma(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary function }\Gamma(x) / \Gamma(x+\delta)$}{GammaDelta}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{TgammaDeltaRatioMpMath? mpNum?  the ratio of gamma functions.}
%	{x? mpNum? A real number.}
%	{$\delta$? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This functions returns the ratio of gamma functions in the form
%\begin{equation}
%	\frac{\Gamma(a)}{\Gamma(a+\delta)}
%\end{equation}
%Note that the result is calculated accurately even when $\delta$ is small compared to $a$: indeed even if $a+\delta \approx a$. The function is typically used when $a$ is large and $\delta$ is very small.
%
%
%
%\subsection{Ratio of Gamma Functions}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{TgammaratioMpMath? mpNum?  the ratio of gamma functions.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This functions returns the ratio of gamma functions in the form
%\begin{equation}
%	\frac{\Gamma(a)}{\Gamma(b)} 
%\end{equation}


%\newpage
%\section{Incomplete gamma functions}


\subsection{Generalized incomplete gamma function}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{gammainc? mpNum? the incomplete gamma function with integration limits $[a, b]$.}
	{z? mpNum? A real or complex number.}
	{a? mpNum? A real or complex number (default = 0).}
	{b? mpNum? A real or complex number (default = inf).}	
	{Keywords? String?  regularized=False.}	
\end{mpFunctionsExtract}

\vpara
The (generalized) incomplete gamma function with integration limits $[a, b]$ is defined as:

\begin{equation}
\Gamma(z, a, b) = \int_a^b t^{z-1} e^{-t} dt
\end{equation}

The generalized incomplete gamma function reduces to the following special cases when one or both endpoints are fixed:

\vpara
$\Gamma(z, 0, \infty)$ is the standard ('complete') gamma function, $\Gamma(z)$,  available directly as the mpFormulaPy function gamma()).

$\Gamma(z, a, \infty)$ is the 'upper' incomplete gamma function, $\Gamma(z, a)$.

$\Gamma(z, 0, b)$ is the 'lower' incomplete gamma function, $\gamma(z, a)$.

\vpara
Of course, we have $\Gamma(z, a, \infty) + \Gamma(z, 0, b) = \Gamma(z)$ for all $z$ and $x$.

\vpara
Note however that some authors reverse the order of the arguments when defining the lower and upper incomplete gamma function, so one should be careful to get the correct definition.

\vpara
If also given the keyword argument regularized=True, gammainc() computes the 'regularized' incomplete gamma function

\begin{equation}
P(z, a, b) = \frac{\Gamma(z, a, b)}{\Gamma(z)}.
\end{equation}

Examples

We can compare with numerical quadrature to verify that gammainc() computes the integral in the definition:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> gammainc(2+3j, 4, 10)
(0.00977212668627705160602312 - 0.0770637306312989892451977j)
>>> quad(lambda t: t**(2+3j-1) * exp(-t), [4, 10])
(0.00977212668627705160602312 - 0.0770637306312989892451977j)
\end{lstlisting}

Evaluation for arbitrarily large arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> gammainc(10, 100)
4.083660630910611272288592e-26
>>> gammainc(10, 10000000000000000)
5.290402449901174752972486e-4342944819032375
>>> gammainc(3+4j, 1000000+1000000j)
(-1.257913707524362408877881e-434284 + 2.556691003883483531962095e-434284j)
\end{lstlisting}


%\subsection{Incomplete Gamma Function}


\subsection{Derivative  of the normalised incomplete gamma function}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{GammaPDerivativeMpMath? mpNum? the partial derivative with respect to $x$ of the incomplete gamma function $P(a,x)$.}
	{a? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The partial derivative with respect to $x$ of the incomplete gamma function $P(a,x)$ is defined as:
\begin{equation}
\frac{\partial}{\partial x}P(a,x) = \frac{e^{-x} x^{a-1}}{\Gamma(a)}.
\end{equation}




\subsection{Normalised incomplete gamma functions}

\label{IncompleteGammaFunctionMpMath}

Boost references are \cite{Temme_1979} and \cite{Temme_1994}



\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{GammaPMpMath? mpNum? the normalised incomplete gamma function $P(a,x)$.}
	{a? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The normalised incomplete gamma function $P(a,x)$ is defined as
\begin{equation}
P(a,x)=\frac{1}{\Gamma(a)} \int_0^x t^{a-1} e^{-t}dt
\end{equation}
for $a \geq 0$ and $x \geq 0$.

\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{GammaQMpMath? mpNum? the normalised incomplete gamma function $Q(a,x)$.}
	{a? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
The normalised incomplete gamma function $Q(a,x)$ is defined as
\begin{equation}
Q(a,x)=\frac{1}{\Gamma(a)} \int_x^{\infty} t^{a-1} e^{-t}dt
\end{equation}
for $a \geq 0$ and $x \geq 0$.



\subsection{Non-Normalised incomplete gamma functions}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{NonNormalisedGammaPMpMath? mpNum? the non-normalised incomplete gamma function $\Gamma(a,x)$.}
	{a? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The non-normalised incomplete gamma function $\Gamma(a,x)$ is defined as
\begin{equation}
\Gamma(a,x)= \int_0^x t^{a-1} e^{-t}dt
\end{equation}
for $a \geq 0$ and $x \geq 0$.

\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{NonNormalisedGammaQMpMath? mpNum? the non-normalised incomplete gamma function $\gamma(a,x)$.}
	{a? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The non-normalised incomplete gamma function $\gamma(a,x)$ is defined as
\begin{equation}
\gamma(a,x)= \int_x^{\infty} t^{a-1} e^{-t}dt
\end{equation}
for $a \geq 0$ and $x \geq 0$.


Note: in Boost, the functions are referred to as TgammaLower and TgammaUpper.


\subsection{Tricomi's entire incomplete gamma function}
\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{TricomiGammaMpMath? mpNum? Tricomi's entire incomplete gamma function $\gamma^*(a,x)$.}
	{a? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This routine returns Tricomi's incomplete gamma function $\gamma^*$, defined as
\begin{equation}
\gamma^*(a,x)=e^{-x} \frac{M(1,a+1,x)}{\Gamma(a+1)}
\end{equation}
Special cases are $\gamma^*(0,x)=1, \gamma^*(a,0)=1/\Gamma(a+1)$, and $\gamma^*(-n,x)=x^n$, if $-n$ is a negative integer. Otherwise there are the following relations to the other incomplete functions:
\begin{equation}
\gamma^*(a,x)=\frac{x^{-a}}{\Gamma(a)}\gamma(a,x)=x^{-a} P(a,x).
\end{equation}


\subsection{Inverse normalised incomplete gamma functions}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{GammaPinvMpMath? mpNum? the inverse of the normalised incomplete gamma function $P(a,x)$.}
	{a? mpNum? A real number.}
	{p? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the inverse normalised incomplete gamma function, i.e. it calculates $x$ with $P(a,x) = p$. The input parameters are $a>0$, $p \geq 0$,  and $p+q=1$. 

\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{GammaQinvMpMath? mpNum? the inverse of the normalised incomplete gamma function $Q(a,x)$.}
	{a? mpNum? A real number.}
	{q? mpNum? A real number.}
\end{mpFunctionsExtract}





\newpage
\section{Polygamma functions and harmonic numbers}

%
%\label{Psi and Polygamma Functions MpMath}
%
%\subsection{\texorpdfstring{$\text{Digamma function }\psi(x)$}{psi2}}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{DigammaMpMath? mpNum? the digamma or $\psi$ function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\vspace{0.3cm}
%This function returns the digamma or $\psi$ function, which is defines as
%\begin{equation}
%\psi(x) = \frac{d(\ln \Gamma(x))}{dx} = \frac{\Gamma'(x)}{\Gamma(x)}, \quad x \neq 0, -1, -2,\ldots
%\end{equation}
%If $x<0$ it is transformed to positive values with the reflection formula
%\begin{equation}
%\psi(1-x)=\psi(x) + \pi \cot(\pi x)
%\end{equation}
%and for $0<x<12$ the recurrence formula
%\begin{equation}
%\psi(x+1)=\psi(x) + \frac{1}{x}
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Trigamma function }\psi'(x)$}{psi3}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TrigammaMpMath? mpNum? the trigamma function $\psi'(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\vspace{0.3cm}
%This function computes the trigamma function $\psi'(x), x\neq 0, -1, -2,\ldots$. The 
%function returns the Hurwitz zeta value $\zeta(2, x)$ if $x$ is positive; for $x < 0$
%the polygamma reflection formula  for $n = 1$ is used to compute the result
%\begin{equation}
%\psi'(x) = \left(\frac{\pi}{\sin(\pi x)} \right)^2 - \zeta(2,1-x).
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Tetragamma function }\psi''(x)$}{psi4}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TetragammaMpMath? mpNum? the tetragamma function $\psi''(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\vspace{0.3cm}
%This function computes the tetragamma function $\psi''(x), x\neq 0, -1, -2,\ldots$. The 
%function returns the Hurwitz zeta value -2$\zeta(3, x)$ if $x$ is positive; for $x < 0$
%the polygamma reflection formula  for $n = 2$ is used to compute the result
%\begin{equation}
%\psi''(x) = -2\pi^3 \cot(\pi x) \left(1+\cot^2(\pi x)  \right)   - 2\zeta(3,1-x).
%\end{equation}
%
%
%\subsection{\texorpdfstring{$\text{Pentagamma function }\psi'''(x)$}{psi5}}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{PentagammaMpMath? mpNum? the pentagamma function $\psi'''(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\vspace{0.3cm}
%This function computes the pentagamma function $\psi'''(x), x\neq 0, -1, -2,\ldots$. The 
%function returns the Hurwitz zeta value 6$\zeta(4, x)$ if $x$ is positive; for $x < 0$
%the polygamma reflection formula  for $n = 3$ is used to compute the result
%\begin{equation}
%\psi'''(x) = 2\pi^4 \left(1+4\cot^2(\pi x)+3\cot^4(\pi x)  \right)   - 6\zeta(4,1-x).
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Polygamma function }\psi^{(n)}(x)$}{psipoly}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{PolygammaMpMath? mpNum? the polygamma function $\psi^{(n)}(x)$.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\vspace{0.3cm}
%This function computes the polygamma function $\psi^{(n)}(x)$, i.e. the $n^{th}$ derivative of the $\psi$ function, with $n\geq 0$ and $x\neq 0, -1, -2,\ldots$. For $x>0$ the result is calculated as
%\begin{equation}
%\psi^{(n)}(x) = (-1)^{n+1} n! \zeta(n+1,x).
%\end{equation}




\subsection{Polygamma function}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{polygamma? mpNum? the polygamma function of order $m$ of $z$, $\psi^{(m)}(z)$.}
	{m? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
Special cases are known as the digamma function ($\psi^{(0)}(z)$), the trigamma function ($\psi^{(1)}(z)$), etc. The polygamma functions are defined as the logarithmic derivatives of the gamma function:

\begin{equation}
\psi^{(m)}(z) = \left(\frac{d}{dz}\right)^{m+1} \log\Gamma(z).
\end{equation}

In particular, $\psi^{(0)}(z) = \Gamma'(z)/\Gamma(z)$. In the present implementation of psi(), the order $m$ must be a nonnegative integer, while the argument $z$ may be an arbitrary complex number (with exception for the polygamma function's poles at $z=0,-1,-2,\ldots$).

Examples

For various rational arguments, the polygamma function reduces to a combination of standard mathematical constants:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> polygamma(0, 1), -euler
(-0.5772156649015328606065121, -0.5772156649015328606065121)
>>> polygamma(1, '1/4'), pi**2+8*catalan
(17.19732915450711073927132, 17.19732915450711073927132)
>>> polygamma(2, '1/2'), -14*apery
(-16.82879664423431999559633, -16.82879664423431999559633)
\end{lstlisting}

Evaluation for a complex argument:
\lstset{language={Python}}
\begin{lstlisting}
>>> polygamma(2, -1-2j)
(0.03902435405364952654838445 + 0.1574325240413029954685366j)
\end{lstlisting}

Evaluation is supported for large orders and/or large arguments :
\lstset{language={Python}}
\begin{lstlisting}
>>> psi(3, 10**100)
2.0e-300
>>> psi(250, 10**30+10**20*j)
(-1.293142504363642687204865e-7010 + 3.232856260909107391513108e-7018j)
\end{lstlisting}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{psi? mpNum? the polygamma function of order $m$ of $z$, $\psi^{(m)}(z)$.}
	{m? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
A shortcut for polygamma(m,z).



\subsection{Digamma function}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{digamma? mpNum? the digamma function.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
A shortcut for psi(0,z).


\subsection{Harmonic numbers}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{harmonic? mpNum? a floating-point approximation of the $n$-th harmonic number $H(n)$.}
	{n? mpNum? An  real or complex number.}	
\end{mpFunctionsExtract}


\vpara
If $n$ is an integer, harmonic(n) gives a floating-point approximation of the $n$-th harmonic number $H(n)$, defined as

\begin{equation}
H(n) = 1 + \frac{1}{2}+ \frac{1}{3} + \ldots + \frac{1}{n}
\end{equation}

The first few harmonic numbers are:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(8):
...     print("%s %s" % (n, harmonic(n)))
...
0 0.0
1 1.0
2 1.5
3 1.83333333333333
4 2.08333333333333
5 2.28333333333333
6 2.45
7 2.59285714285714
\end{lstlisting}

harmonic() supports arbitrary precision evaluation:
\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 50
>>> harmonic(11)
3.0198773448773448773448773448773448773448773448773
>>> harmonic(pi)
1.8727388590273302654363491032336134987519132374152
\end{lstlisting}







\newpage
\section{Beta Functions}

\subsection{Beta function B(a, b)}

%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{BetaMpMath? mpNum? the beta function.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The beta function is defined as
%\begin{equation}
%	B(a,b) = \frac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}
%\end{equation}
%%where $\Gamma(\cdot)$ denotes the Gamma function (see section \ref{GammaFunction}).
%The reference is \cite{Didonato_1992}



\subsection{Beta function}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{beta? mpNum? the beta function, $B(x,y)=\Gamma(x) \Gamma(y)/\Gamma(x+y)$.}
	{x? mpNum? A real or complex number.}
	{y? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
Computes the beta function, $B(x,y)=\Gamma(x) \Gamma(y)/\Gamma(x+y)$. The beta function is also commonly defined by the integral representation

\begin{equation}
B(x,y)=\int_0^1 t^{x-1}(1-t)^{y-1} dt
\end{equation}

Examples

beta() supports complex numbers and arbitrary precision evaluation:

\lstset{language={Python}}
\begin{lstlisting}
>>> beta(1, 2+j)
(0.4 - 0.2j)
>>> mp.dps = 25
>>> beta(j,0.5)
(1.079424249270925780135675 - 1.410032405664160838288752j)
>>> mp.dps = 50
>>> beta(pi, e)
0.037890298781212201348153837138927165984170287886464
\end{lstlisting}





\subsection{Logarithm of  B(a, b)}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{LnBetaMpMath? mpNum? the logarithm of the beta function $\ln B(a,b)|$ with $a,b \neq 0,-1,-2,\ldots$.}
	{a? mpNum? A real number.}
	{b? mpNum? A real number.}
\end{mpFunctionsExtract}



\subsection{Generalized incomplete beta function}

\begin{mpFunctionsExtract}
	\mpFunctionFive
	{betainc? mpNum? the generalized incomplete beta function.}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}
	{x1? mpNum? A real or complex number (default = 0).}
	{x2? mpNum? A real or complex number (default = 1).}	
	{Keywords? String?  regularized=False.}	
\end{mpFunctionsExtract}

\vpara
The generalized incomplete beta function is defined as, 

\begin{equation}
	I_{x_1}^{x_2}(a,b)=\int_{x_1}^{x_2} t^{a-1}(1-t)^{b-1} dt
\end{equation}



When $x_1=0, x_2=1$, this reduces to the ordinary (complete) beta function $B(a,b)$; see beta().

\vpara
With the keyword argument regularized=True, betainc() computes the
regularized incomplete beta function $I_{x_1}^{x_2}(a,b)/B(a, b)$. This is the cumulative distribution of the beta distribution with parameters $a, b$.

\vpara
Examples

Verifying that betainc() computes the integral in the definition:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> x,y,a,b = 3, 4, 0, 6
>>> betainc(x, y, a, b)
-4010.4
>>> quad(lambda t: t**(x-1) * (1-t)**(y-1), [a, b])
-4010.4
\end{lstlisting}

The arguments may be arbitrary complex numbers:

\lstset{language={Python}}
\begin{lstlisting}
>>> betainc(0.75, 1-4j, 0, 2+3j)
(0.2241657956955709603655887 + 0.3619619242700451992411724j)
\end{lstlisting}

With regularization:

\lstset{language={Python}}
\begin{lstlisting}
>>> betainc(1, 2, 0, 0.25, regularized=True)
0.4375
>>> betainc(pi, e, 0, 1, regularized=True) # Complete
1.0
\end{lstlisting}






\subsection{Non-Normalised incomplete beta functions}


The alogorithm is implemented as in \cite{DiDonato_1987}



\begin{mpFunctionsExtract}
	\mpFunctionThreeNotImplemented
	{IBetaNonNormalizedMpMath? mpNum? the non-normalised incomplete beta function.}
	{a? mpNum? A real number.}
	{b? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the non-normalised incomplete beta function $B_x(a,b)$ for $a>0$, $b>0$, and $0 \leq x \leq 1$:
\begin{equation}
	B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt.
\end{equation}
There are some special cases
\begin{equation}
	B_0(a,b)=0, \quad B_1(a,b)=B(a,b), \quad B_x(a,1)= \frac{x^a}{a}, \quad B_x(1,b)= \frac{1-(1-x)^b}{b},
\end{equation}
and the relation $B_{1-x}(a,b)=B(a,b)-B_x(b,a)$, which is used if $x>a/(a+b)$. 

\vspace{0.3cm}
When $a \leq 0$ or $b \leq 0$, the Gauss hypergeometric function ${}_2F_1(\cdot)$ is applied: If $a \neq 0$ is not a negative integer, the result is
\begin{equation}
	B_x(a,b)=\frac{x^a}{a} {}_2F_1(a,1-b,a+1,x), \quad -a \notin \mathbb{N}
\end{equation}
else if $b \neq 0$  is not a negative integer, the result is
\begin{equation}
	B_x(a,b)=B(a,b) - \frac{(1-x)^b x^a}{b} {}_2F_1(1,a+b,b+1,1-x), \quad -b \notin \mathbb{N}.
\end{equation}



\subsection{Normalised incomplete beta functions}
\label{sec:IncompleteBetaFunction}


\begin{mpFunctionsExtract}
	\mpFunctionThreeNotImplemented
	{IBetaMpMath? mpNum? the normalised incomplete beta function.}
	{a? mpNum? A real number.}
	{b? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the normalised incomplete beta function $I_x(a,b)$ for $a>0$, $b>0$, and $0 \leq x \leq 1$:
\begin{equation}
	I_x(a,b) = \frac{B_x(a,b)}{B(a,b)}, \quad B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt.
\end{equation}
There are some special cases
\begin{equation}
	I_0(a,b)=0, \quad I_1(a,b)=1, \quad I_x(a,1)=x^a,
\end{equation}
and the symmetry relation $I_x(a,b)=1-I_{1-x}(b,a)$, which is used for $x>a/(a+b)$.







\newpage
\chapter{Exponential integrals and error functions}
Exponential integrals give closed-form solutions to a large class of commonly occurring transcendental integrals that cannot be evaluated using elementary functions. Integrals of this type include those with an integrand of the form $t^a e^t$ or $e^{-x^2}$, the latter giving rise to the Gaussian (or normal) probability distribution.

All functions in this section can be reduced to the  incomplete gamma function. The incomplete gamma function, in turn, can be expressed using hypergeometric functions (see Hypergeometric functions).

%
%\section{Exponential Integral and Related Integrals}
%
%\subsection{Hyperbolic Cosine Integral Chi}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{HyperbolicCosineIntegralChiMpMath? mpNum? the hyperbolic cosine integral for $x$ \textgreater\ 0.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The hyperbolic cosine integral  is defined as
%\begin{equation}
%	\text{Chi}(x) = \gamma + \ln(x) + \int_0^x \frac{\cosh(t)-1}{t} dt,
%\end{equation}
%and $\text{Chi}(x) = \text{Chi}(-x)$ for $x<0$. The integral is calculated using the relation
%\begin{equation}
%	\text{Chi}(x) = \tfrac{1}{2} \left(\text{Ei}(x)-\text{E}_1(x)\right), \quad (x>0).
%\end{equation}
%
%
%
%
%\subsection{Cosine Integral Ci}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CosineIntegralChiMpMath? mpNum? the cosine integral for $x$ \textgreater\ 0.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The cosine integral is defined as
%\begin{equation}
%	\text{Ci}(x) = \gamma + \ln(x) + \int_0^x \frac{\cos(t)-1}{t} dt,
%\end{equation}
%and $\text{Ci}(x) = \text{Ci}(-x)$ for $x<0$. 
%
%
%
%
%\subsection{Entire Cosine Integral Cin}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{EntireCosineIntegralChiMpMath? mpNum? the entire cosine integral for $x$ \textgreater\ 0.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The entire cosine integral is defined as
%\begin{equation}
%	\text{Cin}(x) =  \int_0^x \frac{1-\cos(t)}{t} dt,
%\end{equation}
%
%
%
%
%
%
%\subsection{Entire Hyperbolic Cosine Integral Cinh}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{EntireHyperbolicCosineIntegralCinhMpMath? mpNum? the entire cosine integral for $x$ \textgreater\ 0.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the entire hyperbolic cosine integral 
%\begin{equation}
%	\text{Cinh}(x) =  \int_0^x \frac{\cosh(t)-1}{t} dt,
%\end{equation}
%
%
%
%
%
%
%\subsection{Exponential Integral E1}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ExponentialIntegralE1MpMath? mpNum? the exponential integral $\text{E}_1(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The exponential integral $\text{E}_1(x)$ for $x \neq 0$ is defined as
%\begin{equation}
%	\text{E}_1(x) =  \int_1^\infty \frac{e^{-xt}}{t} dt,
%\end{equation}
%For $x<0$ the integral is calculated as $\text{E}_1(x) = -\text{Ei}(-x)$. 
%
%%See also section \ref{Exponential Integral E1}
%
%
%
%
%\subsection{Exponential Integral Ei}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ExponentialIntegralEiMpMath? mpNum? the exponential integral $\text{Ei}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The exponential integral $\text{Ei}(x)$ for $x \neq 0$ is defined as
%\begin{equation}
%	\text{Ei}(x) = -PV \int_{-x}^\infty \frac{e^{-t}}{t} dt= PV \int_{-\infty}^x \frac{e^{t}}{t} dt,
%\end{equation}
%For $x<0$ the integral is calculated as $\text{Ei}(x) = -\text{E}_1(-x)$. 
%
%%See also section \ref{Exponential Integral Ei}
%
%
%
%
%
%
%\subsection{Entire Exponential Integral Ein}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ExponentialIntegralEinMpMath? mpNum? the exponential integral $\text{Ei}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the exponential integral $\text{Ein}(x)$ for $x \neq 0$ 
%\begin{equation}
%	\text{Ein}(x) = \int_{0}^x \frac{1-e^{-t}}{t} dt,
%\end{equation}
%For $x<0$ the integral is calculated as $\text{Ei}(x) = -\text{E}_1(-x)$. 
%
%
%
%
%
%\subsection{Exponential Integrals En}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{ExponentialIntegralEnMpMath? mpNum? the exponential integral  $\text{E}_n(x)$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The exponential integrals $\text{E}_n(x)$ of integer order is defined as
%\begin{equation}
%	\text{E}_n(x) = \int_{1}^{\infty} \frac{e^{-xt}}{t^n} dt, \quad (n \geq 0).
%\end{equation}
%For $x<0$ the integral is calculated as $\text{Ei}(x) = -\text{E}_1(-x)$. 
%
%
%
%
%
%\subsection{Logarithmic Integral li}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LogarithmicIntegralLiMpMath? mpNum? $\textbf{H}_{0}(x)$, the logarithmic integral $\text{li}(x)$ for $x \geq 0$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the logarithmic integral $\text{li}(x)$ for $x \geq 0$
%\begin{equation}
%	\text{li}(x) = PV \int_{0}^{x} \frac{e^{1}}{\ln(t)} dt, \quad (x \neq 1).
%\end{equation}
%For $x \neq 0$ the integral is calculated as $\text{li}(x)=\text{Ei}(\ln(x))$. 
%
%
%
%
%
%\subsection{Hyperbolic Sine Integral Shi}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{HyperbolicSineIntegralShiMpMath? mpNum? the hyperbolic sine integral.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the hyperbolic sine integral
%\begin{equation}
%	\text{Shi}(x) =  \int_0^x \frac{\sinh(t)}{t} dt,
%\end{equation}
%and $\text{Shi}(x) = -\text{Shi}(-x)$ for $x<0$. The integral is calculated using the relation
%\begin{equation}
%	\text{Shi}(x) = \tfrac{1}{2} \left(\text{Ei}(x)+\text{E}_1(x)\right), \quad (x>0).
%\end{equation}
%
%
%
%
%
%\subsection{Sine Integral Si}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{SineIntegralSiMpMath? mpNum? the sine integral.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the sine integral
%\begin{equation}
%	\text{Si}(x) =  \int_0^x \frac{\sin(t)}{t} dt,
%\end{equation}
%and $\text{Si}(x) = -\text{Si}(-x)$ for $x<0$.
%
%
%
%
%\subsection{Shifted Sine Integral si}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ShiftedSineIntegralSiMpMath? mpNum? the sine integral.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the shifted sine integral
%\begin{equation}
%	\text{si}(x) = \text{Si}(x) - \tfrac{1}{2} \pi.
%\end{equation}
%
%




%\newpage
\section{Exponential integrals}
\subsection{Exponential integral Ei}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{ei? mpNum? the exponential integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The exponential integral is defined as

\begin{equation}
\text{Ei}(x) = \int_{-\infty}^x \frac{e^t}{t} dt
\end{equation}

When the integration range includes $t=0$, the exponential integral is interpreted as providing the Cauchy principal value.

For real $x$, the Ei-function behaves roughly like $\text{Ei}(x) \approx \exp(x) + \log(|x|)$.

The Ei-function is related to the more general family of exponential integral functions
denoted by $E_n$, which are available as expint().

ei() supports complex arguments and arbitrary precision evaluation:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 50
>>> ei(pi)
10.928374389331410348638445906907535171566338835056
>>> mp.dps = 25
>>> ei(3+4j)
(-4.154091651642689822535359 + 4.294418620024357476985535j)
\end{lstlisting}



\subsection{Exponential integral E1}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{e1? mpNum? the exponential integral $\text{E}_1(x)$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


The exponential integral $\text{E}_1(x)$ is defined as

\begin{equation}
\text{E}_1(x) = \int_{z}^{\infty} \frac{e^t}{t} dt
\end{equation}


This is equivalent to expint() with $n=1$.

The E1-function is essentially the same as the Ei-function (ei()) with negated argument, except for an imaginary branch cut term:

\lstset{language={Python}}
\begin{lstlisting}
>>> e1(2.5)
0.02491491787026973549562801
>>> -ei(-2.5)
0.02491491787026973549562801
>>> e1(-2.5)
(-7.073765894578600711923552 - 3.141592653589793238462643j)
>>> -ei(2.5)
-7.073765894578600711923552
\end{lstlisting}



\subsection{Generalized exponential integral En}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{expint? mpNum? the generalized exponential integral or En-function.}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


The generalized exponential integral or En-function is defined as


\begin{equation}
\text{E}_n(x) = \int_{1}^{\infty} \frac{e^{-zt}}{t^n} dt
\end{equation}


where $n$ and $z$ may both be complex numbers. The case with is also given by e1().

\vpara
Examples

Evaluation at real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> expint(1, 6.25)
0.0002704758872637179088496194
>>> expint(-3, 2+3j)
(0.00299658467335472929656159 + 0.06100816202125885450319632j)
>>> expint(2+3j, 4-5j)
(0.001803529474663565056945248 - 0.002235061547756185403349091j)
\end{lstlisting}




\subsection{Generalized Exponential Integrals Ep}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{GeneralizedExponentialIntegralEpMpMath? mpNum? the generalized exponential integrals $\text{E}_n(x)$ of real order $p$.}
	{x? mpNum? A real number.}
	{p? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the generalized exponential integrals $\text{E}_n(x)$ of real order $p \in  \mathbb{R}$
\begin{equation}
	\text{E}_p(x) = x^{p-1} \int_{x}^{\infty} \frac{e^{-t}}{t^p} dt = \int_{1}^{\infty} \frac{e^{-xt}}{t^p} dt
\end{equation}
with $x>0$ for $p \leq 1$, and $x \geq 0$ for $p>1$. 




\newpage
\section{Logarithmic integral}

\subsection{logarithmic integral li}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{li? mpNum? the logarithmic integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The logarithmic integral or li-function $\text{li}(x)$ is defined by

\begin{equation}
\text{li}(x)= \int_0^x \frac{1}{\log(t)} dt
\end{equation}

The logarithmic integral has a singularity at $x=1$.

Alternatively, li(x, offset=True) computes the offset logarithmic integral (used in number theory)

\begin{equation}
\text{Li}(x)= \int_2^x \frac{1}{\log(t)} dt
\end{equation}


These two functions are related via the simple identity $\text{Li}(x)=\text{li}(x)-\text{li}(2)$.

The logarithmic integral should also not be confused with the polylogarithm (also denoted by Li), which is implemented as polylog().

Examples

Some basic values and limits:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 30; mp.pretty = True
>>> li(0)
0.0
>>> li(1)
-inf
>>> li(1)
-inf
>>> li(2)
1.04516378011749278484458888919
>>> findroot(li, 2)
1.45136923488338105028396848589
>>> li(inf)
+inf
>>> li(2, offset=True)
0.0
>>> li(1, offset=True)
-inf
>>> li(0, offset=True)
-1.04516378011749278484458888919
\end{lstlisting}

The logarithmic integral can be evaluated for arbitrary complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 20
>>> li(3+4j)
(3.1343755504645775265 + 2.6769247817778742392j)
\end{lstlisting}



\newpage
\section{Trigonometric integrals}

\subsection{cosine integral ci}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{ci? mpNum? the cosine integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The cosine integral is defined as

\begin{equation}
\text{Ci}(x)= \int_x^{\infty} \frac{\cos(t)}{t} dt = \gamma + \log(x) + \int_0^x \frac{\cos(t)-1}{t} dt
\end{equation}



Examples

Some values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> ci(0)
-inf
>>> ci(1)
0.3374039229009681346626462
>>> ci(pi)
0.07366791204642548599010096
>>> ci(inf)
0.0
>>> ci(-inf)
(0.0 + 3.141592653589793238462643j)
>>> ci(2+3j)
(1.408292501520849518759125 - 2.983617742029605093121118j)
\end{lstlisting}


\subsection{sine integral si}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{si? mpNum? the sine integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


The sine integral is defined as

\begin{equation}
\text{Si}(x)= \int_0^{x} \frac{\sin(t)}{t} dt 
\end{equation}


The sine integral is thus the antiderivative of the sinc function (see sinc()).

Examples

Some values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> si(0)
0.0
>>> si(1)
0.9460830703671830149413533
>>> si(-1)
-0.9460830703671830149413533
>>> si(pi)
1.851937051982466170361053
>>> si(inf)
1.570796326794896619231322
>>> si(-inf)
-1.570796326794896619231322
>>> si(2+3j)
(4.547513889562289219853204 + 1.399196580646054789459839j)
\end{lstlisting}



\newpage
\section{Hyperbolic integrals}

\subsection{hyperbolic cosine integral chi}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{chi? mpNum? the hyperbolic cosine integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The hyperbolic cosine integral, in analogy with the cosine integral (see ci()), is defined as

\begin{equation}
\text{Chi}(x)= \int_x^{\infty} \frac{\cosh(t)}{t} dt = \gamma + \log(x) + \int_0^x \frac{\cosh(t)-1}{t} dt
\end{equation}


Some values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> chi(0)
-inf
>>> chi(1)
0.8378669409802082408946786
>>> chi(inf)
+inf
>>> findroot(chi, 0.5)
0.5238225713898644064509583
>>> chi(2+3j)
(-0.1683628683277204662429321 + 2.625115880451325002151688j)
\end{lstlisting}



\subsection{hyperbolic sine integral shi}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{shi? mpNum? the hyperbolic sine integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


\vpara
Computes the hyperbolic sine integral, defined in analogy with the sine integral (see si ()) as

\begin{equation}
\text{Shi}(x)= \int_0^{x} \frac{\sinh(t)}{t} dt 
\end{equation}


Some values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> shi(0)
0.0
>>> shi(1)
1.057250875375728514571842
>>> shi(-1)
-1.057250875375728514571842
>>> shi(inf)
+inf
>>> shi(2+3j)
(-0.1931890762719198291678095 + 2.645432555362369624818525j)
\end{lstlisting}


%
%\newpage
%
%\section{Error Function and Related Functions}
%
%
%
%\subsection{Error Function erf}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ErfMpMath? mpNum? the value of the error function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%%See section \ref{Error Function erf}
%This function returns the value of the error function defined by
%\begin{equation}
%	\text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-x^2} dt,
%\end{equation}
%
%
%
%
%
%\subsection{Generalized Error Function erfg}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{ErfgMpMath? mpNum? the value of the error function.}
%	{x? mpNum? A real number.}
%	{p? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the value of the generalized error function,  defined for $p \geq 0, x \geq 0$ by
%\begin{equation}
%	\text{erfg}(p,x) = \int_0^x e^{-x^p} dt,
%\end{equation}
%
%
%
%
%
%\subsection{Complementary Error Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ErfcMpMath? mpNum? the value of the complementary error function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%%See section \ref{Complementary Error Function}
%This function returns the value of the complementary error function defined by
%\begin{equation}
%	\text{erfc}(x) = 1-\text{erfc}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-x^2} dt,
%\end{equation}
%
%
%
%
%\subsection{Scaled Repeated Integrals of erfc}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{ScaledIntErfMpMath? mpNum? the value of the error function.}
%	{x? mpNum? A real number.}
%	{i? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%These functions compute the scaled repeated integrals of complementary error function, defined for $n \geq −1$ using the awkward but standard notation
%\begin{equation}
%	i^n \text{erfc}(x) = \int_x^\infty i^{n-1} \text{erfc}(t)dt = \frac{2}{\sqrt{\pi}} \int_x^\infty \frac{(t-x)^n}{n!} e^{-t^2} dt, \quad (n=0,1,2,\ldots)
%\end{equation}
%\begin{equation}
%	i^{-1} \text{erfc}(x) =  \frac{2}{\sqrt{\pi}} e^{-x^2}, \quad i^{0} \text{erfc}(x) =  \text{erfc}(x).
%\end{equation}
%
%
%
%\subsection{Imaginary Error Function erfi}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ErfiMpMath? mpNum? the value of the imaginary error function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the imaginary error function
%\begin{equation}
%	\text{erfi}(x) =  \frac{1}{i} \text{erf}(ix).
%\end{equation}
%$\text{erfi}(x)$ is computed using the Dawson integral as
%\begin{equation}
%	\text{erfi}(x) =   \frac{2}{\sqrt{\pi}} e^{x^2} \text{dawson}(x).
%\end{equation}
%
%
%
%
%
%\subsection{Exponentially Scaled Complementary Error Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ScaledErfcMpMath? mpNum? the value of the exponentially scaled complementary error..}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns 
%\begin{equation}
%	\text{erfce}(x) = \text{erfc}(x) e^{x^2}
%\end{equation}
%the exponentially scaled complementary error.
%
%
%
%
%
%
%\subsection{Inverse Function of erf}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{InvErfMpMath? mpNum? the value of the exponentially scaled complementary error function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%%See section \ref{Inverse Function of erf}
%This function returns the functional inverse of $\text{erf}(x)$
%\begin{equation}
%	\text{erf(erf\_inv}(x)) = x, \quad -1<x<1.
%\end{equation}
%
%
%
%
%
%
%
%
%\subsection{Inverse Function of erfc}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{InvErfcMpMath? mpNum? the value of the inverse of exponentially scaled complementary error function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%%See section \ref{Inverse Function of erfc}
%This function returns the functional inverse of $\text{erfc}(x)$
%\begin{equation}
%	\text{erfc(erfc\_inv}(x)) = x, \quad 0<x<2.
%\end{equation}
%
%
%
%
%\subsection{Dawson's Integral}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{DawsonIntegralMpMath? mpNum? the value of Dawson's integral.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Dawson's integral is defined by
%\begin{equation}
%	F(x) = e^{-x^2} \int_0^x e^{-x^2} dt,
%\end{equation}
%
%
%
%\subsection{Generalized Dawson Integral}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{GeneralizedDawsonIntegralMpMath? mpNum? value of the generalized Dawson's integral.}
%	{x? mpNum? A real number.}
%	{p? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The generalized Dawson's integral $F(p,x)$, is defined for $p \geq 0, x \geq 0$ by
%\begin{equation}
%	F(p,x) = e^{-x^p} \int_0^x e^{-x^p} dt = xM(1,a+1,-z), z=x^p, a=1/p,
%\end{equation}
%
%where $M(a,b,z)$ denotes the confluent hypergeometric function (see \cite{Dijkstra_1997}).
%
%
%
%
%\subsection{Fresnel Integrals}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{FresnelCosMpMath? mpNum? the value of the Fresnel integral $C(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Fresnel integral $C(x)$ is defined as
%\begin{equation}
%	C(x) = \int_0^x cos\left(\tfrac{1}{2}\pi t^2 \right) dt,
%\end{equation}
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{FresnelSinMpMath? mpNum? the value of the Fresnel integral $S(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The Fresnel integral $S(x)$ is defined as
%\begin{equation}
%	S(x) = \int_0^x sin\left(\tfrac{1}{2}\pi t^2 \right) dt,
%\end{equation}
%
%
%
%
%\subsection{Goodwin-Staton Integral}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{GoodwinStatonMpMath? mpNum? the value of the Goodwin-Staton integral.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Goodwin-Staton integral for $x>0$ is defined as
%\begin{equation}
%	G(x) = \int_0^x \frac{e^{-t^2}}{t+x} dt,
%\end{equation}
%
%
%
%
%
%
%
%\subsection{Expint3}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Expint3MpMath? mpNum? the value of the Expint3 integral.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the the integral
%\begin{equation}
%	\text{expint3}(x) = \int_0^x e^{-t^2} dt = \text{erfg}(3,x) = \tfrac{1}{3} \gamma\left(\tfrac{1}{3}, x^3 \right).
%\end{equation}
%
%


\section{Error functions}


\subsection{Error Function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{erf? mpNum? the error function, $\text{erf}(x)$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The error function is the normalized antiderivative of the Gaussian function $\exp(-t^2)$. More precisely,

\begin{equation}
\text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x \exp(-t^2)dt
\end{equation}

Basic examples

Simple values and limits include:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> erf(0)
0.0
>>> erf(1)
0.842700792949715
>>> erf(-1)
-0.842700792949715
>>> erf(inf)
1.0
>>> erf(-inf)
-1.0
\end{lstlisting}

erf() implements arbitrary-precision evaluation and supports complex numbers:
\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 50
>>> erf(0.5)
0.52049987781304653768274665389196452873645157575796
>>> mp.dps = 25
>>> erf(1+j)
(1.316151281697947644880271 + 0.1904534692378346862841089j)
\end{lstlisting}

See also erfc(), which is more accurate for large $x$, and erfi() which gives the antiderivative of $\exp(t^2)$.
The Fresnel integrals fresnels() and fresnelc() are also related to the error function


\subsection{Complementary Error Function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{erfc? mpNum? the complementary error function, $\text{erfc}(x)=1-\text{erf}(x)$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
This function avoids cancellation that occurs when naively computing the complementary error function as $1-\text{erf}(x)$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> 1 - erf(10)
0.0
>>> erfc(10)
2.08848758376254e-45
\end{lstlisting}

erfc() works accurately even for ludicrously large arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> erfc(10**10)
4.3504398860243e-43429448190325182776
\end{lstlisting}

Complex arguments are supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> erfc(500+50j)
(1.19739830969552e-107492 + 1.46072418957528e-107491j)
\end{lstlisting}



\subsection{Imaginary Error Function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{erfi? mpNum? the imaginary error function, $\text{erfi}(x)$.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The imaginary error function is defined in analogy with the error function, but with a positive sign in the integrand:

\begin{equation}
\text{erfi}(x) = \frac{2}{\sqrt{\pi}} \int_0^x \exp(t^2)dt
\end{equation}


Whereas the error function rapidly converges to 1 as grows, the imaginary error function rapidly diverges to infinity. The functions are related as $\text{erfi}(x)=-i\text{ erf}(ix)$ for all complex numbers $x$.

\vpara
Examples

Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> erfi(0)
0.0
>>> erfi(1)
1.65042575879754
>>> erfi(-1)
-1.65042575879754
>>> erfi(inf)
+inf
>>> erfi(-inf)
-inf
\end{lstlisting}

Large arguments are supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> erfi(1000)
1.71130938718796e+434291
>>> erfi(10**10)
7.3167287567024e+43429448190325182754
>>> erfi(-10**10)
-7.3167287567024e+43429448190325182754
>>> erfi(1000-500j)
(2.49895233563961e+325717 + 2.6846779342253e+325717j)
>>> erfi(100000j)
(0.0 + 1.0j)
>>> erfi(-100000j)
(0.0 - 1.0j)
\end{lstlisting}

Complex arguments are supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> erfc(500+50j)
(1.19739830969552e-107492 + 1.46072418957528e-107491j)
\end{lstlisting}



\subsection{Inverse Error Function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{erfinv? mpNum? the inverse error function, $\text{erfinv}(x)$.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vpara
The inverse error function satisfies $\text{erf(erfinv}(x))=\text{erfinv(erf}(x))=x$. This function is defined only for $-1<x<1$.

Examples

Special values include:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> erfinv(0)
0.0
>>> erfinv(1)
+inf
>>> erfinv(-1)
-inf
\end{lstlisting}

erfinv() supports arbitrary-precision evaluation:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 50
>>> x = erf(2)
>>> x
0.99532226501895273416206925636725292861089179704006
>>> erfinv(x)
2.0\end{lstlisting}



\newpage
\section{The normal distribution}
\subsection{The normal probability density function}


\begin{mpFunctionsExtract}
	\mpFunctionThree
	{npdf? mpNum? the normal probability density function.}
	{x? mpNum? A real number.}
	{mu? mpNum? A real number.}
	{sigma? mpNum? A real number.}
\end{mpFunctionsExtract}

\vpara
npdf(x, mu=0, sigma=1) evaluates the probability density function of a normal distribution with mean value $\mu$ and variance $\sigma^2$.

Elementary properties of the probability distribution can be verified using numerical integration:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> quad(npdf, [-inf, inf])
1.0
>>> quad(lambda x: npdf(x, 3), [3, inf])
0.5
>>> quad(lambda x: npdf(x, 3, 2), [3, inf])
0.5
\end{lstlisting}



\subsection{The normal cumulative distribution function}


\begin{mpFunctionsExtract}
	\mpFunctionThree
	{ncdf? mpNum? the normal cumulative distribution function.}
	{x? mpNum? A real number.}
	{mu? mpNum? A real number.}
	{sigma? mpNum? A real number.}
\end{mpFunctionsExtract}

\vpara
ncdf(x, mu=0, sigma=1) evaluates the cumulative distribution function of a normal distribution with mean value $\mu$ and variance $\sigma^2$.

See also npdf(), which gives the probability density.

Elementary properties include:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> ncdf(pi, mu=pi)
0.5
>>> ncdf(-inf)
0.0
>>> ncdf(+inf)
1.0
\end{lstlisting}


\newpage
\section{Fresnel integrals}

\subsection{Fresnel sine integral}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{fresnels? mpNum? the Fresnel sine integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


The Fresnel sine integral is defined as

\begin{equation}
S(x) = \int_0^x \sin\left(\frac{\pi t^2}{2}  \right) dt
\end{equation}

Note that some sources define this function without the normalization factor $\pi/2$.

\vpara
Examples

Some basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> fresnels(0)
0.0
>>> fresnels(inf)
0.5
>>> fresnels(-inf)
-0.5
>>> fresnels(1)
0.4382591473903547660767567
>>> fresnels(1+2j)
(36.72546488399143842838788 + 15.58775110440458732748279j)
\end{lstlisting}


\subsection{Fresnel cosine integral}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{fresnelc? mpNum? the Fresnel cosine integral.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

The Fresnel cosine integral is defined as

\begin{equation}
C(x) = \int_0^x \cos\left(\frac{\pi t^2}{2}  \right) dt
\end{equation}



Note that some sources define this function without the normalization factor $\pi/2$.

\vpara
Examples

Some basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> fresnelc(0)
0.0
>>> fresnelc(inf)
0.5
>>> fresnelc(-inf)
-0.5
>>> fresnelc(1)
0.7798934003768228294742064
>>> fresnelc(1+2j)
(16.08787137412548041729489 - 36.22568799288165021578758j)
\end{lstlisting}



\newpage
\section{Other Special Functions}

%
%\subsection{Arithmetic-geometric mean}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{AgmMpMath? mpNum? the arithmetic-geometric mean of $|x|$ and $|y|$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%With $a_0 = \max(|x|, |y|)$, $b_0 = \min(|x|, |y|)$ the AGM is calculated using the recurrence formulas
%
%\begin{equation}
%a_{n+1} = \tfrac{1}{2} (a_n + b_n), \quad b_{n+1} = \sqrt{a_n b_n}.
%\end{equation}
%
%The sequences converge quadratically to a common limit and $a_n \geq b_n$ . The iteration is terminated if $a_n - b_n \leq \epsilon a_n$, where $\epsilon$ is less than the square root of the machine epsilon. The result is $(a_n + b_n )/2$.
%
%


%
%\subsection{Integral of cos powers}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{CosIntMpMath? mpNum? the integral of the $n$th cos power.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The integral of the $n$th cos power is defined as
%\begin{equation}
%\text{IC}_n(x) = \int_0^x cos^n t dt.
%\end{equation}
%
%
%
%
%\subsection{Integral of sin powers}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{SinIntMpMath? mpNum? the integral of the $n$th sin power.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The integral of the $n$th sin power is defined as
%\begin{equation}
%\text{IC}_n(x) = \int_0^x sin^n t dt.
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Lambert Functions }W_0(x) \text{ and }W_{-1}(x)$}{Lambert functions}}

%The multivalued Lambert W function is defined as a solution of
%\begin{equation}
%W(x) e ^{W (x)} = x.
%\end{equation}
%
%This function has two real branches for $x < 0$ with a branch point at $x = -1/e$.
%
%LambertW0$(x)$ = $W_0 (x)$ is the principal branch with $W_0 (x) \geq -1$ for $x < 0$, and
%
%LambertWm1$(x)$ = $W_{-1} (x)$ is the other real branch with $W_{-1}(x) \leq -1$ for $x < 0$.
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LambertW0MpMath? mpNum? the value of the Lambert functions $W_0(x)$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LambertWm1MpMath? mpNum? the value of the Lambert functions $W_{-1}(x)$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%


\subsection{Lambert W function}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{lambertw? mpNum? the Lambert W function.}
	{z? mpNum? A real or complex number.}
	{Keywords? String? k=0.}	
\end{mpFunctionsExtract}

\vpara
The Lambert W function $W(z)$ is defined as the inverse function of $w \exp(w)$. In other words, the value of $W(z) $is such that $z=W(z) \exp(W(z))$ for any complex number $z$.

\vpara
The Lambert W function is a multivalued function with infinitely many branches $W_k(z)$, indexed by $k \in \mathbb{Z}$. Each branch gives a different solution $w$ of the equation $z=w \exp(w)$. All branches are supported by lambertw():

\vpara
lambertw(z) gives the principal solution (branch 0).

\vpara
lambertw(z, k) gives the solution on branch $k$.

\vpara
The Lambert W function has two partially real branches: the principal branch ($k=0$) is real for real $z>-1/e$, and the branch $k=-1$ is real for $-1/e <z<0$. All branches except $k=0$ have a logarithmic singularity at $z=0$.

\vpara
The definition, implementation and choice of branches is based on \cite{Corless96onthe}.

\vpara
Basic examples

The Lambert W function is the inverse of $w \exp(w)$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> w = lambertw(1)
>>> w
0.5671432904097838729999687
>>> w*exp(w)
1.0
\end{lstlisting}

Any branch gives a valid inverse:
\lstset{language={Python}}
\begin{lstlisting}
>>> w = lambertw(1, k=3)
>>> w
(-2.853581755409037807206819 + 17.11353553941214591260783j)
>>> w = lambertw(1, k=25)
>>> w
(-5.047020464221569709378686 + 155.4763860949415867162066j)
>>> chop(w*exp(w))
1.0
\end{lstlisting}





\subsection{Arithmetic-geometric mean}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{agm? mpNum? the arithmetic-geometric mean of $a$ and $b$.}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
agm(a, b) computes the arithmetic-geometric mean of $a$ and $b$, defined as the limit of the following iteration:

\begin{equation}
	a_0=a; \quad b_0=b; \quad a_{n+1}= \tfrac{1}{2}(a_n + b_n); \quad b_{n+1}=\sqrt{a_n b_n}.
\end{equation}


This function can be called with a single argument, computing $\text{agm}(a, 1)=\text{agm}(1, a)$.

\vpara
Examples

It is a well-known theorem that the geometric mean of two distinct positive numbers is less than the arithmetic mean. It follows that the arithmetic-geometric mean lies between the two means:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> a = mpf(3)
>>> b = mpf(4)
>>> sqrt(a*b)
3.46410161513775
>>> agm(a,b)
3.48202767635957
>>> (a+b)/2
3.5
\end{lstlisting}

The arithmetic-geometric mean can also be computed for complex numbers:

\lstset{language={Python}}
\begin{lstlisting}
>>> agm(3, 2+j)
(2.51055133276184 + 0.547394054060638j)
\end{lstlisting}

A formula for $\Gamma(1/4)$:
\lstset{language={Python}}
\begin{lstlisting}
>>> gamma(0.25)
3.62560990822191
>>> sqrt(2*sqrt(2*pi**3)/agm(1,sqrt(2)))
3.62560990822191
\end{lstlisting}





\newpage
\chapter{Bessel functions and related functions}
The functions in this section arise as solutions to various differential equations in physics, typically describing wavelike oscillatory behavior or a combination of oscillation and exponential decay or growth. Mathematically, they are special cases of the confluent hypergeometric functions ${}_0F_1, {}_1F_1$ and ${}_1F_2$ (see Hypergeometric functions).



\section{Bessel functions}

\subsection{\texorpdfstring{$\text{Exponentially scaled Bessel function }I_{\nu,e}(x)$}{Bessel Function Inu Scaled}}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{BesselIeMpMath? mpNum? $I_{\nu, e}(x) = I_{\nu}(x) \exp(-|x|)$, the exponentially scaled modified Bessel function $I_{\nu}(z)$ of the first kind of order $\nu$, $x \geq 0$ if $\nu$ is not an integer.}
	{x? mpNum? A real number.}
	{$\nu$? mpNum? A real number.}
\end{mpFunctionsExtract}




\subsection{\texorpdfstring{$\text{Exponentially scaled Bessel function }K_{\nu,e}(x)$}{Bessel Function Knu Scaled}}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{BesselKeMpMath? mpNum? $K_{\nu, e}(x) = K_{\nu}(x) \exp(x)$, the exponentially scaled modified Bessel function $K_{\nu}(z)$ of the first kind of order $\nu$, $x > 0$.}
	{x? mpNum? A real number.}
	{$\nu$? mpNum? A real number.}
\end{mpFunctionsExtract}



\subsection{Bessel function of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{besselj? mpNum? the Bessel function of the first kind $J_n(x)$.}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
Bessel functions of the first kind are defined as solutions of the differential equation

\begin{equation}
x^2 y'' + xy' + (x^2-n^2)y=0
\end{equation}

which appears, among other things, when solving the radial part of Laplace's equation in cylindrical coordinates. This equation has two solutions for given $n$, where the $J_n$-function is the solution that is nonsingular at $x=0$. For positive integer $n$, $J_n(x)$behaves roughly like a sine (odd $n$) or cosine (even $n$) multiplied by a magnitude factor that decays slowly as $x \rightarrow \pm \infty$.

\vpara
Generally, $J_n$ is a special case of the hypergeometric function ${}_0F_1$:

\begin{equation}
J_n(x)=\frac{x^n}{2^n \Gamma(n+1)}{}_0F_1 \left(n+1, -\frac{x^2}{4}  \right)
\end{equation}

With derivative = $m \neq 0$, the $m$-th derivative

\begin{equation}
\frac{d^m}{dx^m} J_n(x)
\end{equation}

is computed.

Evaluation is supported for arbitrary arguments, and at arbitrary precision:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> besselj(2, 1000)
-0.024777229528606
>>> besselj(4, 0.75)
0.000801070086542314
>>> besselj(2, 1000j)
(-2.48071721019185e+432 + 6.41567059811949e-437j)
>>> mp.dps = 25
>>> besselj(0.75j, 3+4j)
(-2.778118364828153309919653 - 1.5863603889018621585533j)
>>> mp.dps = 50
>>> besselj(1, pi)
0.28461534317975275734531059968613140570981118184947
\end{lstlisting}

Arguments may be large:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 25
>>> besselj(0, 10000)
-0.007096160353388801477265164
>>> besselj(0, 10**10)
0.000002175591750246891726859055
>>> besselj(2, 10**100)
7.337048736538615712436929e-51
>>> besselj(2, 10**5*j)
(-3.540725411970948860173735e+43426 + 4.4949812409615803110051e-43433j)
\end{lstlisting}

Derivatives of any order can be computed (negative orders correspond to integration):

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 25
>>> besselj(0, 7.5, 1)
-0.1352484275797055051822405
>>> diff(lambda x: besselj(0,x), 7.5)
-0.1352484275797055051822405
>>> besselj(0, 7.5, 10)
-0.1377811164763244890135677
>>> diff(lambda x: besselj(0,x), 7.5, 10)
-0.1377811164763244890135677
>>> besselj(0,7.5,-1) - besselj(0,3.5,-1)
-0.1241343240399987693521378
>>> quad(j0, [3.5, 7.5])
-0.1241343240399987693521378
\end{lstlisting}


\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{j0? mpNum? the Bessel function $J_0(x)$.}
	{x? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


Computes the Bessel function $J_0(x)$. See besselj().

\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{j1? mpNum? the Bessel function $J_1(x)$.}
	{x? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

Computes the Bessel function $J_1(x)$. See besselj().



\subsection{Bessel function of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{bessely? mpNum? the Bessel function of the second kind $Y_n(x)$.}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}


The Bessel function of the second kind are defined as

\begin{equation}
Y_n(x)=\frac{J_n(x) \cos(\pi n) - J_{-n}(x)}{\sin(\pi n)}
\end{equation}

For $n$ an integer, this formula should be understood as a limit. With derivative = $m \neq 0$, the $m$-th derivative 

\begin{equation}
\frac{d^m}{dx^m} Y_n(x)
\end{equation}

is computed.

Evaluation is supported for arbitrary arguments, and at arbitrary precision:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> bessely(0,0), bessely(1,0), bessely(2,0)
(-inf, -inf, -inf)
>>> bessely(1, pi)
0.3588729167767189594679827
>>> bessely(0.5, 3+4j)
(9.242861436961450520325216 - 3.085042824915332562522402j)
\end{lstlisting}

Arguments may be large:

\lstset{language={Python}}
\begin{lstlisting}
>>> bessely(0, 10000)
0.00364780555898660588668872
>>> bessely(2.5, 10**50)
-4.8952500412050989295774e-26
>>> bessely(2.5, -10**50)
(0.0 + 4.8952500412050989295774e-26j)
\end{lstlisting}


Derivatives and antiderivatives of any order can be computed:

\lstset{language={Python}}
\begin{lstlisting}
>>> bessely(2, 3.5, 1)
0.3842618820422660066089231
>>> diff(lambda x: bessely(2, x), 3.5)
0.3842618820422660066089231
>>> bessely(0.5, 3.5, 1)
-0.2066598304156764337900417
>>> diff(lambda x: bessely(0.5, x), 3.5)
-0.2066598304156764337900417
>>> diff(lambda x: bessely(2, x), 0.5, 10)
-208173867409.5547350101511
>>> bessely(2, 0.5, 10)
-208173867409.5547350101511
>>> bessely(2, 100.5, 100)
0.02668487547301372334849043
>>> quad(lambda x: bessely(2,x), [1,3])
-1.377046859093181969213262
>>> bessely(2,3,-1) - bessely(2,1,-1)
-1.377046859093181969213262
\end{lstlisting}



\subsection{Modified Bessel function of the  first kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{besseli? mpNum? the modified Bessel function of the first kind $J_n(x)$.}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}



The modified Bessel function of the first kind are defined as

\begin{equation}
I_n(x)=i^{-n}J_n(ix)
\end{equation}

With derivative = $m \neq 0$, the $m$-th derivative

\begin{equation}
\frac{d^m}{dx^m}I_n(x)
\end{equation}

is computed.

Evaluation is supported for arbitrary arguments, and at arbitrary precision:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> besseli(0,0)
1.0
>>> besseli(1,0)
0.0
>>> besseli(0,1)
1.266065877752008335598245
>>> besseli(3.5, 2+3j)
(-0.2904369752642538144289025 - 0.4469098397654815837307006j)
\end{lstlisting}

Arguments may be large:

\lstset{language={Python}}
\begin{lstlisting}
>>> besseli(2, 1000)
2.480717210191852440616782e+432
>>> besseli(2, 10**10)
4.299602851624027900335391e+4342944813
>>> besseli(2, 6000+10000j)
(-2.114650753239580827144204e+2603 + 4.385040221241629041351886e+2602j)
\end{lstlisting}


Derivatives and antiderivatives of any order can be computed:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 25
>>> besseli(2, 7.5, 1)
195.8229038931399062565883
>>> diff(lambda x: besseli(2,x), 7.5)
195.8229038931399062565883
>>> besseli(2, 7.5, 10)
153.3296508971734525525176
>>> diff(lambda x: besseli(2,x), 7.5, 10)
153.3296508971734525525176
>>> besseli(2,7.5,-1) - besseli(2,3.5,-1)
202.5043900051930141956876
>>> quad(lambda x: besseli(2,x), [3.5, 7.5])
202.5043900051930141956876
\end{lstlisting}




\subsection{Modified Bessel function of the  second kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{besselk? mpNum? the modified Bessel function of the second kind $K_n(x)$.}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}



The modified Bessel function of the second kind are defined as

\begin{equation}
K_n(x)= \frac{\pi}{2} \frac{I_{-n}(x) - I_n(x)}{\sin(\pi n)}
\end{equation}

For $n$ an integer, this formula should be understood as a limit.

Evaluation is supported for arbitrary arguments, and at arbitrary precision:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> besselk(0,1)
0.4210244382407083333356274
>>> besselk(0, -1)
(0.4210244382407083333356274 - 3.97746326050642263725661j)
>>> besselk(3.5, 2+3j)
(-0.02090732889633760668464128 + 0.2464022641351420167819697j)
>>> besselk(2+3j, 0.5)
(0.9615816021726349402626083 + 0.1918250181801757416908224j)
\end{lstlisting}

Arguments may be large:

\lstset{language={Python}}
\begin{lstlisting}
>>> besselk(0, 100)
4.656628229175902018939005e-45
>>> besselk(1, 10**6)
4.131967049321725588398296e-434298
>>> besselk(1, 10**6*j)
(0.001140348428252385844876706 - 0.0005200017201681152909000961j)
>>> besselk(4.5, fmul(10**50, j, exact=True))
(1.561034538142413947789221e-26 + 1.243554598118700063281496e-25j)
\end{lstlisting}




\newpage
\section{Bessel function zeros}


\subsection{Zeros of the Bessel function of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{besseljzero? mpNum? the m-th positive zero of the Bessel function of the first kind}
	{v? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
For a real order $\nu \geq 0$ and a positive integer $m$, returns $j_{\nu, m}$, the m-th positive zero of the Bessel function of the first kind $J_{\nu}(z)$(see besselj()). Alternatively, with derivative=1, gives the first nonnegative simple zero $j'_{\nu, m}$ of $J'_{\nu}(z)$.

The indexing convention is that used by Abramowitz \& Stegun and the DLMF. Note the special case $j'_{0,1}=0$, while all other zeros are positive. In effect, only simple zeros are counted (all zeros of Bessel functions are simple except possibly $z=0$) and becomes a monotonic function of both $\nu$ and $m$.

The zeros are interlaced according to the inequalities

\begin{equation}
j'_{\nu,k} < j_{\nu,k} < j'_{\nu,k+1}
\end{equation}
\begin{equation}
j_{\nu,1} < j_{\nu+1,2} < j_{\nu,2} < j'_{\nu,k+1} < j_{\nu+1,2} < j_{\nu,3}
\end{equation}

Initial zeros of the Bessel functions $J_0(z), J_1(z), J_2(z)$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> besseljzero(0,1); besseljzero(0,2); besseljzero(0,3)
2.404825557695772768621632
5.520078110286310649596604
8.653727912911012216954199
>>> besseljzero(1,1); besseljzero(1,2); besseljzero(1,3)
3.831705970207512315614436
7.01558666981561875353705
10.17346813506272207718571
>>> besseljzero(2,1); besseljzero(2,2); besseljzero(2,3)
5.135622301840682556301402
8.417244140399864857783614
11.61984117214905942709415
\end{lstlisting}

Initial zeros of $J'_0(z), J'_1(z), J'_2(z)$:

\lstset{language={Python}}
\begin{lstlisting}
>>> besseljzero(0,1,1); besseljzero(0,2,1); besseljzero(0,3,1)
0.0
3.831705970207512315614436
7.01558666981561875353705
>>> besseljzero(1,1,1); besseljzero(1,2,1); besseljzero(1,3,1)
1.84118378134065930264363
5.331442773525032636884016
8.536316366346285834358961
>>> besseljzero(2,1,1); besseljzero(2,2,1); besseljzero(2,3,1)
3.054236928227140322755932
6.706133194158459146634394
9.969467823087595793179143
\end{lstlisting}

Zeros with large index:

\lstset{language={Python}}
\begin{lstlisting}
>>> besseljzero(0,100); besseljzero(0,1000); besseljzero(0,10000)
313.3742660775278447196902
3140.807295225078628895545
31415.14114171350798533666
>>> besseljzero(5,100); besseljzero(5,1000); besseljzero(5,10000)
321.1893195676003157339222
3148.657306813047523500494
31422.9947255486291798943
>>> besseljzero(0,100,1); besseljzero(0,1000,1); besseljzero(0,10000,1)
311.8018681873704508125112
3139.236339643802482833973
31413.57032947022399485808
\end{lstlisting}



\subsection{Zeros of the Bessel function of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{besselyzero? mpNum? the m-th positive zero of the Bessel function of the second kind}
	{v? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
For a real order $\nu > 0$ and a positive integer $m$, returns $y_{\nu, m}$, the m-th positive zero of the Bessel function of the second kind $Y_{\nu}(z)$(see besselj()). Alternatively, with derivative=1, gives the first nonnegative simple zero $y'_{\nu, m}$ of $Y'_{\nu}(z)$.

The zeros are interlaced according to the inequalities

\begin{equation}
y'_{\nu,k} < y_{\nu,k} < y'_{\nu,k+1}
\end{equation}
\begin{equation}
y_{\nu,1} < y_{\nu+1,2} < y_{\nu,2} < y'_{\nu,k+1} < y_{\nu+1,2} < y_{\nu,3}
\end{equation}

Initial zeros of the Bessel functions $Y_0(z), Y_1(z), Y_2(z)$:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> besselyzero(0,1); besselyzero(0,2); besselyzero(0,3)
0.8935769662791675215848871
3.957678419314857868375677
7.086051060301772697623625
>>> besselyzero(1,1); besselyzero(1,2); besselyzero(1,3)
2.197141326031017035149034
5.429681040794135132772005
8.596005868331168926429606
>>> besselyzero(2,1); besselyzero(2,2); besselyzero(2,3)
3.384241767149593472701426
6.793807513268267538291167
10.02347797936003797850539
\end{lstlisting}

Initial zeros of $Y'_0(z), Y'_1(z), Y'_2(z)$::

\lstset{language={Python}}
\begin{lstlisting}
>>> besselyzero(0,1,1); besselyzero(0,2,1); besselyzero(0,3,1)
2.197141326031017035149034
5.429681040794135132772005
8.596005868331168926429606
>>> besselyzero(1,1,1); besselyzero(1,2,1); besselyzero(1,3,1)
3.683022856585177699898967
6.941499953654175655751944
10.12340465543661307978775
>>> besselyzero(2,1,1); besselyzero(2,2,1); besselyzero(2,3,1)
5.002582931446063945200176
8.350724701413079526349714
11.57419546521764654624265
\end{lstlisting}

Zeros with large index:

\lstset{language={Python}}
\begin{lstlisting}
>>> besselyzero(0,100); besselyzero(0,1000); besselyzero(0,10000)
311.8034717601871549333419
3139.236498918198006794026
31413.57034538691205229188
>>> besselyzero(5,100); besselyzero(5,1000); besselyzero(5,10000)
319.6183338562782156235062
3147.086508524556404473186
31421.42392920214673402828
>>> besselyzero(0,100,1); besselyzero(0,1000,1); besselyzero(0,10000,1)
313.3726705426359345050449
3140.807136030340213610065
31415.14112579761578220175
\end{lstlisting}


%
%\newpage
%\section{Spherical Bessel Functions}
%\label{BesselFunctions7MpMath}
%
%
%\subsection{\texorpdfstring{$\text{Spherical Bessel function }j_n(x)$}{jjnx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{SphericalBesseljMpMath? mpNum? $j_n(x)$, the spherical Bessel function of the 1st kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Except for $n = 0$ where the value $\text{sinc}(x)$ is used, the result is calculated just from the  definition [1, 10.1.1]:
%\begin{equation}
%	j_n(x) = \sqrt{\tfrac{1}{2}\pi/x} J_{n+\tfrac{1}{2}}(x), \quad (x\leq 0), \quad \text{and } j_n(-x)=(-1)^n j_n(x).
%\end{equation}
%
%
%
%\subsection{\texorpdfstring{$\text{Spherical Bessel function }y_n(x)$}{yynx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{SphericalBesselyMpMath? mpNum? $y_n(x)$, the spherical Bessel function of the second kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The spherical Bessel function of the second kind, order $n$, $x \neq 0$ is defined as
%\begin{equation}
%	y_n(x) = \sqrt{\tfrac{1}{2}\pi/x} Y_{n+\tfrac{1}{2}}(x), \quad (x > 0), \quad \text{and } y_n(-x)=(-1)^{n+1} y_n(x).
%\end{equation}
%
%
%
%\subsection{\texorpdfstring{$\text{Modified spherical Bessel function }i_n(x)$}{Iinx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{SphericalBesseliMpMath? mpNum? $i_n(x)$, the modified spherical Bessel function of the 1st (and 2nd) kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Except for $n = 0$ where the value $\text{sinh}(x)/x$ is used, the result is calculated just from the  definition:
%\begin{equation}
%	i_n(x) = \sqrt{\tfrac{1}{2}\pi/x} I_{n+\tfrac{1}{2}}(x), \quad (x\geq 0), \quad \text{and } i_n(-x)=(-1)^n i_n(x).
%\end{equation}
%with the reflection formula from [30, 10.47.16]. Note that $i_n$ is named $i^{(1)}_n$ in the NIST
%handbook [30] and restricted to $n \geq 0$, the modified spherical Bessel function of the 2nd kind is then defined as
%\begin{equation}
%	i^{(2)}_n = \sqrt{\tfrac{1}{2}\pi/x} I_{-n-\tfrac{1}{2}}(x), 
%\end{equation}
%which can be expressed by $i_n$, i.e.
%\begin{equation}
%	i^{(1)}_n = i_n(x), \quad i^{(2)}_n = i_{-n-1}(x), \quad (\text{for }n \geq 0).
%\end{equation}
%
%
%\subsection{\texorpdfstring{$\text{Exponentially scaled Bessel function }i_{n,e}(x)$}{Iinex}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{SphericalBesselieMpMath? mpNum? $i_n(x) \exp(−|x|)$, the exponentially scaled modified spherical Bessel function of the 1st/2nd kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%For $n = 0$ the result is
%\begin{equation}
%	i_{0.e}(x)=-\frac{\text{expm1}(-2|x|)}{2|x|},
%\end{equation}
%otherwise $I_{\nu,e}(x)$, the exponentially scaled modified Bessel function of the 1st kind, is used
%\begin{equation}
%	i_{n,e}(x) = \sqrt{\tfrac{1}{2}\pi/x} I_{n+\tfrac{1}{2},e}(x), \quad (x\geq 0), \quad \text{and } i_{n,e}(-x)=(-1)^n i_{n,e}(x).
%\end{equation}
%
%\subsection{\texorpdfstring{$\text{Modified spherical Bessel function }k_n(x)$}{kknx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{SphericalBesselkMpMath? mpNum? $k_n(x)$, the modified spherical Bessel function of the 3rd kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Except for $n = 0$ where the value $\tfrac{1}{2}\pi \exp(-x)/x$ is used, the result is calculated just from the  definition [1, 10.1.1]:
%\begin{equation}
%	k_n(x) = \sqrt{\tfrac{1}{2}\pi/x} K_{n+\tfrac{1}{2}}(x), \quad (x> 0).
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Exponentially scaled  Bessel function }k_{n,e}(x)$}{kkinex}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{SphericalBesselkeMpMath? mpNum? $k_n(x) \exp(x)$, the exponentially scaled modified spherical Bessel function of the 3rd kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%For $n = 0$ the result is $\pi /(2x)$, otherwise $K_{\nu,e}(x)$, the exponentially scaled modified Bessel function of the 2nd kind, is used
%\begin{equation}
%	k_{n,e}(x) = \sqrt{\tfrac{1}{2}\pi/x} K_{n+\tfrac{1}{2},e}(x), \quad (x> 0).
%\end{equation}
%
%
%
%
%




\newpage
\section{Hankel functions}


\subsection{Hankel function of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{hankel1? mpNum? the Hankel function of the first kind}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Hankel function of the first kind is the complex combination of Bessel functions given by

\begin{eqnarray}
H_n^{(1)}(x) = J_n(x)+iY_n(x).
\end{eqnarray}

The Hankel function is generally complex-valued:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hankel1(2, pi)
(0.4854339326315091097054957 - 0.0999007139290278787734903j)
>>> hankel1(3.5, pi)
(0.2340002029630507922628888 - 0.6419643823412927142424049j)
\end{lstlisting}



\subsection{Hankel function of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{hankel2? mpNum? the Hankel function of the second kind}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Hankel function of the second kind is the complex combination of Bessel functions given by

\begin{eqnarray}
H_n^{(2)}(x) = J_n(x)-iY_n(x).
\end{eqnarray}

The Hankel function is generally complex-valued:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hankel2(2, pi)
(0.4854339326315091097054957 + 0.0999007139290278787734903j)
>>> hankel2(3.5, pi)
(0.2340002029630507922628888 + 0.6419643823412927142424049j)
\end{lstlisting}




\newpage
\section{Kelvin functions}

\subsection{Kelvin function ber}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{ber? mpNum? the Kelvin function ber}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Kelvin function ber returns for real arguments the real part of the Bessel J function of a rotated argument

\begin{equation}
J_n(x e^{3\pi i/4}) = \text{ber}_n(x) + i \text{bei}_n(x).
\end{equation}

The imaginary part is given by bei().

Verifying the defining relation:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> n, x = 2, 3.5
>>> ber(n,x)
1.442338852571888752631129
>>> bei(n,x)
-0.948359035324558320217678
>>> besselj(n, x*root(1,8,3))
(1.442338852571888752631129 - 0.948359035324558320217678j)
\end{lstlisting}


The ber and bei functions are also defined by analytic continuation for complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> ber(1+j, 2+3j)
(4.675445984756614424069563 - 15.84901771719130765656316j)
>>> bei(1+j, 2+3j)
(15.83886679193707699364398 + 4.684053288183046528703611j)
\end{lstlisting}



\subsection{Kelvin function bei}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{bei? mpNum? the Kelvin function bei}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


\vpara
The Kelvin function bei returns for real arguments the imaginary part of the Bessel J function of a rotated argument. See ber().


\subsection{Kelvin function ker}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{ker? mpNum? the Kelvin function ker}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Kelvin function ker returns for real arguments the real part of the (rescaled) Bessel K function of a rotated argument


\begin{equation}
e^{-\pi i/2}  K_n(x e^{3\pi i/4}) = \text{ker}_n(x) + i \text{kei}_n(x).
\end{equation}

The imaginary part is given by kei().

Verifying the defining relation:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> n, x = 2, 4.5
>>> ker(n,x)
0.02542895201906369640249801
>>> kei(n,x)
-0.02074960467222823237055351
>>> exp(-n*pi*j/2) * besselk(n, x*root(1,8,1))
(0.02542895201906369640249801 - 0.02074960467222823237055351j)
\end{lstlisting}



The ker and kei functions are also defined by analytic continuation for complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> ker(1+j, 3+4j)
(1.586084268115490421090533 - 2.939717517906339193598719j)
>>> kei(1+j, 3+4j)
(-2.940403256319453402690132 - 1.585621643835618941044855j)
\end{lstlisting}



\subsection{Kelvin function kei}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{kei? mpNum? the Kelvin function kei}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Kelvin function kei returns for real arguments the imaginary part of the (rescaled) Bessel K function of a rotated argument. See ker().




\newpage

\section{Struve Functions}
\label{StruveFunctions4MpMath}

The Struve functions $\textbf{H}_{\nu}(x)$ and the modified Struve functions $\textbf{L}_{\nu}(x)$ have the power series expansions (see \citet{abramowitz_handbook_1970} [1, 12.1.3 and 12.2.1]):
\begin{equation}
\textbf{H}_{\nu}(x) = \left(\tfrac{1}{2}x\right)^{\nu+1} \sum_{k=0}^\infty \frac{(-1)^{k}\left(\tfrac{1}{2}x\right)^{2k}}{\Gamma\left(k+\tfrac{3}{2}\right) \Gamma\left(k+\nu+\tfrac{3}{2}\right)}
\end{equation}


\begin{equation}
\textbf{L}_{\nu}(x) = \left(\tfrac{1}{2}x\right)^{\nu+1} \sum_{k=0}^\infty \frac{\left(\tfrac{1}{2}x\right)^{2k}}{\Gamma\left(k+\tfrac{3}{2}\right) \Gamma\left(k+\nu+\tfrac{3}{2}\right)}
\end{equation}

%
%\subsection{\texorpdfstring{$\text{Struve function }H_0(x)$}{StruveH0}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{StruveH0MpMath? mpNum? $\textbf{H}_{0}(x)$, the Struve function of order zero.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Struve function }H_1(x)$}{StruveH1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{StruveH1MpMath? mpNum? $\textbf{H}_{1}(x)$, the Struve function of order one.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Struve function }L_0(x)$}{StruveL0}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{StruveL0MpMath? mpNum? $\textbf{L}_{0}(x)$, the modified Struve function of order zero.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Struve function }L_1(x)$}{StruveL1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{StruveL1MpMath? mpNum? $\textbf{L}_{1}(x)$, the modified Struve function of order one.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%



\subsection{Struve function H}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{struveh? mpNum? the Struve function H}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


The Struve function H is defined as

\begin{equation}
\textbf{H}_n(z)=\sum_{k=0}^{\infty} \frac{(-1)^k}{\Gamma\left(k+\frac{3}{2}\right)\Gamma\left(k+n+\frac{3}{2}\right)}\left(\frac{z}{2}\right)^{2k+n+1}
\end{equation}

which is a solution to the Struve differential equation

\begin{equation}
z^2f''(z)+zf'(z)+(z^2-n^2)f(z)=\frac{2z^{n+1}}{\pi(2n-1)!!}
\end{equation}

Examples
Evaluation for arbitrary real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> struveh(0, 3.5)
0.3608207733778295024977797
>>> struveh(-1, 10)
-0.255212719726956768034732
>>> struveh(1, -100.5)
0.5819566816797362287502246
>>> struveh(2.5, 10000000000000)
3153915652525200060.308937
>>> struveh(2.5, -10000000000000)
(0.0 - 3153915652525200060.308937j)
>>> struveh(1+j, 1000000+4000000j)
(-3.066421087689197632388731e+1737173 - 1.596619701076529803290973e+1737173j)
\end{lstlisting}



\subsection{Modified Struve function L}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{struvel? mpNum? the modified Struve function L}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The modified Struve function $\textbf{L}_n(z)$ is defined as

\begin{eqnarray}
\textbf{L}_n(z)=-i e^{-n\pi i/2}H_n(iz)
\end{eqnarray}

which solves to the modified Struve differential equation

\begin{equation}
z^2f''(z)+zf'(z)+(z^2+n^2)f(z)=\frac{2z^{n+1}}{\pi(2n-1)!!}
\end{equation}


Examples

Evaluation for arbitrary real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> struvel(0, 3.5)
7.180846515103737996249972
>>> struvel(-1, 10)
2670.994904980850550721511
>>> struvel(1, -100.5)
1.757089288053346261497686e+42
>>> struvel(2.5, 10000000000000)
4.160893281017115450519948e+4342944819025
>>> struvel(2.5, -10000000000000)
(0.0 - 4.160893281017115450519948e+4342944819025j)
>>> struvel(1+j, 700j)
(-0.1721150049480079451246076 + 0.1240770953126831093464055j)
>>> struvel(1+j, 1000000+4000000j)
(-2.973341637511505389128708e+434290 - 5.164633059729968297147448e+434290j)
\end{lstlisting}



\newpage
\section{Anger-Weber functions}


\subsection{Anger function J}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{angerj? mpNum? the Anger function J}
	{v? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


\vpara
The Anger function $\textbf{J}_{\nu}(z)$ is defined as

\begin{eqnarray}
\textbf{J}_{\nu}(z) = \frac{1}{\pi} \int_0^{\pi} \cos(\nu t - z \sin(t)) dt
\end{eqnarray}

which is an entire function of both the parameter $\nu$ and the argument $z$. It solves the inhomogeneous Bessel differential equation

\begin{equation}
f''(z)+\frac{1}{z} f'(z) + \left(1-\frac{\nu^2}{z^2} \right)f(z) = \frac{(z-\nu)}{\pi z^2} \sin(\pi\nu).
\end{equation}

Examples

Evaluation for real and complex parameter and argument:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> angerj(2,3)
0.4860912605858910769078311
>>> angerj(-3+4j, 2+5j)
(-5033.358320403384472395612 + 585.8011892476145118551756j)
>>> angerj(3.25, 1e6j)
(4.630743639715893346570743e+434290 - 1.117960409887505906848456e+434291j)
>>> angerj(-1.5, 1e6)
0.0002795719747073879393087011
\end{lstlisting}



\subsection{Weber function E}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{webere? mpNum? the Weber function E}
	{v? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Weber function $\textbf{E}_{\nu}(z)$ is defined as
\begin{eqnarray}
\textbf{E}_{\nu}(z) = \frac{1}{\pi} \int_0^{\pi} \sin(\nu t - z \sin(t)) dt
\end{eqnarray}

which is an entire function of both the parameter $\nu$ and the argument $z$. It solves the inhomogeneous Bessel differential equation

\begin{equation}
f''(z)+\frac{1}{z} f'(z) + \left(1-\frac{\nu^2}{z^2} \right)f(z) = \frac{1}{\pi z^2} (z+\nu+(z-\nu) \cos(\pi\nu)).
\end{equation}


Examples

Evaluation for real and complex parameter and argument:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpmath import *
>>> mp.dps = 25; mp.pretty = True
>>> webere(2,3)
-0.1057668973099018425662646
>>> webere(-3+4j, 2+5j)
(-585.8081418209852019290498 - 5033.314488899926921597203j)
>>> webere(3.25, 1e6j)
(-1.117960409887505906848456e+434291 - 4.630743639715893346570743e+434290j)
>>> webere(3.25, 1e6)
-0.00002812518265894315604914453
\end{lstlisting}


\newpage
\section{Lommel functions}


\subsection{First Lommel function s}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{lommels1? mpNum? the First Lommel functions s}
	{u? mpNum? A real or complex number.}
	{v? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


\vpara
The Lommel function $s_{\mu,\nu}$ or $s_{\mu,\nu}^{(1)}$ is defined as

\begin{equation}
s_{\mu,\nu}= \frac{z^{\mu+1}}{(\mu-\nu+1)(\mu+\nu+1)}{}_1F_2\left(1; \frac{\mu-\nu+3}{2}, \frac{\mu+\nu+3}{2};-\frac{z^2}{4}\right)
\end{equation}
which solves the inhomogeneous Bessel equation
\begin{equation}
z^2 f''(z)+z f'(z) + \left(z^2-\nu^2\right)f(z) = z^{\mu+1}.
\end{equation}

A second solution is given by lommels2().

An integral representation:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> u,v,z = 0.25, 0.125, mpf(0.75)
>>> lommels1(u,v,z)
0.4276243877565150372999126
>>> (bessely(v,z)*quad(lambda t: t**u*besselj(v,t), [0,z]) - \
... besselj(v,z)*quad(lambda t: t**u*bessely(v,t), [0,z]))*(pi/2
0.4276243877565150372999126
\end{lstlisting}




\subsection{Second Lommel function S}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{lommels2? mpNum? the Second Lommel functions S}
	{u? mpNum? A real or complex number.}
	{v? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


\vpara
The second Lommel function or $S_{\mu,\nu}$ or $s_{\mu,\nu}^{(2)}$ is defined as
\begin{IEEEeqnarray}{rCl} 
S_{\mu,\nu}(z) & = & s_{\mu,\nu}(z) + 2^{\mu-1} \Gamma\left(\tfrac{1}{2}(\mu-\nu+1)\right) \Gamma\left(\tfrac{1}{2}(\mu+\nu+1)\right)  \\ \nonumber
& \times & \left[\sin\left(\tfrac{1}{2}(\mu-\nu)\pi\right)J_{\nu}(z)- \cos\left(\tfrac{1}{2}(\mu-\nu)\pi\right)Y_{\nu}(z)- \right]
\end{IEEEeqnarray}


which solves the same differential equation as lommels1().

Verifying the differential equation:

\lstset{language={Python}}
\begin{lstlisting}
>>> f = lambda z: lommels2(u,v,z)
>>> z**2*diff(f,z,2) + z*diff(f,z) + (z**2-v**2)*f(z)
0.6495190528383289850727924
>>> z**(u+1)
0.6495190528383289850727924
\end{lstlisting}


\newpage
\section{Airy and Scorer functions}

%
%\subsection{Airy Functions}
%\label{AiryFunctions4MpMath}
%
%In this section let $z = (2/3)|x|^{3/2}$.  For large negative $x$ the Airy functions and the Scorer function $Gi(x)$ have asymptotic expansions oscillating with $\cos(z + \pi/4)$ or $\sin(z + \pi/4)$, see Abramowitz and Stegun [1, 10.4.60, 10.4.64, 10.4.87]; therefore the phase information becomes totally unreliable for $x < -(2/\epsilon (x))^{2/3}$, and
%the relative error increases strongly for $x$ less than the square root.
%
%\subsection{\texorpdfstring{$\text{Airy Function Ai}(x)$}{Aix}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AiryAiMpMath? mpNum? the Airy function $\text{Ai}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{\texorpdfstring{$\text{Airy Function Ai}'(x)$}{AiPx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AiryAiDerivativeMpMath? mpNum? the Airy function $\text{Ai}'(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This routine returns the Airy function $\text{Ai}'(x)$, defined as
%\begin{equation}
%	\text{Ai}'(x) = \frac{x}{\pi\sqrt{3}}  K_{2/3}(z), \quad (x>0)
%\end{equation}
%\begin{equation}
%	\text{Ai}'(x) = \frac{1}{-(3^{2/3)}\Gamma(1/3)} , \quad (x=0)
%\end{equation}
%\begin{equation}
%	\text{Ai}'(x) = -\frac{x}{2} \left(J_{2/3}(z) + \frac{1}{\sqrt{3}} Y_{2/3}(z) \right), \quad (x<0)
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Airy Function Bi}(x)$}{Bix}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AiryBiMpMath? mpNum? the Airy function $\text{Bi}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\subsection{\texorpdfstring{$\text{Airy Function Bi}'(x)$}{BiPx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AiryBiDerivativeMpMath? mpNum? the Airy function $\text{Bi}'(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This routine returns the Airy function $\text{Bi}'(x)$, defined as
%\begin{equation}
%	\text{Bi}'(x) = x \left(\frac{2}{\sqrt{3}}I_{2/3}(z) + \frac{1}{\pi} K_{2/3}(z) \right), \quad (x>0)
%\end{equation}
%\begin{equation}
%	\text{Bi}(x) = \frac{3^{1/6}}{\Gamma(1/3)} , \quad (x=0)
%\end{equation}
%\begin{equation}
%	\text{Bi}(x) = -\tfrac{x}{2} \left(\frac{1}{\sqrt{3}} J_{2/3}(z) - Y_{2/3}(z) \right), \quad (x<0)
%\end{equation}
%


\subsection{Airy function Ai}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{airyai? mpNum? the Airy function Ai}
	{z? mpNum? A real or complex number.}
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
The Airy function $\text{Ai}(z)$ is the solution of the Airy differential equation 

$f''(z)-z f(z)=0$ with initial conditions

\begin{equation}
\text{Ai}(0)=\frac{1}{3^{2/3}\Gamma\left(\frac{2}{3}\right)}; \quad \text{Ai'}(0)=\frac{1}{3^{1/3}\Gamma\left(\frac{1}{3}\right)}
\end{equation}

Other common ways of defining the Ai-function include integrals such as

\begin{equation}
\text{Ai}(x)= \frac{1}{\pi} \int_0^{\infty} \cos\left(\tfrac{1}{3}t^3 + xt \right) dt, \quad x \in \mathbb{R}
\end{equation}

\begin{equation}
\text{Ai}(z)= \frac{\sqrt{3}}{2\pi} \int_0^{\infty} \exp\left(-\frac{t^3}{3}-\frac{z^3}{3t^3} \right) dt.
\end{equation}


\vspace{0.3cm}
The Airy function $\text{Ai}(x)$ can also be defined as
\begin{equation}
\text{Ai}(x) = \frac{1}{\pi} \sqrt{\frac{x}{3}} K_{1/3}(z), \quad (x>0)
\end{equation}
\begin{equation}
\text{Ai}(x) = \frac{1}{3^{2/3}\Gamma(2/3)} , \quad (x=0)
\end{equation}
\begin{equation}
\text{Ai}(x) = \tfrac{1}{2} \sqrt{-x} \left(J_{1/3}(z) - \frac{1}{\sqrt{3}} Y_{1/3}(z) \right), \quad (x<0)
\end{equation}



The Ai-function is an entire function with a turning point, behaving roughly like a slowly decaying sine wave for $z<0$ and like a rapidly decreasing exponential for $z>0$. A second solution of the Airy differential equation is given by $\text{Bi}(z)$(see airybi()).

\vpara
Optionally, with derivative=alpha, airyai() can compute the $\alpha$-th order fractional derivative with respect to $z$. 

For $\alpha=n=1,2,3,\ldots$ this gives the derivative $\text{Ai}^{n}(z)$, and for $\alpha=-n=-1,-2,-3,\ldots$ this gives the $n$-fold iterated integral 

\begin{equation}
f_0(z)=\text{Ai}(z); \quad f_n(z) = \int_0^z f_{n-1}(t) dt.
\end{equation}

The Ai-function has infinitely many zeros, all located along the negative half of the real
axis. They can be computed with airyaizero().

Limits and values include:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> airyai(0); 1/(power(3,'2/3')*gamma('2/3'))
0.3550280538878172392600632
0.3550280538878172392600632
>>> airyai(1)
0.1352924163128814155241474
>>> airyai(-1)
0.5355608832923521187995166
>>> airyai(inf); airyai(-inf)
0.0
0.0
\end{lstlisting}

Evaluation is supported for large magnitudes of the argument:

\lstset{language={Python}}
\begin{lstlisting}
>>> airyai(-100)
0.1767533932395528780908311
>>> airyai(100)
2.634482152088184489550553e-291
>>> airyai(50+50j)
(-5.31790195707456404099817e-68 - 1.163588003770709748720107e-67j)
>>> airyai(-50+50j)
(1.041242537363167632587245e+158 + 3.347525544923600321838281e+157j)
>>> airyai(10**10)
1.162235978298741779953693e-289529654602171
>>> airyai(-10**10)
0.0001736206448152818510510181
>>> w = airyai(10**10*(1+j))
>>> w.real
5.711508683721355528322567e-186339621747698
>>> w.imag
1.867245506962312577848166e-186339621747697
\end{lstlisting}



\subsection{Airy function Bi}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{airybi? mpNum? the Airy function Bi}
	{z? mpNum? A real or complex number.}
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
The Airy function \text{Bi}(z) is the solution of the Airy differential equation 

$f''(z)-z f(z)=0$ with initial conditions

\begin{equation}
\text{Bi}(0)=\frac{1}{3^{1/6}\Gamma\left(\frac{2}{3}\right)}; \quad \text{Bi'}(0)=\frac{1}{3^{1/6}\Gamma\left(\frac{1}{3}\right)}
\end{equation}


\vspace{0.3cm}
The Airy function $\text{Bi}(x)$, can also be defined as
\begin{equation}
\text{Bi}(x) = \sqrt{x} \left(\frac{2}{\sqrt{3}}I_{1/3}(z) + \frac{1}{\pi} K_{1/3}(z) \right), \quad (x>0)
\end{equation}
\begin{equation}
\text{Bi}(x) = \frac{1}{3^{1/6}\Gamma(2/3)} , \quad (x=0)
\end{equation}
\begin{equation}
\text{Bi}(x) = -\tfrac{1}{2} \sqrt{-x} \left(\frac{1}{\sqrt{3}} J_{1/3}(z) + Y_{1/3}(z) \right), \quad (x<0)
\end{equation}




Like the Ai-function (see airyai()), the Bi-function is oscillatory for $z<0$, but it grows rather than decreases for $z>0$.

Optionally, as for airyai(), derivatives, integrals and fractional derivatives can be computed with the derivative parameter.

The Bi-function has infinitely many zeros along the negative half-axis, as well as complex zeros, which can all be computed with airybizero().


Limits and values include:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> airybi(0); 1/(power(3,'1/6')*gamma('2/3'))
0.6149266274460007351509224
0.6149266274460007351509224
>>> airybi(1)
1.207423594952871259436379
>>> airybi(-1)
0.10399738949694461188869
>>> airybi(inf); airybi(-inf)
+inf
0.0
\end{lstlisting}

Evaluation is supported for large magnitudes of the argument:

\lstset{language={Python}}
\begin{lstlisting}
>>> airybi(-100)
0.02427388768016013160566747
>>> airybi(100)
6.041223996670201399005265e+288
>>> airybi(50+50j)
(-5.322076267321435669290334e+63 + 1.478450291165243789749427e+65j)
>>> airybi(-50+50j)
(-3.347525544923600321838281e+157 + 1.041242537363167632587245e+158j)
>>> airybi(10**10)
1.369385787943539818688433e+289529654602165
>>> airybi(-10**10)
0.001775656141692932747610973
>>> w = airybi(10**10*(1+j))
>>> w.real
-6.559955931096196875845858e+186339621747689
>>> w.imag
-6.822462726981357180929024e+186339621747690
\end{lstlisting}




\subsection{Zeros of the Airy function Ai}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{airyaizero? mpNum? the $k$-th zero of the Airy Ai-function}
	{k? mpNum? An integer.}
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
Gives the $k$-th zero of the Airy Ai-function, i.e. the $k$-th number ordered by magnitude for which $\text{Ai}(a_k)=0$.

Optionally, with derivative=1, the corresponding zero $a'_k$ of the derivative function, i.e. $\text{Ai'}(a'_k)=0$, is computed.

Examples

Some values of :

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> airyaizero(1)
-2.338107410459767038489197
>>> airyaizero(2)
-4.087949444130970616636989
>>> airyaizero(3)
-5.520559828095551059129856
>>> airyaizero(1000)
-281.0315196125215528353364
\end{lstlisting}



\subsection{Zeros of the Airy function Bi}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{airybizero? mpNum? the $k$-th zero of the Airy Bi-function}
	{k? mpNum? An integer.}
	{Keywords? String? derivative=0, complex=0.}	
\end{mpFunctionsExtract}


\vpara
With complex=False, gives the $k$-th real zero of the Airy Bi-function, i.e. the $k$-th number ordered by magnitude for which $\text{Bi}(b_k)=0$.

With complex=True, gives the $k$-th complex zero in the upper half plane $\beta_k$. Also the conjugate $\overline{\beta_k}$ is a zero.

Optionally, with derivative=1, the corresponding zero $b'_k$ or $\beta'_k$ of the derivative function, i.e. $\text{Bi'}(b'_k)=0$ or $\text{Bi,}(\beta'_k)=0$, is computed.

Examples

Some values of :

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> airybizero(1)
-1.17371322270912792491998
>>> airybizero(2)
-3.271093302836352715680228
>>> airybizero(3)
-4.830737841662015932667709
>>> airybizero(1000)
-280.9378112034152401578834
\end{lstlisting}



\subsection{Scorer function Gi}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{scorergi? mpNum? the Scorer function Gi}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


\vpara
Evaluates the Scorer function

\begin{equation}
\text{Gi}(z) = \text{Ai}(z) \int_0^z \text{Bi}(t)dt + \text{Bi}(z) \int_z^{\infty} \text{Ai}(t)dt 
\end{equation}

which gives a particular solution to the inhomogeneous Airy differential equation $f''(z)-z f(z) = 1-\pi$. Another particular solution is given by the Scorer Hi-function
(scorerhi()). The two functions are related as $\text{Gi}(z) + \text{Hi}(z) = \text{Bi}(z)$.

Examples

Some values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> scorergi(0); 1/(power(3,'7/6')*gamma('2/3'))
0.2049755424820002450503075
0.2049755424820002450503075
>>> diff(scorergi, 0); 1/(power(3,'5/6')*gamma('1/3'))
0.1494294524512754526382746
0.1494294524512754526382746
>>> scorergi(+inf); scorergi(-inf)
0.0
0.0
>>> scorergi(1)
0.2352184398104379375986902
>>> scorergi(-1)
-0.1166722172960152826494198
\end{lstlisting}




\subsection{Scorer function Hi}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{scorerhi? mpNum? the Scorer function Gi}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
Evaluates the second Scorer function

\begin{equation}
\text{Hi}(z) = \text{Bi}(z) \int_{-\infty}^z \text{Ai}(t)dt - \text{Ai}(z) \int^z_{-\infty} \text{Bi}(t)dt 
\end{equation}

which gives a particular solution to the inhomogeneous Airy differential equation $f''(z)-z f(z) = 1-\pi$. See also scorergi().

Examples

Some values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> scorerhi(0); 2/(power(3,'7/6')*gamma('2/3'))
0.4099510849640004901006149
0.4099510849640004901006149
>>> diff(scorerhi,0); 2/(power(3,'5/6')*gamma('1/3'))
0.2988589049025509052765491
0.2988589049025509052765491
>>> scorerhi(+inf); scorerhi(-inf)
+inf
0.0
>>> scorerhi(1)
0.9722051551424333218376886
>>> scorerhi(-1)
0.2206696067929598945381098
\end{lstlisting}


\newpage
\section{Coulomb wave functions}


\subsection{Regular Coulomb wave function}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{coulombf? mpNum? the regular Coulomb wave function}
	{l? mpNum? A real or complex number.}
	{eta? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


\vpara
Calculates the regular Coulomb wave function

\begin{equation}
F_l(\eta, z) = C_l(\eta) z^{l+1} e^{iz} {}_1F_1(l+1-i\eta, 2l+2,2iz))
\end{equation}

where the normalization constant $C_l(\eta)$ is as calculated by coulombc(). This function solves the differential equation

\begin{equation}
f''(z)+\left(1-\frac{2\eta}{z}-\frac{l(l+1)}{z^2} \right) f(z)=0.
\end{equation}


A second linearly independent solution is given by the irregular Coulomb wave function $G_l(\eta, z) $(see coulombg()) and thus the general solution is

\begin{equation}
f(z) = C_1 F_l(\eta, z) + C_2 G_l(\eta, z) 
\end{equation}


for arbitrary constants $C_1, C_2$. Physically, the Coulomb wave functions give the radial solution to the Schrodinger equation for a point particle in a $1/z$ potential; $z$ is then the radius and $l, \eta$ are quantum numbers.

\vpara
The Coulomb wave functions with real parameters are defined in Abramowitz \& Stegun, section 14. However, all parameters are permitted to be complex in this implementation (see references).


Evaluation is supported for arbitrary magnitudes of :

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> coulombf(2, 1.5, 3.5)
0.4080998961088761187426445
>>> coulombf(-2, 1.5, 3.5)
0.7103040849492536747533465
>>> coulombf(2, 1.5, '1e-10')
4.143324917492256448770769e-33
>>> coulombf(2, 1.5, 1000)
0.4482623140325567050716179
>>> coulombf(2, 1.5, 10**10)
-0.066804196437694360046619
\end{lstlisting}



Some test case with complex parameters, taken from Michel [2]:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15
>>> coulombf(1+0.1j, 50+50j, 100.156)
(-1.02107292320897e+15 - 2.83675545731519e+15j)
>>> coulombg(1+0.1j, 50+50j, 100.156)
(2.83675545731519e+15 - 1.02107292320897e+15j)
>>> coulombf(1e-5j, 10+1e-5j, 0.1+1e-6j)
(4.30566371247811e-14 - 9.03347835361657e-19j)
>>> coulombg(1e-5j, 10+1e-5j, 0.1+1e-6j)
(778709182061.134 + 18418936.2660553j)
\end{lstlisting}




\subsection{Irregular Coulomb wave function}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{coulombg? mpNum? the irregular Coulomb wave function}
	{l? mpNum? A real or complex number.}
	{eta? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


\vpara
Calculates the irregular Coulomb wave function

\begin{equation}
G_l(\eta, z) = \frac{F_l(\eta,z) \cos(\chi) - F_{-l-1}(\eta,z)}{\sin(\chi)}
\end{equation}
where
\begin{equation}
\chi=\sigma_l-\sigma_{l-1}-(l+1/2)\pi
\end{equation}
and
\begin{equation}
\sigma_l(\eta)=(\ln\Gamma(1+l+i\eta) - \ln\Gamma(1+l-i\eta))/(2i)
\end{equation}
See coulombf() for additional information.

Evaluation is supported for arbitrary magnitudes of :

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> coulombg(-2, 1.5, 3.5)
1.380011900612186346255524
>>> coulombg(2, 1.5, 3.5)
1.919153700722748795245926
>>> coulombg(-2, 1.5, '1e-10')
201126715824.7329115106793
>>> coulombg(-2, 1.5, 1000)
0.1802071520691149410425512
>>> coulombg(-2, 1.5, 10**10)
0.652103020061678070929794
\end{lstlisting}



\subsection{Normalizing Gamow constant}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{coulombc? mpNum? the normalizing Gamow constant for Coulomb wave functions}
	{l? mpNum? A real or complex number.}
	{eta? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


The normalizing Gamow constant for Coulomb wave functions is defined as

\begin{equation}
C_l(\eta)=2^l \exp(-\pi\eta/2 + [\ln\Gamma(1+l+i\eta) + \ln\Gamma(1+l-i\eta)]/2 - \ln\Gamma(2l+2))
\end{equation}

where the log gamma function with continuous imaginary part away from the negative half axis (see loggamma()) is implied.

\vpara
This function is used internally for the calculation of Coulomb wave functions, and automatically cached to make multiple evaluations with fixed $l,\eta$ fast.





\newpage
\section{Parabolic cylinder functions}

\subsection{Parabolic cylinder function D}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{pcfd? mpNum? the parabolic cylinder function D}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


\vpara
Gives the parabolic cylinder function in Whittaker's notation $D_n(z)=U(-n-1/2, z)$ (see pcfu()). It solves the differential equation 

\begin{equation}
y'' + \left(n+\frac{1}{2} - \frac{1}{4} z^2\right) y = 0.
\end{equation}

and can be represented in terms of Hermite polynomials (see hermite()) as

\begin{equation}
D_n(z) = 2^{-n/2} e^{-z^2/4} H_n\left(\frac{z}{\sqrt{2}}  \right)
\end{equation}

Examples


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> pcfd(0,0); pcfd(1,0); pcfd(2,0); pcfd(3,0)
1.0
0.0
-1.0
0.0
>>> pcfd(4,0); pcfd(-3,0)
3.0
0.6266570686577501256039413
>>> pcfd('1/2', 2+3j)
(-5.363331161232920734849056 - 3.858877821790010714163487j)
>>> pcfd(2, -10)
1.374906442631438038871515e-9
\end{lstlisting}




\subsection{Parabolic cylinder function U}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{pcfu? mpNum? the parabolic cylinder function U}
	{a? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


\vpara
Gives the parabolic cylinder function $U(a, z)$, which may be defined for $\Re(z)>0$ in terms of the confluent U-function (see hyperu()) by

\begin{equation}
U(a, z) = 2^{-\frac{1}{4}-\frac{a}{2}} e^{-\frac{1}{4}z^2} U\left(\frac{a}{2} + \frac{1}{4}, \frac{1}{2}, \frac{1}{2}z^2 \right)
\end{equation}

or, for arbitrary $z$,

\begin{equation}
e^{-\frac{1}{4}z^2} U(a, z) = U(a, 0) {}_1F_1\left(-\frac{a}{2} + \frac{1}{4}, \frac{1}{2}, -\frac{1}{2}z^2 \right) + U'(a, 0 ){}_1F_1\left(-\frac{a}{2} + \frac{3}{4}, \frac{3}{2}, -\frac{1}{2}z^2 \right)
\end{equation}


Examples

Connection to other functions:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> z = mpf(3)
>>> pcfu(0.5,z)
0.03210358129311151450551963
>>> sqrt(pi/2)*exp(z**2/4)*erfc(z/sqrt(2))
0.03210358129311151450551963
>>> pcfu(0.5,-z)
23.75012332835297233711255
>>> sqrt(pi/2)*exp(z**2/4)*erfc(-z/sqrt(2))
23.75012332835297233711255
>>> pcfu(0.5,-z)
23.75012332835297233711255
>>> sqrt(pi/2)*exp(z**2/4)*erfc(-z/sqrt(2))
23.75012332835297233711255
\end{lstlisting}



\subsection{Parabolic cylinder function V}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{pcfv? mpNum? the parabolic cylinder function V}
	{a? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
Gives the parabolic cylinder function $V(a, z)$, which can be represented in terms of pcfu() as

\begin{equation}
V(a, z) = \frac{\Gamma(a+\frac{1}{2}) (U(a, -z) - \sin(\pi a)U(a, z))}{\pi}
\end{equation}

Examples

Wronskian relation between $U$ and $V$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> a, z = 2, 3
>>> pcfu(a,z)*diff(pcfv,(a,z),(0,1))-diff(pcfu,(a,z),(0,1))*pcfv(a,z)
0.7978845608028653558798921
>>> sqrt(2/pi)
0.7978845608028653558798921
>>> a, z = 2.5, 3
>>> pcfu(a,z)*diff(pcfv,(a,z),(0,1))-diff(pcfu,(a,z),(0,1))*pcfv(a,z)
0.7978845608028653558798921
>>> a, z = 0.25, -1
>>> pcfu(a,z)*diff(pcfv,(a,z),(0,1))-diff(pcfu,(a,z),(0,1))*pcfv(a,z)
0.7978845608028653558798921
>>> a, z = 2+1j, 2+3j
>>> chop(pcfu(a,z)*diff(pcfv,(a,z),(0,1))-diff(pcfu,(a,z),(0,1))*pcfv(a,z))
0.7978845608028653558798921
\end{lstlisting}



\subsection{Parabolic cylinder function W}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{pcfw? mpNum? Computes the parabolic cylinder function W}
	{a? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


Gives the parabolic cylinder function $W(a, z)$ defined in (DLMF 12.14).

Examples

Value at the origin:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> a = mpf(0.25)
>>> pcfw(a,0)
0.9722833245718180765617104
>>> power(2,-0.75)*sqrt(abs(gamma(0.25+0.5j*a)/gamma(0.75+0.5j*a)))
0.9722833245718180765617104
>>> diff(pcfw,(a,0),(0,1))
-0.5142533944210078966003624
>>> -power(2,-0.25)*sqrt(abs(gamma(0.75+0.5j*a)/gamma(0.25+0.5j*a)))
-0.5142533944210078966003624
\end{lstlisting}





\newpage
\chapter{Orthogonal polynomials}
An orthogonal polynomial sequence is a sequence of polynomials $P_0(x), P_1(x),\ldots$ of degree $0, 1, \ldots$, which are mutually orthogonal in the sense that

\begin{equation}
  \int_S P_n(x) P_m(x) w(x) = \begin{cases}
    c_n \neq 0 & \text{if } m=n\\
    0 & \text{if } m \neq n
  \end{cases}
\end{equation}

where $S$ is some domain (e.g. an interval $[a, b] \in \mathbb{R}$) and $w(x)$ is a fixed weight function. A
sequence of orthogonal polynomials is determined completely by $w$, $S$, and a normalization convention (e.g. $c_n=1$). Applications of orthogonal polynomials include function approximation and solution of differential equations.

\vpara
Orthogonal polynomials are sometimes defined using the differential equations they satisfy (as functions of $x$) or the recurrence relations they satisfy with respect to the order $n$. Other ways of defining orthogonal polynomials include differentiation formulas and generating
functions. The standard orthogonal polynomials can also be represented as hypergeometric series (see Hypergeometric functions), more specifically using the Gauss hypergeometric function ${}_2F_1$ in most cases. The following functions are generally implemented using hypergeometric functions since this is computationally efficient and easily generalizes.

For more information, see the Wikipedia article on orthogonal polynomials.

%
%\newpage
%\section{Orthogonal Polynomials and Legendre Functions}
%
%\subsection{Chebychev Polynomials of the first kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{ChebychevTMpMath? mpNum? $T_n (x)$, the Chebyshev polynomial of the ﬁrst kind of degree $n$.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%These functions return $T_n (x)$, the Chebyshev polynomial of the ﬁrst kind of degree $n$. 
%
%
%
%
%
%
%\subsection{Chebyshev Polynomials of the second kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{ChebychevUMpMath? mpNum? $U_n (x)$, the Chebyshev polynomial of the second kind of degree $n$.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%These functions return $U_n (x)$, the Chebyshev polynomial of the second kind of degree $n$. 
%
%
%
%
%\subsection{Gegenbauer (Ultraspherical) Polynomials}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{GegenbauerCMpMath? mpNum?  $C^{(a)}_n (x)$, the Gegenbauer (ultraspherical) polynomial of degree $n$ with parameter $a$.}
%	{n? mpNum? An Integer.}
%	{a? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%
%
%
%
%\subsection{Hermite Polynomials}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{HermiteHMpMath? mpNum? $H_n(x)$, the Hermite polynomial of degree $n \geq 0$.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%These functions return $H_n(x)$, the Hermite polynomial of degree $n \geq 0$. 
%
%
%\subsection{Jacobi Polynomials}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionFour
%	{JacobiPMpMath? mpNum? $P^{(a,b)}_n (x)$, the Jacobi polynomial of degree $n \geq 0$ with parameters $(a, b)$.}
%	{n? mpNum? An Integer.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{Generalized Laguerre Polynomials}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{GeneralizedLaguerreMpMath? mpNum?  $L^{(a)}_n (x)$, the generalized Laguerre polynomials of degree $n \geq 0$ with parameter $a$.}
%	{n? mpNum? An Integer.}
%	{a? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%%\newpage
%\subsection{Legendre Polynomials/Functions}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{LegendrePMpMath? mpNum? $P_l(x)$, the Legendre functions of the first kind.}
%	{l? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%These functions return $P_l(x)$, the Legendre functions of the first kind, also called Legendre polynomials if $l \geq 0$ and $|x| \leq 1$. The Legendre polynomials are orthogonal on the interval $(−1, 1)$ with $w(x) = 1$. If $l \geq 0$ the function uses the recurrence relation for varying degree from [1, 8.5.3]:
%\begin{IEEEeqnarray}{rCl} 
%	P_0 (x) & = & 1 \\
%	P_1 (x) & = & x \nonumber \\ 
%	(l+1)P_{l+1} (x)& = & (2l+1) P_{l}(x) - l P_{l-1}(x).  \nonumber
%\end{IEEEeqnarray}
%and for negative $l$ the result is $P_l(x) = P_{-l-1}(x)$.
%
%
%
%
%
%%\newpage
%\subsection{Associated Legendre Polynomials/Functions}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{AssociatedLegendrePlmMpMath? mpNum? $L^m_n (x)$, the associated Legendre polynomials of degree $l \geq 0$ and order $m \geq 0$.}
%	{l? mpNum? An Integer.}
%	{m? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns $L^m_n (x)$, the associated Legendre polynomials of degree $l \geq 0$ and order $m \geq 0$, defined for $m>0, |x|<1$ as
%\begin{equation}
%P^m_l (x) = (-1)^m (1-x^2)^{m/2} \frac{d^m}{dx^m} P_{l} (x).
%\end{equation}
%
%
%
%
%%\newpage
%\subsection{Legendre Functions of the Second Kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{LegendreQMpMath? mpNum? $Q_l(x)$, the Legendre functions of the second kind of degree $l \geq 0$ and $|x| \neq 1$.}
%	{l? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%These functions return $Q_l(x)$, the Legendre functions of the second kind of degree $l \geq 0$ and $|x| \neq 1$, defined as
%\begin{IEEEeqnarray}{rCl} 
%	Q_0 (x) & = & \frac{1}{2} \ln \frac{1+x}{1-x}  \\
%	Q_1 (x) & = & \frac{x}{2} \ln \frac{1+x}{1-x} -1\nonumber \\ 
%	(k+1)Q_{k+1} (x)& = & (2k+1) x Q_{k}(x) - k Q_{k-1}(x).  \nonumber
%\end{IEEEeqnarray}
%
%
%
%
%
%\subsection{Associated Legendre Functions of the Second Kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{AssociatedLegendreQlmMpMath? mpNum? $Q^m_l (x)$, the associated Legendre functions of the second kind with $l \geq 0$, $l+m \geq 0$ and $x \neq 1$.}
%	{l? mpNum? An Integer.}
%	{m? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns $Q^m_l (x)$, the associated Legendre functions of the second kind with $l \geq 0$, $l+m \geq 0$ and $x \neq 1$, defined as
%\begin{equation}
%Q^m_l (x) = (-1)^m (1-x^2)^{m/2} \frac{d^m}{dx^m} Q_{l} (x), \quad |x|<1,
%\end{equation}
%\begin{equation}
%Q^m_l (x) = (x^2-1)^{m/2} \frac{d^m}{dx^m} Q_{l} (x), \quad |x|>1.
%\end{equation}
%
%
%
%
%
%\subsection{Spherical Harmonic Functions}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionFour
%	{SphericalHarmonicMpMath? mpNum? the real and imaginary parts of the spherical harmonic function $Y_{lm}(\theta, \phi)$.}
%	{l? mpNumList[2]? An Integer.}
%	{m? mpNum? An Integer.}
%	{$\theta$? mpNum? A real number.}
%	{$\phi$? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The procedures return the real and imaginary parts of the spherical harmonic function $Y_{lm}(\theta, \phi)$. These functions are closely related to the associated Legendre polynomials:
%\begin{equation}
%Y_{lm}(\theta, \phi) = \sqrt{\frac{(2l+1) (l-m)!}{4 \pi (l+m)!}} P^m_l (\cos(\theta)) e^{i m \phi}
%\end{equation}
%
%



\section{Legendre functions}


\subsection{Legendre polynomial}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{legendre? mpNum? the Legendre polynomial $P_n(x)$}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Legendre polynomials are given by the formula

\begin{equation}
P_n(x)= \frac{1}{2^n n!} \frac{d^n}{dx^n}(x^2-1)^n
\end{equation}

Alternatively, they can be computed recursively using

\begin{equation}
P_0(x)=1; \quad P_1(x)=x; \quad (n+1)P_{n+1}(x)=(2n+1)xPn(x)-nP_{n-1}(x)
\end{equation}

A third definition is in terms of the hypergeometric function ${}_2F_1$, whereby they can be generalized to arbitrary $n$:

\begin{equation}
P_n(x)={}_2F_1\left(-n, n+1, 1, \frac{1-x}{2} \right)
\end{equation}

The Legendre polynomials assume fixed values at the points $x=-1$ and $x=1$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> nprint([legendre(n, 1) for n in range(6)])
[1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
>>> nprint([legendre(n, -1) for n in range(6)])
[1.0, -1.0, 1.0, -1.0, 1.0, -1.0]
\end{lstlisting}




\subsection{Associated Legendre function of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{legenp? mpNum? the (associated) Legendre function of the first kind of degree $n$ and order $m$, $P_n^m(z)$.}
	{n? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}		
	{Keywords? String? type=2.}	
\end{mpFunctionsExtract}

\vpara
Calculates the (associated) Legendre function of the first kind of degree $n$ and order $m$, $P_n^m(z)$. Taking $m=0$ gives the ordinary Legendre function of the first kind, $P_n(z)$. The parameters may be complex numbers.

\vpara
In terms of the Gauss hypergeometric function, the (associated) Legendre function is defined as

\begin{equation}
P_n^m = \frac{1}{\Gamma(1-m)}\frac{(1+z)^{m/2}}{(1-z)^{m/2}} {}_2F_1\left(-n, n+1, 1-m, \frac{1-z}{2} \right).
\end{equation}

With type=3 instead of type=2, the alternative definition

\begin{equation}
\widehat{P}_n^m = \frac{1}{\Gamma(1-m)}\frac{(1+z)^{m/2}}{(z-1)^{m/2}} {}_2F_1\left(-n, n+1, 1-m, \frac{1-z}{2} \right).
\end{equation}


is used. These functions correspond respectively to LegendreP[n,m,2,z] and
LegendreP[n,m,3,z] in Mathematica.

\vpara
The general solution of the (associated) Legendre differential equation

\begin{equation}
(1-z^2)f''(z) - 2zf'(z) + \left(n(n+1)-\frac{m^2}{1-z^2} \right)f(z)=0
\end{equation}
is given by $C_1 P_n^m(z) + C_2 Q_n^m(z)$ for arbitrary constants $C_1$, $C_2$, where $Q_n^m(z)$ is a Legendre function of the second kind as implemented by legenq().

\vpara
Examples

Evaluation for arbitrary parameters and arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> legenp(2, 0, 10); legendre(2, 10)
149.5
149.5
>>> legenp(-2, 0.5, 2.5)
(1.972260393822275434196053 - 1.972260393822275434196053j)
>>> legenp(2+3j, 1-j, -0.5+4j)
(-3.335677248386698208736542 - 5.663270217461022307645625j)
>>> chop(legenp(3, 2, -1.5, type=2))
28.125
>>> chop(legenp(3, 2, -1.5, type=3))
-28.125
\end{lstlisting}









\subsection{Associated Legendre function of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{legenq? mpNum? the (associated) Legendre function of the second kind of degree $n$ and order $m$, $Q_n^m(z)$.}
	{n? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}		
	{Keywords? String? type=2.}	
\end{mpFunctionsExtract}

\vpara
Calculates the (associated) Legendre function of the second kind of degree $n$ and order $m$, $Q_n^m(z)$. Taking $m=0$ gives the ordinary Legendre function of the second kind, $Q_n(z)$. The parameters may complex numbers.

\vpara
The Legendre functions of the second kind give a second set of solutions to the (associated) Legendre differential equation. (See legenp().) Unlike the Legendre functions of the first kind, they are not polynomials of $z$ for integer $n, m$ but rational or logarithmic functions with poles at $z=\pm1$.

\vpara
There are various ways to define Legendre functions of the second kind, giving rise to different complex structure. A version can be selected using the type keyword argument. The type=2 and type=3 functions are given respectively by

\begin{equation}
Q_n^m(z) = \frac{\pi}{2\sin(\pi m)} \left(\cos(\pi m)P_n^m(z) - \frac{\Gamma(1+m+n)}{\Gamma(1-m+n)}P_n^{-m}(z)  \right)
\end{equation}
\begin{equation}
\widehat{Q}_n^m(z) = \frac{\pi}{2\sin(\pi m)}e^{\pi i m} \left(\widehat{P}_n^m(z) - \frac{\Gamma(1+m+n)}{\Gamma(1-m+n)}\widehat{P}_n^{-m}(z)  \right)
\end{equation}

where $P$ and $\widehat{P}$ are the type=2 and type=3 Legendre functions of the first kind. The formulas above should be understood as limits when is an integer.

\vpara
These functions correspond to LegendreQ[n,m,2,z] (or LegendreQ[n,m,z]) and
LegendreQ[n,m,3,z] in Mathematica. The type=3 function is essentially the same as the function defined in Abramowitz \& Stegun (eq. 8.1.3) but with $(z+1)^{m/2} (z-1)^{m/2}$ instead of $(z^2-1)^{m/2}$, giving slightly different branches.

Examples

Evaluation for arbitrary parameters and arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> legenq(2, 0, 0.5)
-0.8186632680417568557122028
>>> legenq(-1.5, -2, 2.5)
(0.6655964618250228714288277 + 0.3937692045497259717762649j)
>>> legenq(2-j, 3+4j, -6+5j)
(-10001.95256487468541686564 - 6011.691337610097577791134j)
\end{lstlisting}




\subsection{Spherical harmonics}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{spherharm? mpNum? the spherical harmonic $Y_l^m(\theta,\phi)$}
	{l? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}
	{theta? mpNum? A real or complex number.}	
	{phi? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


\vpara
Evaluates the spherical harmonic $Y_l^m(\theta,\phi)$,

\begin{equation}
Y_l^m(\theta,\phi) = \sqrt{\frac{(2l+1)(l-m)!}{4\pi (l+m)!}} P_l^m(\cos(\theta))e^{i m \phi}
\end{equation}

where $P_l^m$ is an associated Legendre function (see legenp()).

Here $\theta \in [0,\pi]$ denotes the polar coordinate (ranging from the north pole to the south pole) and $\phi \in [0,2\pi]$ denotes the azimuthal coordinate on a sphere. Care should be used since many different conventions for spherical coordinate variables are used.

\vpara
Usually spherical harmonics are considered for $l \in \mathbb{N}, m \in \mathbb{Z}, |m| \leq l$. More generally, $l, m, \theta, \phi$ are permitted to be complex numbers.

Some low-order spherical harmonics with reference values:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> theta = pi/4
>>> phi = pi/3
>>> spherharm(0,0,theta,phi); 0.5*sqrt(1/pi)*expj(0)
(0.2820947917738781434740397 + 0.0j)
(0.2820947917738781434740397 + 0.0j)
>>> spherharm(1,-1,theta,phi); 0.5*sqrt(3/(2*pi))*expj(-phi)*sin(theta)
(0.1221506279757299803965962 - 0.2115710938304086076055298j)
(0.1221506279757299803965962 - 0.2115710938304086076055298j)
>>> spherharm(1,0,theta,phi); 0.5*sqrt(3/pi)*cos(theta)*expj(0)
(0.3454941494713354792652446 + 0.0j)
(0.3454941494713354792652446 + 0.0j)
>>> spherharm(1,1,theta,phi); -0.5*sqrt(3/(2*pi))*expj(phi)*sin(theta)
(-0.1221506279757299803965962 - 0.2115710938304086076055298j)
(-0.1221506279757299803965962 - 0.2115710938304086076055298j)
\end{lstlisting}




\newpage
\section{Chebyshev polynomials}


\subsection{Chebyshev polynomial of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{chebyt? mpNum? the Chebyshev polynomial of the first kind $T_n(x)$}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Chebyshev polynomial of the first kind $T_n(x)$ are defined by the identity

\begin{equation}
T_n(\cos(x)) = \cos(nx).
\end{equation}

The $T_n (x)$ are orthogonal on the interval $(-1, 1)$, with respect to the weight function $w(x) = (1 - x^2 )^{-1/2}$.

For $0 \leq n \leq 64$ the function evaluates $T_n (x)$ with the
standard recurrence formulas [1, 22.7.4]:
\begin{IEEEeqnarray}{rCl} 
	T_0 (x) & = & 1 \\
	T_1 (x) & = & x \nonumber \\ 
	T_{n+1} (x)& = & 2x T_{n}(x) - T_{n-1}(x).  \nonumber
\end{IEEEeqnarray}

If $n > 64$ the following trigonometric and hyperbolic identities [1, 22.3.15]:
\begin{IEEEeqnarray}{rCl} 
	T_n (x) & = & \cos(n \arccos(x)), \quad |x| < 1 \\
	T_n (x) & = & \cosh(n \text{ arccosh}(x)), \quad |x| > 1
\end{IEEEeqnarray}
are used, and the special cases $|x| = 1$ are handled separately. If $n < 0$ the function
result is $T_n (x) = T{-n} (x)$.

The Chebyshev polynomials of the first kind are a special case of the Jacobi polynomials, and by extension of the hypergeometric function ${}_2F_1$. They can thus also be evaluated for nonintegral $n$.

The Chebyshev polynomials of the first kind are orthogonal on the interval $[-1, 1]$ with respect to the weight function $w(x)=1/\sqrt{1-x^2}$:

\lstset{language={Python}}
\begin{lstlisting}
>>> f = lambda x: chebyt(m,x)*chebyt(n,x)/sqrt(1-x**2)
>>> m, n = 3, 4
>>> nprint(quad(f, [-1, 1]),1)
0.0
>>> m, n = 4, 4
>>> quad(f, [-1, 1])
1.57079632596448
\end{lstlisting}




\subsection{Chebyshev polynomial of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{chebyu? mpNum? the Chebyshev polynomial of the second kind $U_n(x)$}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


The Chebyshev polynomial of the second kind $U_n(x)$ are defined by the identity

\begin{equation}
U_n(\cos(x) = \frac{\sin((n+1)x)}{\sin(x(}
\end{equation}

The $U_n (x)$ are orthogonal on the interval $(-1, 1)$, with respect to the weight function $w(x) = (1 - x^2 )^{1/2}$.

For $0 \leq n \leq 64$ the function evaluates $U_n (x)$ with the
standard recurrence formulas [1, 22.7.4]:
\begin{IEEEeqnarray}{rCl} 
	U_0 (x) & = & 1 \\
	U_1 (x) & = & 2x \nonumber \\ 
	U_{n+1} (x)& = & 2x U_{n}(x) - U_{n-1}(x).  \nonumber
\end{IEEEeqnarray}

If $n > 64$ the following trigonometric and hyperbolic identities [1, 22.3.15]:
\begin{IEEEeqnarray}{rCl} 
	U_n (x) & = & \frac{\sin((n+1) \arccos(x))}{\sin( \arccos(x))} , \quad |x| < 1 \\
	U_n (x) & = & \frac{\sin((n+1) \text{ arccosh}(x))}{\sin( \text{ arccosh}(x))} , \quad |x| > 1 
\end{IEEEeqnarray}
are used, and the special cases $|x| = 1$ are handled separately. If $n < 0$ the function
result are  $U_{-1} (x) = 0$ and $U_n (x) = -U{-n-2} (x)$.


The Chebyshev polynomials of the second kind are a special case of the Jacobi polynomials, and by extension of the hypergeometric function ${}_2F_1$. They can thus also be evaluated for nonintegral $n$.

\vpara
The Chebyshev polynomials of the first kind are orthogonal on the interval $[-1, 1]$ with respect to the weight function $w(x) = \sqrt{1-x^2}$:

\lstset{language={Python}}
\begin{lstlisting}
>>> f = lambda x: chebyu(m,x)*chebyu(n,x)*sqrt(1-x**2)
>>> m, n = 3, 4
>>> quad(f, [-1, 1])
0.0
>>> m, n = 4, 4
>>> quad(f, [-1, 1])
1.5707963267949
\end{lstlisting}



\newpage
\section{Jacobi and Gegenbauer polynomials}


\subsection{Jacobi polynomial}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{jacobi? mpNum? the Jacobi polynomial $P_n^{(a,b)}$}
	{n? mpNum? A real or complex number.}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vspace{0.3cm}
These functions return $P^{(a,b)}_n (x)$, the Jacobi polynomial of degree $n \geq 0$ with parameters $(a, b)$. $a, b$ should be greater than $-1$, and $a + b$ must not be an integer less than $-1$.
Jacobi polynomials are orthogonal on the interval $(-1, 1)$, with respect to the weight
function $w(x) = (1 - x)^a (1 + x)^b$, if $a, b$ are greater than $-1$.
The cases $n \leq 1$ are computed with the explicit formulas
\begin{equation}
P^{(a,b)}_0= 1, \quad   2P^{(a,b)}_1= (a - b) + (a + b + 2)x,
\end{equation}
and for $n > 1$ there are the somewhat complicated recurrence relations from [30] (18.9.1) and (18.9.2):
\begin{IEEEeqnarray}{rCl} 
	P^{(a,b)}_{n+1} & = &  (A_n x + B_n)P^{(a,b)}_n - C_n P^{(a,b)}_{n+1} \\
	A_n & = & \frac{(2n + a + b + 1)(2n + a + b + 2)}{2(n + 1)(n + a + b + 1)}  \nonumber  \\
	B_n & = & \frac{(a^2 - b^2 )(2n + a + b + 1)}{2(n + 1)(n + a + b + 1)(2n + a + b)}  \nonumber \\ 
	C_n & = & \frac{(n + a)(n + b)(2n + a + b + 2)}{(n + 1)(n + a + b + 1)(2n + a + b)} .  \nonumber
\end{IEEEeqnarray}



jacobi(n, a, b, x) evaluates the Jacobi polynomial $P_n^{(a,b)}$. The Jacobi polynomials are a special case of the hypergeometric function ${}_2F_1$ given by:

\begin{equation}
P_n^{(a,b)} = \binom{n+a}{n}{}_2F_1\left(-n, 1+a+b+n, a+1, \frac{1-x}{2} \right).
\end{equation}

Note that this definition generalizes to nonintegral values of $n$. When $n$ is an integer, the hypergeometric series terminates after a finite number of terms, giving a polynomial in $x$.

Evaluation of Jacobi polynomials

A special evaluation is $P_n^{(a,b)} = \binom{n+a}{n}$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> jacobi(4, 0.5, 0.25, 1)
2.4609375
>>> binomial(4+0.5, 4)
2.4609375
\end{lstlisting}




%\newpage
\subsection{Zernike Radial Polynomials}

\begin{mpFunctionsExtract}
	\mpFunctionThreeNotImplemented
	{ZernikeRadialMpMath? mpNum? the Zernike radial polynomials $R^m_n(r)$.}
	{n? mpNum? An Integer.}
	{m? mpNum? An Integer.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the Zernike radial polynomials $R^m_n(r)$ with $r\geq 0$ and $n\geq m \geq 0$, $n-m$ even, and zero otherwise. The  $R^m_n(r)$ are special cases of the Jacobi Polynomials
\begin{equation}
R^m_n(r) = (-1)^{(n-m)/2} r^m P^{(m,0)}_{(n-m)/2} (1-2r^2).
\end{equation}





\subsection{Gegenbauer polynomial}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{gegenbauer? mpNum? the Gegenbauer polynomial $C_n^{(a)}(z)$}
	{n? mpNum? A real or complex number.}
	{a? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
Evaluates the Gegenbauer polynomial, or ultraspherical polynomial,

\begin{equation}
C_n^{(a)}(z) = \binom{n+2a-1}{n}{}_2F_1\left(-n, n+2a; a+\frac{1}{2}, \frac{1}{2} (1-z)\right).
\end{equation}

When $n$ is a nonnegative integer, this formula gives a polynomial in $z$ of degree $n$, but all parameters are permitted to be complex numbers. With $a=1/2$, the Gegenbauer polynomial reduces to a Legendre polynomial.

These functions return $C^{(a)}_n (x)$, the Gegenbauer (ultraspherical) polynomial of degree $n$ with parameter $a$. The degree $n$ must be non-negative; $a$ should be $> -1/2$. The Gegenbauer polynomials are orthogonal on the interval $(-1, 1)$, with respect to the weight function $w(x) = (1 - x^2)^{a-1/2}$ .
If $a \neq 0$ the function uses the standard recurrence formulas [1, 22.7.3]:
\begin{IEEEeqnarray}{rCl} 
	C^{(a)}_0 (x) & = & 1 \\
	C^{(a)}_1 (x) & = & 2ax \nonumber \\ 
	nC^{(a)}_n (x)& = & 2(n+a-1)x C^{(a)}_{n-1}(x) - (n+2a-2)  C^{(a)}_{n-2}(x).  \nonumber
\end{IEEEeqnarray}
For $a = 0$ the result can be expressed in Chebyshev polynomials:
\begin{equation}
C^{(0)}_0 (x) =  1, \quad  C^{(0)}_n (x) =  2/n T_n(x).
\end{equation}




Evaluation for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> gegenbauer(3, 0.5, -10)
-2485.0
>>> gegenbauer(1000, 10, 100)
3.012757178975667428359374e+2322
>>> gegenbauer(2+3j, -0.75, -1000j)
(-5038991.358609026523401901 + 9414549.285447104177860806j)
\end{lstlisting}


\newpage
\section{Hermite and Laguerre polynomials}

\subsection{Hermite polynomials}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{hermite? mpNum? the Hermite polynomial $H_n(z)$}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
Evaluates the Hermite polynomial $H_n(z)$, which may be defined using the recurrence

\begin{equation}
H_0(z)=1; \quad H_1(z) = 2z; \quad H_{n+1}=2zH_n(z)-2nH_{n-1}(z).
\end{equation}

The $H_n$ are orthogonal on the interval $(-\infty, \infty)$, with respect to the weight function $w(x) = e^{-x^2}$.
They are computed with the standard recurrence formulas [1, 22.7.13]:
\begin{IEEEeqnarray}{rCl} 
	H_0 (x) & = & 1 \\
	H_1 (x) & = & 2x \nonumber \\ 
	H_n (x)& = & 2x H_{n-1}(x) - 2(n-1)  H_{n-2}(x).  \nonumber
\end{IEEEeqnarray}



The Hermite polynomials are orthogonal on $(-\infty, \infty)$ with respect to the weight $e^{-z^2}$. More generally, allowing arbitrary complex values of $n$, the Hermite function $H_n(z)$ is defined as 

\begin{equation}
H_n(z)=(2z)^n {}_2F_0 \left(-\frac{n}{2}, \frac{1-n}{2}, -\frac{1}{z^2}  \right)
\end{equation}

for $\Re z>0$, or generally

\begin{equation}
H_n(z) = 2^n \sqrt{\pi} \left(\frac{1}{\Gamma(\frac{1-n}{2})} {}_1F_1 \left(-\frac{n}{2}, \frac{1}{2}, z^2\right)  -  \frac{2z}{\Gamma(-\frac{n}{2})} {}_1F_1 \left(-\frac{1-n}{2}, \frac{3}{2}, z^2\right)  \right)
\end{equation}


Evaluation for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hermite(0, 10)
1.0
>>> hermite(1, 10); hermite(2, 10)
20.0
398.0
>>> hermite(10000, 2)
4.950440066552087387515653e+19334
>>> hermite(3, -10**8)
-7999999999999998800000000.0
>>> hermite(-3, -10**8)
1.675159751729877682920301e+4342944819032534
>>> hermite(2+3j, -1+2j)
(-0.07652130602993513389421901 - 0.1084662449961914580276007j)
\end{lstlisting}




\subsection{Laguerre polynomials}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{laguerre? mpNum? the generalized Laguerre polynomial $L_n^{\alpha}(z)$}
	{n? mpNum? A real or complex number.}
	{a? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vspace{0.3cm}
These functions return $L^{(a)}_n (x)$, the generalized Laguerre polynomials of degree $n \geq 0$ with parameter $a; x \geq 0$ and $a > -1$ are the standard ranges. These polynomials are orthogonal on the interval $(0,\infty)$, with respect to the weight function $w(x) = e^{-x}x^a$.

If $x < 0$ and $a > -1$ the function tries to avoid inaccuracies
and computes the result with Kummer’s confluent hypergeometric function, see Abramowitz and Stegun[1, 22.5.34]
\begin{equation}
L^{(a)}_n (x) = \binom{n+a}{n} M(-n,a+1,x),
\end{equation}
otherwise the standard recurrence formulas are used:
\begin{IEEEeqnarray}{rCl} 
	L^{(a)}_0 (x) & = & 1 \\
	L^{(a)}_1 (x) & = & -x+1+a \nonumber \\ 
	nL^{(a)}_n (x)& = & (2n+a-1-x) L^{(a)}_{n-1}(x) - (n+a-1)  L^{(a)}_{n-2}(x).  \nonumber
\end{IEEEeqnarray}



Gives the generalized (associated) Laguerre polynomial, defined by

\begin{equation}
L_n^{\alpha}(z) = \frac{\Gamma(n+b+1)}{\Gamma(b+1)\Gamma(n+1)} {}_1F_1(-n,a+1,z).
\end{equation}

With $a=0$ and $n$ a nonnegative integer, this reduces to an ordinary Laguerre
polynomial, the sequence of which begins

\begin{equation}
L_0(z) = 1, \quad L_1(z)=1-z, \quad L_2(z) = z^2-2z+1, \ldots
\end{equation}

The Laguerre polynomials are orthogonal with respect to the weight $z^a e^{-z}$ on $[0, \infty)$.


Evaluation for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> laguerre(5, 0, 0.25)
0.03726399739583333333333333
>>> laguerre(1+j, 0.5, 2+3j)
(4.474921610704496808379097 - 11.02058050372068958069241j)
>>> laguerre(2, 0, 10000)
49980001.0
>>> laguerre(2.5, 0, 10000)
-9.327764910194842158583189e+4328
\end{lstlisting}




\subsection{Laguerre Polynomials}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{LaguerreLMpMath? mpNum? $L_n (x)$, the Laguerre polynomials of degree $n \geq 0$.}
	{n? mpNum? An Integer.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns $L_n (x)$, the Laguerre polynomials of degree $n \geq 0$. The Laguerre polynomials are just special cases of the generalized Laguerre polynomials
\begin{equation}
L_n (x) = L^{(0)}_n (x).
\end{equation}



%\newpage
\subsection{Associated Laguerre Polynomials}


\begin{mpFunctionsExtract}
	\mpFunctionThreeNotImplemented
	{AssociatedLaguerreMpMath? mpNum? $L^m_n (x)$, the associated Laguerre polynomials of degree $n \geq 0$ and order $m \geq 0$.}
	{n? mpNum? An Integer.}
	{m? mpNum? An Integer.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns $L^m_n (x)$, the associated Laguerre polynomials of degree $n \geq 0$ and order $m \geq 0$, defined as
\begin{equation}
L^m_n (x) = (-1)^m \frac{d^m}{dx^m} L_{n+m} (x).
\end{equation}
The  $L^m_n (x)$ are computed using the generalized Laguerre polynomials
\begin{equation}
L^m_n (x) = L^{(m)}_n (x).
\end{equation}






\newpage
\chapter{Hypergeometric functions}
The functions listed in Exponential integrals and error functions, Bessel functions and related functions and Orthogonal polynomials, and many other functions as well, are merely particular instances of the generalized hypergeometric function ${}_pF_q$. The functions listed in
the following section enable efficient direct evaluation of the underlying hypergeometric series, as well as linear combinations, limits with respect to parameters, and analytic continuations thereof. Extensions to twodimensional series are also provided. See also the
basic or q-analog of the hypergeometric series in q-functions.

\vpara
For convenience, most of the hypergeometric series of low order are provided as standalone functions. They can equivalently be evaluated using hyper(). As will be demonstrated in the respective docstrings, all the hyp\#f\# functions implement analytic continuations and/or asymptotic expansions with respect to the argument , thereby permitting evaluation for anywhere in the complex plane. Functions of higher degree can be computed via hyper(), but generally only in rapidly convergent instances.

\vpara
Most hypergeometric and hypergeometric-derived functions accept optional keyword arguments to specify options for hypercomb() or hyper(). Some useful options are maxprec, maxterms, zeroprec, accurate\_small, hmag, force\_series, asymp\_tol and eliminate. These options give control over what to do in case of slow convergence, extreme loss of accuracy or evaluation at zeros (these two cases cannot generally be distinguished from each other automatically), and singular parameter combinations.

\vpara
For alternative implementations, see e.g. \cite{pearson_2009}, \cite{Muller_2001} or  \cite{Forrey_1997}.

%An implementation is available in \cite{Ehrhard_2013}





\newpage

\section{Confluent Hypergeometric Limit Function}
\label{Hypergeometric0F1MpMath}



\subsection{Confluent Hypergeometric Limit Function}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{hyp0f1? mpNum? the hypergeometric function ${}_0F_1$}
	{a? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
Gives the hypergeometric function ${}_0F_1$, sometimes known as the confluent limit function, defined as

\begin{equation}
{}_0F_1(a,z) = \sum_{k=0}^{\infty} \frac{1}{(a)_k} \frac{z^k}{k!}.
\end{equation}

This function satisfies the differential equation $z f''(z) + a f'(z) = f(z)$, and is related to the Bessel function of the first kind (see besselj()). 

\vspace{0.3cm}
This functions returns the confluent hypergeometric limit function ${}_0F_1(b; x)$, defined for $b \neq 0,-1,-2,-3, \cdots$,  by the series 

\begin{equation}
{}_0F_1(b;x) = {}_0F_1(-;b;x) = \sum_{n=0}^\infty \frac{x^n}{(b)_n n!}
\end{equation}
where $(a)_k$ is the Pochammer symbol (see section \ref{PochhammerSymbol})

The function is calculated by treating ${}_0F_1(b;0) = 1$ as special case, and otherwise using the following relations to Bessel functions:
\begin{equation}
{}_0F_1(b;x) = \Gamma(b) (+x)^{(1-b)/2} I_{b-1}\left(2\sqrt{+x}\right), \quad x>0,
\end{equation}
\begin{equation}
{}_0F_1(b;x) = \Gamma(b) (-x)^{(1-b)/2} J_{b-1}\left(2\sqrt{-x}\right), \quad x<0,
\end{equation}


\vpara
hyp0f1(a,z) is equivalent to hyper([],[a],z); see documentation for hyper() for more information.

Examples

Evaluation for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hyp0f1(2, 0.25)
1.130318207984970054415392
>>> hyp0f1((1,2), 1234567)
6.27287187546220705604627e+964
>>> hyp0f1(3+4j, 1000000j)
(3.905169561300910030267132e+606 + 3.807708544441684513934213e+606j)
\end{lstlisting}

Evaluation is supported for arbitrarily large values of $z$, using asymptotic expansions:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyp0f1(1, 10**50)
2.131705322874965310390701e+8685889638065036553022565
>>> hyp0f1(1, -10**50)
1.115945364792025420300208e-13
\end{lstlisting}

Verifying the differential equation:

\lstset{language={Python}}
\begin{lstlisting}
>>> a = 2.5
>>> f = lambda z: hyp0f1(a,z)
>>> for z in [0, 10, 3+4j]:
... chop(z*diff(f,z,2) + a*diff(f,z) - f(z))
...
0.0
0.0
0.0
\end{lstlisting}



\subsection{Regularized Confluent Hypergeometric Limit Function}
\nomenclature{${}_0\widetilde{F}_1(b;x)$}{Regularized Confluent Hypergeometric Limit Function}
\label{Hypergeometric0F1RegularizedMpMath}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{Hypergeometric0F1RegularizedMpMath? mpNum? the regularized confluent hypergeometric limit function ${}_0F_1(b; x)$.}
	{b? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The regularized confluent hypergeometric limit function ${}_0\widetilde{F}_1(b;x)$ for unrestricted $b$ is defined by [30, 15.1.2]
\begin{equation}
{}_0\widetilde{F}_1(b;x) = \frac{1}{\Gamma(b)} {}_0F_1(b;x), \quad \quad (b \neq	0, -1, -2, \cdots)  
\end{equation}
and by the corresponding limit if $b = 0, -1, -2, \cdots, = -n$, with the value
\begin{equation}
{}_0\widetilde{F}_1(-n;x) = x^{n+1} {}_0F_1(n+2;x), \quad n \in \mathbb{N}
\end{equation}
where $\Gamma(\cdot)$ is the Gamma function (see section \ref{GammaFunction}).







\newpage
\section{Kummer's Confluent Hypergeometric Functions and related functions}




\subsection{Kummer's Confluent Hypergeometric Function of the first kind}
\label{Hypergeometric1F1MpMath}
\nomenclature{${}_1F_1(a,b;z)$}{Kummer's Confluent Hypergeometric Function}


\begin{mpFunctionsExtract}
	\mpFunctionThree
	{hyp1f1? mpNum? the confluent hypergeometric function of the first kind ${}_1F_1(a,b;z)$}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The confluent hypergeometric function of the first kind is defined as

\begin{equation}
 {}_1F_1(a,b;z) = \sum_{k=0}^\infty\frac{(a)_k}{(b)_k}\cdot\frac{z^k}{k!}
\end{equation}

also known as Kummer's function and sometimes denoted by $M(a,b;z)$. This function gives one solution to the confluent (Kummer's) differential equation

\begin{equation}
z f''(z) + (b-z) f'(z) -a f(z)=0.
\end{equation}

A second solution is given by the $U$ function; see hyperu(). Solutions are also given in an alternate form by the Whittaker functions (whitm(), whitw()).


\vspace{0.3cm}
This functions returns the Kummer's confluent hypergeometric function ${}_1F_1(a, b; x)$, defined by the series 

\begin{equation}
{}_1F_1(a,b;z) = M(a,b;z) = \sum_{n=0}^\infty\frac{(a)_n}{(b)_n}\cdot\frac{z^n}{n!}
\end{equation}
where $(a)_k$ is the Pochammer symbol (see section \ref{PochhammerSymbol})

The function has the following integral representation
\begin{equation}
{}_1{F}_1(a,b;z)  = B(a,b-a)^{-1} \int_0^1{e^{zt}  t^{a-1}(1-t)^{b-a-1}}dt, \quad \Re b > \Re a > 0
\end{equation}

The following closed-form approximation based on a Laplace approximation has been derived by \cite{Butler_Wood_2002}:
\begin{equation}
{}_1{F}_1(a,b;z)  \approx  \frac{G_1(a,b;z)}{G_1(a,b;0)}, \quad \text{where}
\end{equation}
\begin{center}
	$G_1(a,b,c;z) = w^{-1/2} y^a (1-y)^{b-a} e^xy$,
	
	\vspace{0.3cm}
	$w = a(1-y)^2 + (b-a)y^2$
	
	\vspace{0.3cm}
	$y = [(x-b) + \sqrt{(x-b)^2 + 4ax}] / 2x$, if $x \neq 0$, and $y=a/b$ otherwise.
\end{center}





\vpara
hyp1f1(a,b,z) is equivalent to hyper([a],[b],z); see documentation for hyper() for more information.

Parameters may be complex:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyp1f1(2+3j, -1+j, 10j)
(261.8977905181045142673351 + 160.8930312845682213562172j)
\end{lstlisting}

Arbitrarily large values of are supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyp1f1(3, 4, 10**20)
3.890569218254486878220752e+43429448190325182745
>>> hyp1f1(3, 4, -10**20)
6.0e-60
>>> hyp1f1(3, 4, 10**20*j)
(-1.935753855797342532571597e-20 - 2.291911213325184901239155e-20j)
\end{lstlisting}

Verifying the differential equation:

\lstset{language={Python}}
\begin{lstlisting}
>>> a, b = 1.5, 2
>>> f = lambda z: hyp1f1(a,b,z)
>>> for z in [0, -10, 3, 3+4j]:
... chop(z*diff(f,z,2) + (b-z)*diff(f,z) - a*f(z))
...
0.0
0.0
0.0
0.0
\end{lstlisting}



\subsection{Kummer's Regularized Confluent Hypergeometric Function}
\nomenclature{${}_1\widetilde{F}_1(a,b;z)$}{Kummer's Regularized Confluent Hypergeometric Function}
\label{Hypergeometric1F1RegularizedMpMath}

\begin{mpFunctionsExtract}
	\mpFunctionThreeNotImplemented
	{Hypergeometric1F1RegularizedMpMath? mpNum? Kummer's regularized confluent hypergeometric function ${}_1F_1(a, b; x)$.}
	{a? mpNum? A real number.}
	{b? mpNum? A real number.}
	{z? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the Kummer's regularized confluent hypergeometric function ${}_1\widetilde{F}_1(a,b;z)$ for unrestricted $b$, defined by [30, 15.1.2]
\begin{equation}
{}_1\widetilde{F}_1(a,b;z)  = \frac{1}{\Gamma(b)} {}_1F_1(a;b;z) = \boldsymbol{M}(a,b;x) = \frac{1}{\Gamma(b)} M(a;b;z), \quad \quad (b \neq	0, -1, -2, \cdots)
\end{equation}
and by the corresponding limit if $b = 0, -1, -2, \cdots, = -n$, with the value
\begin{equation}
{}_1\widetilde{F}_1(a,b;z)  = \frac{(a)_{n+1}}{(n+1)!} x^{n+1} {}_1F_1(a+n+1;n+2;z), \quad n \in \mathbb{N}
\end{equation}
where $\Gamma(\cdot)$ is the Gamma function (see section \ref{GammaFunction}) and $(a)_k$ is the Pochammer symbol (see section \ref{PochhammerSymbol})

The function has the following integral representation
\begin{equation}
{}_1\widetilde{F}_1(a,b;-m;z)  = \frac{1}{\Gamma(a)\Gamma(b-a)} \int_0^1{e^{zt}  t^{a-1}(1-t)^{b-a-1}}dt, \quad \Re b > \Re a > 0
\end{equation}





\subsection{Kummer's Confluent Hypergeometric Function of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{hyperu? mpNum? the Tricomi confluent hypergeometric function $U$}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Kummer or confluent hypergeometric function of the second kind is also known as the Tricomi confluent hypergeometric function, $U$. This function gives a second linearly independent solution to the confluent hypergeometric differential equation (the first is provided by ${}_1F_1$ - see hyp1f1()).


\vspace{0.3cm}
This functions returns the Tricomi's confluent hypergeometric function $U(a, b; x)$ for $x>0$ and $b \neq 0, \pm1 \pm2, \cdots$,  defined by  

\begin{equation}
U(a,b;x) = \frac{\Gamma(1-b)}{\Gamma(1+a-b)} M(a,b;c;z) + \frac{\Gamma(1-b)}{\Gamma(a)} x^{1-b} M(1+a-b,2-b;x) 
\end{equation}
where $\Gamma(\cdot)$ is the Gamma function (see section \ref{GammaFunction}).




Examples

Evaluation for arbitrary complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hyperu(2,3,4)
0.0625
>>> hyperu(0.25, 5, 1000)
0.1779949416140579573763523
>>> hyperu(0.25, 5, -1000)
(0.1256256609322773150118907 - 0.1256256609322773150118907j)
\end{lstlisting}



\subsection{Hypergeometric Function 2F0}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{hyp2f0? mpNum? the hypergeometric function ${}_2F_0$}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The hypergeometric function ${}_2F_0$ is defined formally by the series

\begin{equation}
{}_2F_0(a,b;;z) = \sum_{n=0}^{\infty}(a)_n (b)_n \frac{z^n}{n!}
\end{equation}

This series usually does not converge. For small enough $z$, it can be viewed as an asymptotic series that may be summed directly with an appropriate truncation. When this is not the case, hyp2f0() gives a regularized sum, or equivalently, it uses a representation in terms of the hypergeometric U function [1]. The series also converges when either $a$or $b$ is a nonpositive integer, as it then terminates into a polynomial after $-a$ or $-b$ terms.

Examples

Evaluation is supported for arbitrary complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hyp2f0((2,3), 1.25, -100)
0.07095851870980052763312791
>>> hyp2f0((2,3), 1.25, 100)
(-0.03254379032170590665041131 + 0.07269254613282301012735797j)
>>> hyp2f0(-0.75, 1-j, 4j)
(-0.3579987031082732264862155 - 3.052951783922142735255881j)
\end{lstlisting}

Even with real arguments, the regularized value of 2F0 is often complex-valued, but the imaginary part decreases exponentially as $z \rightarrow 0$. In the following example, the first call uses complex evaluation while the second has a small enough $z$ to evaluate using the direct series and thus the returned value is strictly real (this should be taken to indicate that the imaginary part is less than eps):

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15
>>> hyp2f0(1.5, 0.5, 0.05)
(1.04166637647907 + 8.34584913683906e-8j)
>>> hyp2f0(1.5, 0.5, 0.0005)
1.00037535207621
\end{lstlisting}

The imaginary part can be retrieved by increasing the working precision:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 80
>>> nprint(hyp2f0(1.5, 0.5, 0.009).imag)
1.23828e-46
\end{lstlisting}


\newpage
\section{Whittaker functions M and W}

%
%\subsection{Whittaker M Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{WhittakerMMpMath? mpNum? the Whittaker function $M_{\kappa, \mu}(x)$.}
%	{$\kappa$? mpNum? A real number.}
%	{$\mu$? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the Whittaker function $M_{\kappa, \mu}(x)$, defined by
%\begin{equation}
%M_{\kappa, \mu}(x) = e^{-\frac{1}{2}x} x^{\frac{1}{2}+\mu} M\left(\tfrac{1}{2} + \mu - \kappa, 1 + 2 \mu, x\right)
%\end{equation}
%
%
%
%
%
%\subsection{Whittaker W Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{WhittakerWMpMath? mpNum? the Whittaker function $W_{\kappa, \mu}(x)$.}
%	{$\kappa$? mpNum? A real number.}
%	{$\mu$? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the Whittaker function $W_{\kappa, \mu}(x)$, defined by
%\begin{equation}
%W_{\kappa, \mu}(x) = e^{-\frac{1}{2}x} x^{\frac{1}{2}+\mu} U\left(\tfrac{1}{2} + \mu - \kappa, 1 + 2 \mu, x\right)
%\end{equation}
%
%

\subsection{Whittaker function M}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{whitm? mpNum? the Whittaker function $M$}
	{k? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Whittaker function $M(k, m, z)$ gives a solution to the Whittaker differential equation

\begin{equation}
\frac{d^2}{dz^2} + \left(-\frac{1}{4} + \frac{k}{z} + \frac{\frac{1}{4}-m^2}{z^2}  \right)f=0.
\end{equation}

A second solution is given by whitw().

The Whittaker functions are defined in Abramowitz \& Stegun, section 13.
They are alternate forms of the confluent hypergeometric functions ${}_1F_1$ and $U$:

\begin{equation}
M(k, m, z) = e^{-\frac{1}{2}z} z^{\frac{1}{2}+m} {}_1F_1\left(\tfrac{1}{2}+m-k, 1+2m, z \right)
\end{equation}
\begin{equation}
W(k, m, z) = e^{-\frac{1}{2}z} z^{\frac{1}{2}+m} U\left(\tfrac{1}{2}+m-k, 1+2m, z \right)
\end{equation}

Examples

Evaluation for arbitrary real and complex arguments is supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> whitm(1, 1, 1)
0.7302596799460411820509668
>>> whitm(1, 1, -1)
(0.0 - 1.417977827655098025684246j)
>>> whitm(j, j/2, 2+3j)
(3.245477713363581112736478 - 0.822879187542699127327782j)
>>> whitm(2, 3, 100000)
4.303985255686378497193063e+21707
\end{lstlisting}



\subsection{Whittaker function W}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{whitw? mpNum? the Whittaker function $W$}
	{k? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Whittaker function $W(k, m, z)$ gives a solution to the Whittaker differential equation. See whitw().

Examples

Evaluation for arbitrary real and complex arguments is supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> whitw(1, 1, 1)
1.19532063107581155661012
>>> whitw(1, 1, -1)
(-0.9424875979222187313924639 - 0.2607738054097702293308689j)
>>> whitw(j, j/2, 2+3j)
(0.1782899315111033879430369 - 0.01609578360403649340169406j)
>>> whitw(2, 3, 100000)
1.887705114889527446891274e-21705
>>> whitw(-1, -1, 100)
1.905250692824046162462058e-24
\end{lstlisting}







\newpage

\section{Gauss Hypergeometric Function}

\subsection{Gauss Hypergeometric Function}
\nomenclature{${}_2F_1(a,b;c;x)$}{Gauss Hypergeometric Function}
\label{sec:Hypergeometric2F1MpMath}
\begin{mpFunctionsExtract}
	\mpFunctionFour
	{hyp2f1? mpNum? the square of $z$.}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}
	{c? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The Gauss hypergeometric function ${}_2F_1$ (often simply referred to as \textit{the} hypergeometric function), defined for
$| z | < 1$ by the series 

\begin{equation}
 {}_2F_1(a,b;c;z) = \sum_{k=0}^\infty\frac{(a)_k(b)_k}{(c)_k}\cdot\frac{z^k}{k!}
\end{equation}

and for $|z| \geq 1$ by analytic continuation, with a branch cut on $1,\infty$ when necessary.

\vpara
Special cases of this function include many of the orthogonal polynomials as well as the incomplete beta function and other functions. Properties of the Gauss hypergeometric function are documented comprehensively in many references, for example Abramowitz \& Stegun, section 15.

\vpara
The implementation supports the analytic continuation as well as evaluation close to the unit circle where $|z| \approx 1$. The syntax hyp2f1(a,b,c,z) is equivalent to hyper([a,b],[c],z).


\vspace{0.3cm}
This functions returns the Gauss hypergeometric function ${}_2F_1(a, b; c; x)$, defined for
$| x | < 1$ by the series 

\begin{equation}
{}_2F_1(a,b;c;x) = \sum_{k=0}^\infty\frac{(a)_k(b)_k}{(c)_k}\cdot\frac{x^k}{k!}
\end{equation}
where $(a)_k$ is the Pochammer symbol (see section \ref{PochhammerSymbol})


The function has the following integral representation
\begin{equation}
{}_2{F}_1(a,b;c;z)  =  B(a,c-a)^{-1}  \int_0^1{\frac{t^{b-1}(1-t)^{c-b-1}}{(1-zt)^a}}dt, \quad \Re c > \Re b > 0
\end{equation}
where $B(\cdot,\cdot)$ is the Beta function (see section \ref{BetaFunction})

The following closed-form approximation based on a Laplace approximation has been derived by \cite{Butler_Wood_2002}:
\begin{equation}
{}_2{F}_1(a,b;c;z)  \approx  \frac{G_2(a,b,c;z)}{G_2(a,b,c;0)}, \quad \text{where}
\end{equation}
\begin{center}
	$G_2(a,b,c;z) = w^{-1/2} y^a (1-y)^{c-a} (1-xy)^{-b}$,
	
	\vspace{0.3cm}
	$w = a(1-y)^2 + (c-a)y^2 - b x^2 y^2 (1-y)^2 / (1-xy)^2$
	
	\vspace{0.3cm}
	$y = [\tau + \sqrt{\tau^2 - 4ax (c-b)}] / [2x(b-c)]$, if $x \neq 0$, and $y=a/c$ otherwise.
	
	\vspace{0.3cm}
	$\tau = x(b-a)-c$.
\end{center}


\vpara
Examples

Evaluation with inside, outside and on the unit circle, for fixed parameters:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hyp2f1(2, (1,2), 4, 0.75)
1.303703703703703703703704
>>> hyp2f1(2, (1,2), 4, -1.75)
0.7431290566046919177853916
>>> hyp2f1(2, (1,2), 4, 1.75)
(1.418075801749271137026239 - 1.114976146679907015775102j)
>>> hyp2f1(2, (1,2), 4, 1)
1.6
>>> hyp2f1(2, (1,2), 4, -1)
0.8235498012182875315037882
>>> hyp2f1(2, (1,2), 4, j)
(0.9144026291433065674259078 + 0.2050415770437884900574923j)
>>> hyp2f1(2, (1,2), 4, 2+j)
(0.9274013540258103029011549 + 0.7455257875808100868984496j)
>>> hyp2f1(2, (1,2), 4, 0.25j)
(0.9931169055799728251931672 + 0.06154836525312066938147793j)
\end{lstlisting}

Evaluation with complex parameter values:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyp2f1(1+j, 0.75, 10j, 1+5j)
(0.8834833319713479923389638 + 0.7053886880648105068343509j)
\end{lstlisting}

Evaluation with $z=1$ :

\lstset{language={Python}}
\begin{lstlisting}
>>> hyp2f1(-2.5, 3.5, 1.5, 1)
0.0
>>> hyp2f1(-2.5, 3, 4, 1)
0.06926406926406926406926407
>>> hyp2f1(2, 3, 4, 1)
+inf
\end{lstlisting}


Arbitrarily large values of are supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyp2f1((-1,3), 1.75, 4, '1e100')
(7.883714220959876246415651e+32 + 1.365499358305579597618785e+33j)
>>> hyp2f1((-1,3), 1.75, 4, '1e1000000')
(7.883714220959876246415651e+333332 + 1.365499358305579597618785e+333333j)
>>> hyp2f1((-1,3), 1.75, 4, '1e1000000j')
(1.365499358305579597618785e+333333 - 7.883714220959876246415651e+333332j)
\end{lstlisting}

Verifying the differential equation:

\lstset{language={Python}}
\begin{lstlisting}
>>> f = lambda z: hyp2f1(a,b,c,z)
>>> chop(z*(1-z)*diff(f,z,2) + (c-(a+b+1)*z)*diff(f,z) - a*b*f(z))
0.0
\end{lstlisting}



\subsection{Gauss Regularized Hypergeometric Function}
\nomenclature{${}_2\widetilde{F}_1(a,b;c;z)$}{Gauss Regularized Hypergeometric Function}

\begin{mpFunctionsExtract}
	\mpFunctionFourNotImplemented
	{Hypergeometric2F1RegularizedMpMath? mpNum? the regularized Gauss hypergeometric function ${}_2F_1(a, b; c; x)$.}
	{a? mpNum? A real number.}
	{b? mpNum? A real number.}
	{c? mpNum? A real number.}
	{z? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The regularized Gauss hypergeometric function ${}_2\widetilde{F}_1(a,b;c;z)$ for unrestricted $c$, is defined by [30, 15.1.2]
\begin{equation}
{}_2\widetilde{F}_1(a,b;c;z)  = \frac{1}{\Gamma(c)} {}_2F_1(a,b;c;z) = \boldsymbol{F}(a,b;c;z), \quad \quad (c \neq	0, -1, -2, \cdots)
\end{equation}
and by the corresponding limit if $c = 0, -1, -2, \cdots, = -m$, with the value
\begin{equation}
{}_2\widetilde{F}_1(a,b;-m;z)  = \frac{(a)_{m+1}(b)_{m+1}}{(m+1)!} x^{m+1} {}_2F_1(a+m+1,a+m+1;m+2;z) 
\end{equation}
where $\Gamma(\cdot)$ is the Gamma function (see section \ref{GammaFunction}) and $(a)_k$ is the Pochammer symbol (see section \ref{PochhammerSymbol})

The function has the following integral representation
\begin{equation}
{}_2\widetilde{F}_1(a,b;c;z)  = \frac{1}{\Gamma(b)\Gamma(c-b)} \int_0^1{\frac{t^{b-1}(1-t)^{c-b-1}}{(1-zt)^a}}dt, \quad \Re c > \Re b > 0
\end{equation}






\newpage
\section{Additional Hypergeometric Functions}


\subsection{Hypergeometric Function 1F2}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{hyp1f2? mpNum? the the hypergeometric function ${}_1F_2(a_1; b_1, b_2; z)$}
	{a1? mpNum? A real or complex number.}
	{b1? mpNum? A real or complex number.}	
	{b2? mpNum? A real or complex number.}		
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
Gives the hypergeometric function ${}_1F_2(a_1; b_1, b_2; z)$. The call hyp1f2(a1,b1,b2,z) is equivalent to hyper([a1],[b1,b2],z).

Evaluation works for complex and arbitrarily large arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> a, b, c = 1.5, (-1,3), 2.25
>>> hyp1f2(a, b, c, 10**20)
-1.159388148811981535941434e+8685889639
>>> hyp1f2(a, b, c, -10**20)
-12.60262607892655945795907
>>> hyp1f2(a, b, c, 10**20*j)
(4.237220401382240876065501e+6141851464 - 2.950930337531768015892987e+6141851464j)
>>> hyp1f2(2+3j, -2j, 0.5j, 10-20j)
(135881.9905586966432662004 - 86681.95885418079535738828j)
\end{lstlisting}



\subsection{Hypergeometric Function 2F2}

\begin{mpFunctionsExtract}
	\mpFunctionFive
	{hyp2f2? mpNum? the hypergeometric function  ${}_2F_2(a_1; b_1, b_2; z)$.}
	{a1? mpNum? A real or complex number.}
	{a2? mpNum? A real or complex number.}
	{b1? mpNum? A real or complex number.}
	{b2? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
Gives the hypergeometric function ${}_2F_2(a_1,a2;b_1,b_2;z)$. The call hyp2f2(a1,a2,b1,b2,z) is equivalent to hyper([a1,a2],[b1,b2],z).

Evaluation works for complex and arbitrarily large arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> a, b, c, d = 1.5, (-1,3), 2.25, 4
>>> hyp2f2(a, b, c, d, 10**20)
-5.275758229007902299823821e+43429448190325182663
>>> hyp2f2(a, b, c, d, -10**20)
2561445.079983207701073448
>>> hyp2f2(a, b, c, d, 10**20*j)
(2218276.509664121194836667 - 1280722.539991603850462856j)
>>> hyp2f2(2+3j, -2j, 0.5j, 4j, 10-20j)
(80500.68321405666957342788 - 20346.82752982813540993502j)
\end{lstlisting}



\subsection{Hypergeometric Function 2F3}

\begin{mpFunctionsExtract}
	\mpFunctionSix
	{hyp2f3? mpNum? the hypergeometric function ${}_2F_3(a_1,a2;b_1,b_2,b_3;z)$.}
	{a1? mpNum? A real or complex number.}
	{a2? mpNum? A real or complex number.}
	{b1? mpNum? A real or complex number.}
	{b2? mpNum? A real or complex number.}	
	{b3? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
Gives the hypergeometric function ${}_2F_3(a_1,a2;b_1,b_2,b_3;z)$. The call hyp2f3(a1,a2,b1,b2,b3,z) is equivalent to hyper([a1,a2],[b1,b2,b3],z).

Evaluation works for complex and arbitrarily large arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> a1,a2,b1,b2,b3 = 1.5, (-1,3), 2.25, 4, (1,5)
>>> hyp2f3(a1,a2,b1,b2,b3,10**20)
-4.169178177065714963568963e+8685889590
>>> hyp2f3(a1,a2,b1,b2,b3,-10**20)
7064472.587757755088178629
>>> hyp2f3(a1,a2,b1,b2,b3,10**20*j)
(-5.163368465314934589818543e+6141851415 + 1.783578125755972803440364e+6141851416j)
>>> hyp2f3(2+3j, -2j, 0.5j, 4j, -1-j, 10-20j)
(-2280.938956687033150740228 + 13620.97336609573659199632j)
>>> hyp2f3(2+3j, -2j, 0.5j, 4j, -1-j, 10000000-20000000j)
(4.849835186175096516193e+3504 - 3.365981529122220091353633e+3504j)
\end{lstlisting}




\subsection{Hypergeometric Function 3F2}

\begin{mpFunctionsExtract}
	\mpFunctionSix
	{hyp3f2? mpNum? hypergeometric function ${}_3F_2$.}
	{a1? mpNum? A real or complex number.}
	{a2? mpNum? A real or complex number.}
	{a3? mpNum? A real or complex number.}	
	{b1? mpNum? A real or complex number.}
	{b2? mpNum? A real or complex number.}	
	{z? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
Gives the hypergeometric function ${}_3F_2$, defined for $|z|<1$ as

\begin{equation}
{}_3F_2(a_1,a_2,a_3;b_1,b_2;z) = \sum_{k=0}^{\infty} \frac{(a_1)_k (a_2)_k (a_3)_k}{(b_1)_k (b_2)_k} \frac{z^k}{k!},
\end{equation}

and for $|z \geq 1|$ by analytic continuation. The analytic structure of this function is similar to that of ${}_2F_1$, generally with a singularity at $z=1$ and a branch cut on $(1, \infty)$.

\vpara
Evaluation is supported inside, on, and outside the circle of convergence $|z|=1$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> hyp3f2(1,2,3,4,5,0.25)
1.083533123380934241548707
>>> hyp3f2(1,2+2j,3,4,5,-10+10j)
(0.1574651066006004632914361 - 0.03194209021885226400892963j)
>>> hyp3f2(1,2,3,4,5,-10)
0.3071141169208772603266489
>>> hyp3f2(1,2,3,4,5,10)
(-0.4857045320523947050581423 - 0.5988311440454888436888028j)
>>> hyp3f2(0.25,1,1,2,1.5,1)
1.157370995096772047567631
>>> (8-pi-2*ln2)/3
1.157370995096772047567631
>>> hyp3f2(1+j,0.5j,2,1,-2j,-1)
(1.74518490615029486475959 + 0.1454701525056682297614029j)
>>> hyp3f2(1+j,0.5j,2,1,-2j,sqrt(j))
(0.9829816481834277511138055 - 0.4059040020276937085081127j)
>>> hyp3f2(-3,2,1,-5,4,1)
1.41
>>> hyp3f2(-3,2,1,-5,4,2)
2.12
\end{lstlisting}


Evaluation very close to the unit circle:

\lstset{language={Python}}
\begin{lstlisting}
>>> hyp3f2(1,2,3,4,5,'1.0001')
(1.564877796743282766872279 - 3.76821518787438186031973e-11j)
>>> hyp3f2(1,2,3,4,5,'1+0.0001j')
(1.564747153061671573212831 + 0.0001305757570366084557648482j)
>>> hyp3f2(1,2,3,4,5,'0.9999')
1.564616644881686134983664
>>> hyp3f2(1,2,3,4,5,'-0.9999')
0.7823896253461678060196207
\end{lstlisting}



\newpage
\section{Generalized hypergeometric functions}

\subsection{Generalized hypergeometric function pFq}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{hyper? mpNum? the generalized hypergeometric function${}_pF_q$}
	{as? mpNum? list of real or complex numbers.}
	{bs? mpNum? list of real or complex numbers.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
Evaluates the generalized hypergeometric function

\begin{equation}
{}_pF_q(a_1,\ldots,a_p;b_1,\ldots,b_q;z) = \sum_{n=0}^{\infty} \frac{(a_1)_n (a_2)_n \ldots (a_p)_k}{(b_1)_n (b_2)_n \ldots (b_q)_n} \frac{z^n}{n!},
\end{equation}


where $(x)_n$ denotes the rising factorial (see rf()).

The parameters lists a\_s and b\_s may contain integers, real numbers, complex numbers, as well as exact fractions given in the form of tuples $(p,q)$. hyper() is optimized to handle integers and fractions more efficiently than arbitrary floating-point parameters (since rational parameters are by far the most common).

The parameters can be any combination of integers, fractions, floats and complex numbers:

\lstset{language={Python}}
\begin{lstlisting}
>>> a, b, c, d, e = 1, (-1,2), pi, 3+4j, (2,3)
>>> x = 0.2j
>>> hyper([a,b],[c,d,e],x)
(0.9923571616434024810831887 - 0.005753848733883879742993122j)
>>> b, e = -0.5, mpf(2)/3
>>> fn = lambda n: rf(a,n)*rf(b,n)/rf(c,n)/rf(d,n)/rf(e,n)*x**n/fac(n)
>>> nsum(fn, [0, inf])
(0.9923571616434024810831887 - 0.005753848733883879742993122j)
\end{lstlisting}

If any $b_k$ is a nonpositive integer, the function is undefined (unless the series terminates before the division by zero occurs):

\lstset{language={Python}}
\begin{lstlisting}
>>> hyper([1,1,1,-3],[-2,5],1)
Traceback (most recent call last):
...
ZeroDivisionError: pole in hypergeometric series
>>> hyper([1,1,1,-1],[-2,5],1)
1.1
\end{lstlisting}


Except for polynomial cases, the radius of convergence $R$ of the hypergeometric series is either $R=\infty$ (if $p \leq q$), $R=1$ (if $p=q+1$), or $R=0$ (if $p>q+1$).

The analytic continuations of the functions with $p=q+1$, i.e. ${}_2F_1$, ${}_3F_2$, ${}_4F_3$, etc, are all implemented and therefore these functions can be evaluated for $|z|\geq 1$. The shortcuts hyp2f1(), hyp3f2() are available to handle the most common cases (see their documentation), but functions of higher degree are also supported via hyper():

\lstset{language={Python}}
\begin{lstlisting}
>>> hyper([1,2,3,4], [5,6,7], 1)   # 4F3 at finite-valued branch point
1.141783505526870731311423
>>> hyper([4,5,6,7], [1,2,3], 1)   # 4F3 at pole
+inf
>>> hyper([1,2,3,4,5], [6,7,8,9], 10)    # 5F4
(1.543998916527972259717257 - 0.5876309929580408028816365j)
>>> hyper([1,2,3,4,5,6], [7,8,9,10,11], 1j)   # 6F5
(0.9996565821853579063502466 + 0.0129721075905630604445669j)
\end{lstlisting}

Please note that, as currently implemented, evaluation of ${}_pF_{p-1}$  with $p \geq 3$ may be slow or inaccurate when $|z-1|$ is small, for some parameter values.

When $p>q+1$, hyper computes the (iterated) Borel sum of the divergent series. For ${}_2F_0$ the Borel sum has an analytic solution and can be computed efficiently (see hyp2f0()). For higher degrees, the functions is evaluated first by attempting to sum it directly as an asymptotic series (this only works for tiny $|z|$), and then by evaluating the
Borel regularized sum using numerical integration. Except for special parameter combinations, this can be extremely slow.

\lstset{language={Python}}
\begin{lstlisting}
>>> hyper([1,1], [], 0.5) # regularization of 2F0
(1.340965419580146562086448 + 0.8503366631752726568782447j)
>>> hyper([1,1,1,1], [1], 0.5) # regularization of 4F1
(1.108287213689475145830699 + 0.5327107430640678181200491j)
\end{lstlisting}

With the following magnitude of argument, the asymptotic series for ${}_3F_1$ gives only a few digits. Using Borel summation, hyper can produce a value with full accuracy:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15
>>> hyper([2,0.5,4], [5.25], '0.08', force_series=True)
Traceback (most recent call last):
...
NoConvergence: Hypergeometric series converges too slowly. Try increasing maxterms.
>>> hyper([2,0.5,4], [5.25], '0.08', asymp_tol=1e-4)
1.0725535790737
>>> hyper([2,0.5,4], [5.25], '0.08')
(1.07269542893559 + 5.54668863216891e-5j)
>>> hyper([2,0.5,4], [5.25], '-0.08', asymp_tol=1e-4)
0.946344925484879
>>> hyper([2,0.5,4], [5.25], '-0.08')
0.946312503737771
>>> mp.dps = 25
>>> hyper([2,0.5,4], [5.25], '-0.08')
0.9463125037377662296700858
\end{lstlisting}

Note that with the positive $z$ value, there is a complex part in the correct result, which falls below the tolerance of the asymptotic series.

%\newpage
%\section{hypercomb()}



\subsection{Weighted combination of hypergeometric functions}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{hypercomb? mpNum? a weighted combination of hypergeometric functions}
	{f? mpFunction? a real or function.}
	{params? mpNum? list of real or complex numbers.}
	{z? mpNum? A real or complex number.}
	{Keywords? String ? discardknownzeros=True.}			
\end{mpFunctionsExtract}

\vpara
Computes a weighted combination of hypergeometric functions

\begin{equation}
\sum_{r=1}^N \left[\prod_{k=1}^{l_r} (w_{r,k})^{c_{r,k}} \frac{\prod_{k=1}^{m_r}\Gamma(\alpha_{r,k})}{\prod_{k=1}^{n_r}\Gamma(\beta_{r,k})} {}_{p_r}F_{q_r} (a_{r,1},\ldots,a_{r,p}; b_{r,1},\ldots,b_{r,q}; z_r)\right]
\end{equation}

Typically the parameters are linear combinations of a small set of base parameters; hypercomb() permits computing a correct value in the case that some of the $\alpha$, $\beta$, $b$ turn out to be nonpositive integers, or if division by zero occurs for some $w^c$, assuming that there are opposing singularities that cancel out. The limit is computed by evaluating the function with the base parameters perturbed, at a higher working precision.

The first argument should be a function that takes the perturbable base parameters params as input and returns tuples (w, c, alpha, beta, a, b, z), where the coefficients w, c, gamma factors alpha, beta, and hypergeometric coefficients a, b each should be lists of numbers, and z should be a single number.

Examples

The following evaluates

\begin{equation}
(a-1)\frac{\Gamma(a-3)}{\Gamma(a-4)} {}_1F_1(a,a-1,z)=e^z (a-4)(a+z-1)
\end{equation}

with $a=1, z=3$. There is a zero factor, two gamma function poles, and the 1F1 function is singular; all singularities cancel out to give a finite value:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> hypercomb(lambda a: [([a-1],[1],[a-3],[a-4],[a],[a-1],3)], [1])
-180.769832308689
>>> -9*exp(3)
-180.769832308689
\end{lstlisting}



\newpage
\section{Meijer G-function}

%\subsection{Meijer G-function}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{meijerg? mpNum? the  Meijer G-function}
	{as? mpNum? list of real or complex numbers.}
	{bs? mpNum? list of real or complex numbers.}
	{z? mpNum? A real or complex number.}
	{Keywords? String?  r=1, series=1.}			
\end{mpFunctionsExtract}

\vpara
Evaluates the Meijer G-function, defined as
\begin{equation}
\MeijerG[a,b]{n}{p}{m}{q}{z;r} = \frac{1}{2\pi i} \int_L \frac{\prod_{j=1}^m \Gamma(b_j+s)\prod_{j=1}^n \Gamma(1-a_j-s)}{\prod_{j=n+1}^p \Gamma(a_j+s)\prod_{j=m+1}^q \Gamma(1-b_j-s)}z^{-s/r} ds
\end{equation}

for an appropriate choice of the contour $L$ (see references).

\vpara
There are $p$ elements $a_j$. The argument a\_s should be a pair of lists, the first containing the $n$ elements $a_1,\ldots,a_n$ and the second containing the $p-n$ elements $a_{n+1},\ldots,a_p$.

\vpara
There are $q$ elements $a_j$. The argument b\_s should be a pair of lists, the first containing the $m$ elements $b_1,\ldots,b_m$ and the second containing the $q-m$ elements $b_{m+1},\ldots,b_q$ .

\vpara
The implicit tuple $(m,n,p,q)$ constitutes the order or degree of the Meijer G-function, and is determined by the lengths of the coefficient vectors. Confusingly, the indices in this tuple appear in a different order from the coefficients, but this notation is standard. The many examples given below should hopefully clear up any potential confusion.

\vpara
The Meijer G-function is evaluated as a combination of hypergeometric series. There are two versions of the function, which can be selected with the optional \textit{series} argument.

\textit{series=1} uses a sum of $m$  ${}_pF_{q-1}$ functions of $z$

\textit{series=2} uses a sum of $n$  ${}_qF_{p-1}$ functions of $1/z$

\vpara
The default series is chosen based on the degree and $|z|$ in order to be consistent with Mathematica's. This definition of the Meijer G-function has a discontinuity at $|z|=1$ for some orders, which can be avoided by explicitly specifying a series.

Keyword arguments are forwarded to hypercomb().

\vpara
Many standard functions are special cases of the Meijer G-function (possibly rescaled and/or with branch cut corrections). We define some test parameters:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> a = mpf(0.75)
>>> b = mpf(1.5)
>>> z = mpf(2.25)
\end{lstlisting}

The exponential function:
\begin{equation}
e^z = \MeijerG[-,1]{0}{0}{1}{1}{-z}
\end{equation}


\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[],[]], [[0],[]], -z)
9.487735836358525720550369
>>> exp(z)
9.487735836358525720550369
\end{lstlisting}


The natural logarithm
\begin{equation}
\log(1+z) = \MeijerG[a,b]{2}{2}{1}{2}{-z}
\end{equation}


\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[1,1],[]], [[1],[0]], z)
1.178654996341646117219023
>>> log(1+z)
1.178654996341646117219023
\end{lstlisting}


A rational function
\begin{equation}
\frac{z}{z+1} = \MeijerG[a,b]{2}{2}{1}{2}{-z}
\end{equation}



\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[1,1],[]], [[1],[1]], z)
0.6923076923076923076923077
>>> z/(z+1)
0.6923076923076923076923077
\end{lstlisting}

The sine and cosine functions:
\begin{equation}
\frac{1}{\sqrt{\pi}} \sin(2\sqrt{z}) = \MeijerG[a,b]{0}{0}{1}{2}{z}
\end{equation}
\begin{equation}
\frac{1}{\sqrt{\pi}} \cos(2\sqrt{z}) = \MeijerG[a,b]{0}{0}{1}{2}{z}
\end{equation}

\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[],[]], [[0.5],[0]], (z/2)**2)
0.4389807929218676682296453
>>> sin(z)/sqrt(pi)
0.4389807929218676682296453
>>> meijerg([[],[]], [[0],[0.5]], (z/2)**2)
-0.3544090145996275423331762
>>> cos(z)/sqrt(pi)
-0.3544090145996275423331762
\end{lstlisting}

Bessel functions:
\begin{equation}
J_{\alpha}(2\sqrt{z}) = \MeijerG[a,b]{0}{0}{1}{2}{z}
\end{equation}
\begin{equation}
Y_{\alpha}(2\sqrt{z}) = \MeijerG[a,b]{0}{1}{2}{3}{z}
\end{equation}
\begin{equation}
(-z)^{\alpha/2} z^{-\alpha/2}  I_{\alpha}(2\sqrt{z}) = \MeijerG[a,b]{0}{0}{2}{2}{-z}
\end{equation}
\begin{equation}
2 K_{\alpha}(2\sqrt{z}) = \MeijerG[a,b]{0}{0}{2}{2}{z}
\end{equation}



As the example with the Bessel I function shows, a branch factor is required for some arguments when inverting the square root.

\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[],[]], [[a/2],[-a/2]], (z/2)**2)
0.5059425789597154858527264
>>> besselj(a,z)
0.5059425789597154858527264
>>> meijerg([[],[(-a-1)/2]], [[a/2,-a/2],[(-a-1)/2]], (z/2)**2)
0.1853868950066556941442559
>>> bessely(a, z)
0.1853868950066556941442559
>>> meijerg([[],[]], [[a/2],[-a/2]], -(z/2)**2)
(0.8685913322427653875717476 + 2.096964974460199200551738j)
>>> (-z)**(a/2) / z**(a/2) * besseli(a, z)
(0.8685913322427653875717476 + 2.096964974460199200551738j)
>>> 0.5*meijerg([[],[]], [[a/2,-a/2],[]], (z/2)**2)
0.09334163695597828403796071
>>> besselk(a,z)
0.09334163695597828403796071
\end{lstlisting}


Error functions:
\begin{equation}
\sqrt{\pi} z^{2(\alpha-1)} \text{erfc}(z) = \MeijerG[a,b]{0}{1}{2}{2}{z, \tfrac{1}{2}}
\end{equation}

\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[],[a]], [[a-1,a-0.5],[]], z, 0.5)
0.00172839843123091957468712
>>> sqrt(pi) * z**(2*a-2) * erfc(z)
0.00172839843123091957468712
\end{lstlisting}



A Meijer G-function of higher degree, (1,1,2,3):

\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[a],[b]], [[a],[b,a-1]], z)
1.55984467443050210115617
>>> sin((b-a)*pi)/pi*(exp(z)-1)*z**(a-1)
1.55984467443050210115617
\end{lstlisting}


A Meijer G-function of still higher degree, (4,1,2,4), that can be expanded as a messy combination of exponential integrals:

\lstset{language={Python}}
\begin{lstlisting}
>>> meijerg([[a],[2*b-a]], [[b,a,b-0.5,-1-a+2*b],[]], z)
0.3323667133658557271898061
>>> chop(4**(a-b+1)*sqrt(pi)*gamma(2*b-2*a)*z**a*\
... expint(2*b-2*a, -2*sqrt(-z))*expint(2*b-2*a, 2*sqrt(-z)))
0.3323667133658557271898061
\end{lstlisting}


In the following case, different series give different values:

\lstset{language={Python}}
\begin{lstlisting}
>>> chop(meijerg([[1],[0.25]],[[3],[0.5]],-2))
-0.06417628097442437076207337
>>> meijerg([[1],[0.25]],[[3],[0.5]],-2,series=1)
0.1428699426155117511873047
>>> chop(meijerg([[1],[0.25]],[[3],[0.5]],-2,series=2))
-0.06417628097442437076207337
\end{lstlisting}







\newpage
\section{Bilateral hypergeometric series}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{bihyper? mpNum? the  bilateral hypergeometric series}
	{as? mpNum? list of real or complex numbers.}
	{bs? mpNum? list of real or complex numbers.}
	{z? mpNum? A real or complex number.}
	{Keywords? String?  r=1, series=1.}			
\end{mpFunctionsExtract}

\vpara
Evaluates the bilateral hypergeometric series

\begin{equation}
{}_AH_B(a_1;\ldots,a_A;b_1,\ldots,b_B) = \sum_{n=-\infty}^{\infty} \frac{(a_1)_n \ldots (a_A)_n}{(b_1)_n \ldots (b_B)_n} z^n
\end{equation}

where, for direct convergence, $A=B$ and $|z|=1$, although a regularized sum exists
more generally by considering the bilateral series as a sum of two ordinary hypergeometric functions. In order for the series to make sense, none of the parameters may be integers.

Examples

The value of ${}_2H_2$ at $z=1$ is given by Dougall's formula:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> a,b,c,d = 0.5, 1.5, 2.25, 3.25
>>> bihyper([a,b],[c,d],1)
-14.49118026212345786148847
>>> gammaprod([c,d,1-a,1-b,c+d-a-b-1],[c-a,d-a,c-b,d-b])
-14.49118026212345786148847
\end{lstlisting}

The regularized function ${}_1H_0$ can be expressed as the sum of one ${}_2F_0$ function and one ${}_1F_1$ function:


\lstset{language={Python}}
\begin{lstlisting}
>>> a = mpf(0.25)
>>> z = mpf(0.75)
>>> bihyper([a], [], z)
(0.2454393389657273841385582 + 0.2454393389657273841385582j)
>>> hyper([a,1],[],z) + (hyper([1],[1-a],-1/z)-1)
(0.2454393389657273841385582 + 0.2454393389657273841385582j)
>>> hyper([a,1],[],z) + hyper([1],[2-a],-1/z)/z/(a-1)
(0.2454393389657273841385582 + 0.2454393389657273841385582j)
\end{lstlisting}



\newpage
\section{Hypergeometric functions of two variables}

\subsection{Generalized 2D hypergeometric series}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{hyper2d? mpNum? the sum the generalized 2D hypergeometric series}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}	
	{x? mpNum? A real or complex number.}		
	{y? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The sum of the generalized 2D hypergeometric series is calculated as

\begin{equation}
\sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{P((a),m,n)}{Q((b))} \frac{x^my^n}{m!,n!}
\end{equation}

where $(a)=(a_1,\ldots,a_r)$, $(b)=(b_1,\ldots,b_r)$ and where $P$ and $Q$ are products of rising factorials such as $(a_j)_n$ or $(a_j)_{m+n}$. $P$ and $Q$ are specified in the form of dicts, with the $m$ and $n$ dependence as keys and parameter lists as values. The supported rising factorials are given in the following table (note that only a few are supported in $Q$):



\begin{table}[ht]
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Key & Rising factorial & $Q$\\
		\hline
		"m" & $(a_j)_m$ &  Yes \\
		"n" & $(a_j)_n$ &  Yes \\
		"m+n" & $(a_j)_{m+n}$ &  Yes \\				
		"m-n" & $(a_j)_{m-n}$ &  No \\
		"n-m" & $(a_j)_{n-m}$ &  No \\
		"2m+n" & $(a_j)_{2m+n}$ &  No \\				
		"2m-n" & $(a_j)_{2m-n}$ &  No \\
		"2n-m" & $(a_j)_{2n-m}$ &  No \\
		\hline
	\end{tabular}
	%	\caption{\result}
	%	\label{\result} 
\end{table}

For example, the Appell F1 and F4 functions

\begin{equation}
F_1 = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{(a)_{m+n}(b)_m (c)_n}{(d)_{m+n}} \frac{x^my^n}{m!,n!}
\end{equation}

\begin{equation}
F_4 = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{(a)_{m+n}(b)_{m+n} }{(d)_{m+n}} \frac{x^my^n}{m!,n!}
\end{equation}


can be represented respectively as


\lstset{language={Python}}
\begin{lstlisting}
hyper2d({'m+n':[a], 'm':[b], 'n':[c]}, {'m+n':[d]}, x, y)

hyper2d({'m+n':[a,b]}, {'m':[c], 'n':[d]}, x, y)
\end{lstlisting}



More generally, hyper2d() can evaluate any of the 34 distinct convergent secondorder (generalized Gaussian) hypergeometric series enumerated by Horn, as well as the Kampe de Feriet function.

The series is computed by rewriting it so that the inner series (i.e. the series containing $n$ and $y$) has the form of an ordinary generalized hypergeometric series and thereby can be evaluated efficiently using hyper(). If possible, manually swapping $x$ and $y$
and the corresponding parameters can sometimes give better results.

Examples

Two separable cases: a product of two geometric series, and a product of two Gaussian hypergeometric functions:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> x, y = mpf(0.25), mpf(0.5)
>>> hyper2d({'m':1,'n':1}, {}, x,y)
2.666666666666666666666667
>>> 1/(1-x)/(1-y)
2.666666666666666666666667
>>> hyper2d({'m':[1,2],'n':[3,4]}, {'m':[5],'n':[6]}, x,y)
4.164358531238938319669856
>>> hyp2f1(1,2,5,x)*hyp2f1(3,4,6,y)
4.164358531238938319669856
\end{lstlisting}




\subsection{Appell F1 hypergeometric function}

\begin{mpFunctionsExtract}
	\mpFunctionSix
	{appellf1? mpNum? the Appell F1 hypergeometric function of two variables.}
	{a? mpNum? A real or complex number.}
	{b1? mpNum? A real or complex number.}	
	{b2? mpNum? A real or complex number.}
	{c? mpNum? A real or complex number.}	
	{x? mpNum? A real or complex number.}		
	{y? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
Gives the Appell F1 hypergeometric function of two variables,

\begin{equation}
F_1(a_1,b_1,b_2,c,x,y) = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{(a)_{m+n}(b_1)_m (b_2)_n}{(c)_{m+n}} \frac{x^my^n}{m!,n!}
\end{equation}


This series is only generally convergent when $|x|<1$ and $|y|<1$, although appellf1() can evaluate an analytic continuation with respect to either variable, and sometimes both.

Examples

Evaluation is supported for real and complex parameters:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> appellf1(1,0,0.5,1,0.5,0.25)
1.154700538379251529018298
>>> appellf1(1,1+j,0.5,1,0.5,0.5j)
(1.138403860350148085179415 + 1.510544741058517621110615j)
\end{lstlisting}



\subsection{Appell F2 hypergeometric function}

\begin{mpFunctionsExtract}
	\mpFunctionSeven
	{appellf2? mpNum? the Appell F2 hypergeometric function of two variables.}
	{a? mpNum? A real or complex number.}
	{b1? mpNum? A real or complex number.}	
	{b2? mpNum? A real or complex number.}
	{c1? mpNum? A real or complex number.}
	{c2? mpNum? A real or complex number.}		
	{x? mpNum? A real or complex number.}		
	{y? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
Gives the Appell F2 hypergeometric function of two variables

\begin{equation}
F_2(a_1,b_1,b_2,c_1,c_2,x,y) = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{(a)_{m+n}(b_1)_m (b_2)_n}{(c_1)_{m}(c_2)_{n}} \frac{x^my^n}{m!,n!}
\end{equation}


The series is generally absolutely convergent for $|x|+|y|<1$.

Examples

Evaluation is supported for real and complex parameters:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> appellf2(1,2,3,4,5,0.25,0.125)
1.257417193533135344785602
>>> appellf2(1,-3,-4,2,3,2,3)
-42.8
>>> appellf2(0.5,0.25,-0.25,2,3,0.25j,0.25)
(0.9880539519421899867041719 + 0.01497616165031102661476978j)
>>> chop(appellf2(1,1+j,1-j,3j,-3j,0.25,0.25))
1.201311219287411337955192
>>> appellf2(1,1,1,4,6,0.125,16)
(-0.09455532250274744282125152 - 0.7647282253046207836769297j)
\end{lstlisting}




\subsection{Appell F3 hypergeometric function}

\begin{mpFunctionsExtract}
	\mpFunctionSeven
	{appellf3? mpNum? the Appell F3 hypergeometric function of two variables.}
	{a1? mpNum? A real or complex number.}
	{a2? mpNum? A real or complex number.}
	{b1? mpNum? A real or complex number.}	
	{b2? mpNum? A real or complex number.}
	{c? mpNum? A real or complex number.}		
	{x? mpNum? A real or complex number.}		
	{y? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
Gives the Appell F3 hypergeometric function of two variables

\begin{equation}
F_3(a_1,a_2,b_1,b_2,c,x,y) = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{(a_1)_{m}(a_2)_{n}(b_1)_m (b_2)_n}{(c)_{m+n}} \frac{x^my^n}{m!,n!}
\end{equation}


The series is generally absolutely convergent for $|x|<1, |y|<1$.

Examples

Evaluation for various parameters and variables:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> appellf3(1,2,3,4,5,0.5,0.25)
2.221557778107438938158705
>>> appellf3(1,2,3,4,5,6,0); hyp2f1(1,3,5,6)
(-0.5189554589089861284537389 - 0.1454441043328607980769742j)
(-0.5189554589089861284537389 - 0.1454441043328607980769742j)
>>> appellf3(1,-2,-3,1,1,4,6)
-17.4
>>> appellf3(1,2,-3,1,1,4,6)
(17.7876136773677356641825 + 19.54768762233649126154534j)
>>> appellf3(1,2,-3,1,1,6,4)
(85.02054175067929402953645 + 148.4402528821177305173599j)
>>> chop(appellf3(1+j,2,1-j,2,3,0.25,0.25))
1.719992169545200286696007
\end{lstlisting}




\subsection{Appell F4 hypergeometric function}

\begin{mpFunctionsExtract}
	\mpFunctionSix
	{appellf4? mpNum? the Appell F4 hypergeometric function of two variables.}
	{a? mpNum? A real or complex number.}
	{b? mpNum? A real or complex number.}	
	{c1? mpNum? A real or complex number.}
	{c2? mpNum? A real or complex number.}	
	{x? mpNum? A real or complex number.}		
	{y? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
Gives the Appell F4 hypergeometric function of two variables

\begin{equation}
F_4(a,b,c_1,c_2,x,y) = \sum_{m=0}^{\infty} \sum_{n=0}^{\infty} \frac{(a)_{m+n}(a_2)_{n}(b)_{m+n}}{(c_1)_m (c_2)_n} \frac{x^my^n}{m!,n!}
\end{equation} 


The series is generally absolutely convergent for $\sqrt{|x|} + \sqrt{|y|}  <1$.

Examples

Evaluation for various parameters and variables:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> appellf4(1,1,2,2,0.25,0.125)
1.286182069079718313546608
>>> appellf4(-2,-3,4,5,4,5)
34.8
>>> appellf4(5,4,2,3,0.25j,-0.125j)
(-0.2585967215437846642163352 + 2.436102233553582711818743j)
\end{lstlisting}





\newpage
\chapter{Elliptic functions}
Elliptic functions historically comprise the elliptic integrals and their inverses, and originate from the problem of computing the arc length of an ellipse. From a more modern point of view, an elliptic function is defined as a doubly periodic function, i.e. a function which
satisfies

\begin{equation}
f(z+2\omega_1) = f(z+2\omega_2) = f(z)
\end{equation}

for some half-periods $\omega1, \omega_2$ with $\Im[\omega_1/\omega_2]>0$. The canonical elliptic functions are the Jacobi elliptic functions. More broadly, this section includes quasi-doubly periodic functions (such as the Jacobi theta functions) and other functions useful in the study of elliptic functions.

\vpara
Many different conventions for the arguments of elliptic functions are in use. It is even standard to use different parametrizations for different functions in the same text or software (and mpFormulaPy is no exception). The usual parameters are the elliptic nome $q$, which
usually must satisfy $|q|<1$; the elliptic parameter $m$ (an arbitrary complex number); the elliptic modulus $k$ (an arbitrary complex number); and the half-period ratio $\tau$, which usually must satisfy $\Im[\tau]>0$. These quantities can be expressed in terms of each other using the following relations:

\begin{equation}
m=k^2; \quad \tau=i \frac{K(1-m)}{K(m)}; \quad q=e^{i \pi \tau}; \quad k=\frac{\vartheta_2^4(q)}{\vartheta_2^4(q)}
\end{equation}

In addition, an alternative definition is used for the nome in number theory, which we here denote by q-bar:

\begin{equation}
\overline{q} = q^2 = e^{2 i \pi \tau}
\end{equation}

%\newpage
\section{Elliptic arguments}

For convenience, mpFormulaPy provides functions to convert between the various parameters (qfrom(), mfrom(), kfrom(), taufrom(), qbarfrom()).


\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{qfrom? mpNum? the elliptic nome $q$.}
	{Keywords? String? m=x; k=x; tau=x; qbar=x.}
\end{mpFunctionsExtract}

\vpara
Returns the elliptic nome $q$, given any of $m, k, \tau, \overline{q}$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> qfrom(q=0.25)
0.25
>>> qfrom(m=mfrom(q=0.25))
0.25
>>> qfrom(k=kfrom(q=0.25))
0.25
>>> qfrom(tau=taufrom(q=0.25))
(0.25 + 0.0j)
>>> qfrom(qbar=qbarfrom(q=0.25))
0.25
\end{lstlisting}


\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{qbarfrom? mpNum? the number-theoretic nome $\overline{q}$.}
	{Keywords? String? m=x; k=x; tau=x; q=x.}
\end{mpFunctionsExtract}

\vpara
Returns the number-theoretic nome $\overline{q}$, given any of $q, m, k, \tau$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> qbarfrom(qbar=0.25)
0.25
>>> qbarfrom(q=qfrom(qbar=0.25))
0.25
>>> qbarfrom(m=extraprec(20)(mfrom)(qbar=0.25)) # ill-conditioned
0.25
>>> qbarfrom(k=extraprec(20)(kfrom)(qbar=0.25)) # ill-conditioned
0.25
>>> qbarfrom(tau=taufrom(qbar=0.25))
(0.25 + 0.0j)
\end{lstlisting}



\vspace{0.6cm}

%\newpage
\begin{mpFunctionsExtract}
	\mpFunctionOne
	{mfrom? mpNum? the elliptic parameter $m$.}
	{Keywords? String? k=x; tau=x; q=x; qbar=x.}
\end{mpFunctionsExtract}

\vpara
Returns the elliptic parameter $m$, given any of $q, k, \tau, \overline{q}$::

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> mfrom(m=0.25)
0.25
>>> mfrom(q=qfrom(m=0.25))
0.25
>>> mfrom(k=kfrom(m=0.25))
0.25
>>> mfrom(tau=taufrom(m=0.25))
(0.25 + 0.0j)
>>> mfrom(qbar=qbarfrom(m=0.25))
0.25
\end{lstlisting}



\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{kfrom? mpNum? the elliptic modulus $k$.}
	{Keywords? String? m=x; tau=x; q=x; qbar=x.}
\end{mpFunctionsExtract}

\vpara
Returns the elliptic modulus $k$, given any of $q, m, \tau, \overline{q}$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> kfrom(k=0.25)
0.25
>>> kfrom(m=mfrom(k=0.25))
0.25
>>> kfrom(q=qfrom(k=0.25))
0.25
>>> kfrom(tau=taufrom(k=0.25))
(0.25 + 0.0j)
>>> kfrom(qbar=qbarfrom(k=0.25))
0.25
\end{lstlisting}



\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{taufrom? mpNum? the elliptic half-period ratio $\tau$.}
	{Keywords? String? m=x; k=x; q=x; qbar=x.}
\end{mpFunctionsExtract}

\vpara
Returns the elliptic half-period ratio $\tau$, given any of $q, m, k, \overline{q}$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> taufrom(tau=0.5j)
(0.0 + 0.5j)
>>> taufrom(q=qfrom(tau=0.5j))
(0.0 + 0.5j)
>>> taufrom(m=mfrom(tau=0.5j))
(0.0 + 0.5j)
>>> taufrom(k=kfrom(tau=0.5j))
(0.0 + 0.5j)
>>> taufrom(qbar=qbarfrom(tau=0.5j))
(0.0 + 0.5j)
\end{lstlisting}


\newpage
\section{Legendre elliptic integrals}

%\subsection{Complete elliptic integral of the 1st kind}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CompleteLegendreEllint1MpMath? mpNum? the value of the complete elliptic integral of the first kind.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the complete elliptic integral of the first kind
%$K(k)$ with $|k| < 1$
%\begin{equation}
%K(k)=\int_0^{\pi/2} \frac{dt}{\sqrt{1-k^2 \sin^2 t}}.
%\end{equation}
%
%
%
%\subsection{Complete elliptic integral of the 2nd kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CompleteLegendreEllint2MpMath? mpNum? the value of the complete elliptic integral of the second kind.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the complete elliptic integral of the second kind
%$E(k)$ with $|k| \leq 1$
%\begin{equation}
%E(k)=\int_0^{\pi/2} \sqrt{1-k^2 \sin^2 t}.
%\end{equation}
%
%
%
%
%
%\subsection{Complete elliptic integral of the 3rd kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{CompleteLegendreEllint3MpMath? the value of the complete elliptic integral of the third kind.}
%	{$\nu$? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the complete elliptic integral of the third kind
%$\Pi(\nu,k)$ with $|k| < , \nu \neq 1$
%\begin{equation}
%\Pi(\nu,k)=\int_0^{\pi/2} \frac{dt}{(1-\nu \sin^2 t)\sqrt{1-k^2 \sin^2 t}}.
%\end{equation}
%
%
%
%
%\subsection{Legendre elliptic integral of the 1st kind}
%
%\label{Legendre elliptic integral of the 1st kind MpMath}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{LegendreEllint1MpMath? mpNum? the value of the incomplete Legendre elliptic integral of the first kind.}
%	{$\phi$? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the incomplete Legendre elliptic integral of the first kind
%\begin{equation}
%F(\phi, k)=\int_0^{\phi} \frac{dt}{\sqrt{1-k^2 \sin^2 t}}.
%\end{equation}
%with $|k \sin \phi| \leq 1$.
%
%
%
%
%\subsection{Legendre elliptic integral of the 2nd kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{LegendreEllint2MpMath? mpNum? the value of the incomplete Legendre elliptic integral of the second kind.}
%	{$\phi$? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the incomplete Legendre elliptic integral of the second kind 
%\begin{equation}
%E(\phi, k)=\int_0^{\phi} \sqrt{1-k^2 \sin^2 t}.
%\end{equation}
%with $|k \sin \phi| \leq 1$.
%
%
%
%
%\subsection{Legendre elliptic integral of the 3rd kind}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{LegendreEllint3MpMath? mpNum? the value of the incomplete Legendre elliptic integral of the third kind.}
%	{$\phi$? mpNum? A real number.}
%	{$\nu$? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the incomplete Legendre elliptic integral of the third kind
%\begin{equation}
%\Pi(\phi, \nu,k)=\int_0^{\phi} \frac{dt}{(1-\nu \sin^2 t)\sqrt{1-k^2 \sin^2 t}}.
%\end{equation}
%with $|k \sin \phi| \leq 1$.
%
%
%
%
%\subsection{Heumann's Lambda Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{HeumannLambdaMpMath? mpNum? the value of  Heuman’s Lambda function for $|k| \leq 1$.}
%	{$\phi$? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of  Heuman’s Lambda function for $|k| \leq 1$ (cf. Abramowitz and Stegun [30, 17.4.39/17.4.40], where a slightly different notation is used)
%\begin{equation}
%\Lambda_0(\phi,k)=\frac{F(\phi,k'}{K(k')} + \frac{2}{\pi} K(k) Z(\phi,k').
%\end{equation}
%
%
%
%
%\subsection{Jacobi Zeta Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiZetaMpMath? mpNum? the value of  the Jacobi Zeta function for $|k|\leq 1$.}
%	{$\phi$? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of  the Jacobi Zeta function for $|k|\leq 1$
%\begin{equation}
%Z(\phi,k) = E(\phi,k) - \frac{E(k)}{K(k)} F(\phi,k).
%\end{equation}
%
%
%
%\subsection{Elliptic Modulus}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{EllipticModulusMpMath? mpNum? the value of  the elliptic modulus $k(q)$ as a function of the nome $|q| \leq 1$.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of  the elliptic modulus $k(q)$ as a function of the nome $|q| \leq 1$. The modulus $k$ is often used as argument of elliptic integrals and Jacobi elliptic functions, the nome $q$ is used with Jacobi theta functions. $k(q)$ is explicitly given by
%\begin{equation}
%k(q) = \frac{\theta_2(q)^2}{\theta_3(q)^2}
%\end{equation}
%
%
%\subsection{Elliptic Nome}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{EllipticNomeMpMath? mpNum? the value of  the elliptic modulus $k(q)$ as a function of the nome $|q| \leq 1$.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the elliptic nome $q(k)$ as a function of the modulus $|k| < 1$:
%\begin{equation}
%q(k)=\exp \left(-\pi \frac{K'(k)}{K(k)} \right)
%\end{equation}
%
%
%\subsection{Jacobi Amplitude}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiAmplitudeMpMath? mpNum? the value of the Jacobi amplitude function $\text{am}(x, k)$.}
%	{$\phi$? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Jacobi amplitude function $\text{am}(x, k)$ for a given modulus $k$ is the inverse function of Legendre's elliptic function of the first kind: $\text{am}(F(x, k), k) = x$. When $|k| < 1$, $\text{am}(x, k)$ is a monotone quasi-periodic function [30, 22.16.2] 
%
%\begin{center}
%	$\text{am}(x + 2K(k), k) = \text{am}(x, k) + \pi,	$
%\end{center}
%
%with the special case $\text{am}(x, 0) = x$. When $|k| > 1$, $\text{am}(x, k)$ is periodic with period $4K(1/k)/k$, and if $|k| = 1$, then it is equal to the Gudermannian function $\text{am}(x, \pm 1) = gd(x)$.
%
%





\subsection{Complete elliptic integral of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{ellipk? mpNum? the complete elliptic integral of the first kind, $K(m)$.}
	{m? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


\vpara
The complete elliptic integral of the first kind, $K(m)$ is defined by

\begin{equation}
K(m)=\int_0^{\pi/2} \frac{dt}{\sqrt{1-m \sin^2 t}} = \frac{\pi}{2} {}_2F_1 \left(\tfrac{1}{2},\tfrac{1}{2},1,m \right)
\end{equation}

Note that the argument is the parameter $m=k^2$, not the modulus $k$ which is sometimes used.

Values and limits include:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> ellipk(0)
1.570796326794896619231322
>>> ellipk(inf)
(0.0 + 0.0j)
>>> ellipk(-inf)
0.0
>>> ellipk(1)
+inf
>>> ellipk(-1)
1.31102877714605990523242
>>> ellipk(2)
(1.31102877714605990523242 - 1.31102877714605990523242j)
\end{lstlisting}

Evaluation is supported for arbitrary complex $m$:

\lstset{language={Python}}
\begin{lstlisting}
>>> ellipk(3+4j)
(0.9111955638049650086562171 + 0.6313342832413452438845091j)
\end{lstlisting}




\subsection{Incomplete elliptic integral of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{ellipf? mpNum? the Legendre incomplete elliptic integral of the first kind $F(\phi,m)$.}
	{phi? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


\vpara
The Legendre incomplete elliptic integral of the first kind is defined as

\begin{equation}
F(\phi,m)=\int_0^{\phi} \frac{dt}{\sqrt{1-m \sin^2 t}} 
\end{equation}

or equivalently

\begin{equation}
F(\phi,m)=\int_0^{\sin \phi} \frac{dt}{\sqrt{1-t^2}\sqrt{1-mt^2}} 
\end{equation}


The function reduces to a complete elliptic integral of the first kind (see ellipk()) when $\phi=\pi/2$; that is, $F(\pi/2) = K(m)$.

In the defining integral, it is assumed that the principal branch of the square root is taken and that the path of integration avoids crossing any branch cuts. Outside $-\pi/2 \leq \Re(\phi) \leq \pi/2$, the function extends quasi-periodically as

\begin{equation}
F(\phi+n\pi,m) = 2nK(m) + F(\phi,m), n \in \mathbb{Z}.
\end{equation}

Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> ellipf(0,1)
0.0
>>> ellipf(0,0)
0.0
>>> ellipf(1,0); ellipf(2+3j,0)
1.0
(2.0 + 3.0j)
>>> ellipf(1,1); log(sec(1)+tan(1))
1.226191170883517070813061
1.226191170883517070813061
>>> ellipf(pi/2, -0.5); ellipk(-0.5)
1.415737208425956198892166
1.415737208425956198892166
>>> ellipf(pi/2+eps, 1); ellipf(-pi/2-eps, 1)
+inf
+inf
>>> ellipf(1.5, 1)
3.340677542798311003320813
\end{lstlisting}

Evaluation is supported for arbitrary complex $m$:

\lstset{language={Python}}
\begin{lstlisting}
>>> ellipf(3j, 0.5)
(0.0 + 1.713602407841590234804143j)
>>> ellipf(3+4j, 5-6j)
(1.269131241950351323305741 - 0.3561052815014558335412538j)
>>> z,m = 2+3j, 1.25
>>> k = 1011
>>> ellipf(z+pi*k,m); ellipf(z,m) + 2*k*ellipk(m)
(4086.184383622179764082821 - 3003.003538923749396546871j)
(4086.184383622179764082821 - 3003.003538923749396546871j)
\end{lstlisting}


\newpage
\subsection{Complete elliptic integral of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{ellipe? mpNum? the Legendre complete elliptic integral of the second kind $E(m)$.}
	{m? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


%!!! NOTE: CHANGE FROM mpmath syntax !!!!!

\vpara
The Legendre complete elliptic integral of the second kind is defined by

\begin{equation}
E(m)=\int_0^{\pi/2} \frac{dt}{\sqrt{1-m \sin^2 t}} = \frac{\pi}{2} {}_2F_1 \left(\tfrac{1}{2},-\tfrac{1}{2},1,m \right)
\end{equation}


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> ellipe(0)
1.570796326794896619231322
>>> ellipe(1)
1.0
>>> ellipe(-1)
1.910098894513856008952381
>>> ellipe(2)
(0.5990701173677961037199612 + 0.5990701173677961037199612j)
>>> ellipe(inf)
(0.0 + +infj)
>>> ellipe(-inf)
+inf
\end{lstlisting}

Evaluation is supported for arbitrary complex $m$:

\lstset{language={Python}}
\begin{lstlisting}
>>> ellipe(0.5+0.25j)
(1.360868682163129682716687 - 0.1238733442561786843557315j)
>>> ellipe(3+4j)
(1.499553520933346954333612 - 1.577879007912758274533309j)
\end{lstlisting}



\subsection{Incomplete elliptic integral of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{ellipef? mpNum? the Legendre incomplete elliptic integral of the second kind $E(\phi,m)$.}
	{phi? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The incomplete elliptic integral of the second kind

\begin{equation}
E(\phi,m)=\int_0^{\phi} \frac{dt}{\sqrt{1-m \sin^2 t}} =\int_0^{\sin \phi} \frac{\sqrt{1-mt^2}}{\sqrt{1-t^2}} dt
\end{equation}

The incomplete integral reduces to a complete integral when $\phi=\pi/2$; that is, $E(\pi/2,m) = E(m)$.

In the defining integral, it is assumed that the principal branch of the square root is taken and that the path of integration avoids crossing any branch cuts. Outside $-\pi/2 \leq \Re(\phi) \leq \pi/2$, the function extends quasi-periodically as

\begin{equation}
E(\phi+n\pi,m) = 2nE(m) + F(\phi,m), n \in \mathbb{Z}.
\end{equation}


Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> ellipe(0,1)
0.0
>>> ellipe(0,0)
0.0
>>> ellipe(1,0)
1.0
>>> ellipe(2+3j,0)
(2.0 + 3.0j)
>>> ellipe(1,1); sin(1)
0.8414709848078965066525023
0.8414709848078965066525023
>>> ellipe(pi/2, -0.5); ellipe(-0.5)
1.751771275694817862026502
1.751771275694817862026502
>>> ellipe(pi/2, 1); ellipe(-pi/2, 1)
1.0
-1.0
>>> ellipe(1.5, 1)
0.9974949866040544309417234
\end{lstlisting}

Evaluation is supported for arbitrary complex $m$:

\lstset{language={Python}}
\begin{lstlisting}
>>> ellipe(0.5+0.25j)
>>> ellipe(3j, 0.5)
(0.0 + 7.551991234890371873502105j)
>>> ellipe(3+4j, 5-6j)
(24.15299022574220502424466 + 75.2503670480325997418156j)
>>> k = 35
>>> z,m = 2+3j, 1.25
>>> ellipe(z+pi*k,m); ellipe(z,m) + 2*k*ellipe(m)
(48.30138799412005235090766 + 17.47255216721987688224357j)
(48.30138799412005235090766 + 17.47255216721987688224357j)
\end{lstlisting}




\subsection{Complete elliptic integral of the third kind}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{ellippi? mpNum? the complete elliptic integral of the third kind $\Pi(n,m$.}
	{n? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


The complete elliptic integral of the third kind is defined as

$\Pi(n,m)=\Pi(n; \pi/2, m)$.


Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> ellippi(0,-5); ellipk(-5)
0.9555039270640439337379334
0.9555039270640439337379334
>>> ellippi(inf,2)
0.0
>>> ellippi(2,inf)
0.0
>>> abs(ellippi(1,5))
+inf
>>> abs(ellippi(0.25,1))
+inf
\end{lstlisting}





\subsection{Incomplete elliptic integral of the third kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{ellippif? mpNum? the Legendre incomplete elliptic integral of the third kind $\Pi(n;\phi,m)$.}
	{n? mpNum? A real or complex number.}	
	{phi? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


The Legendre incomplete elliptic integral of the third kind is defined as

\begin{equation}
\Pi(n;\phi,m)=\int_0^{\phi} \frac{dt}{(1-n \sin^2 t)\sqrt{1-m \sin^2 t}} = \int_0^{\sin \phi} \frac{dt}{(1-nt^2)\sqrt{1-t^2}\sqrt{1-mt^2}}
\end{equation}

\vpara
In the defining integral, it is assumed that the principal branch of the square root is taken and that the path of integration avoids crossing any branch cuts. Outside $-\pi/2 \leq \Re(\phi) \leq \pi/2$, the function extends quasi-periodically as

\begin{equation}
\Pi(n, \phi+k\pi,m) = 2k\Pi(n,m) + \Pi(n,\phi,m), k \in \mathbb{Z}.
\end{equation}


Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> ellippi(0.25,-0.5); ellippi(0.25,pi/2,-0.5)
1.622944760954741603710555
1.622944760954741603710555
>>> ellippi(1,0,1)
0.0
>>> ellippi(inf,0,1)
0.0
>>> ellippi(0,0.25,0.5); ellipf(0.25,0.5)
0.2513040086544925794134591
0.2513040086544925794134591
>>> ellippi(1,1,1); (log(sec(1)+tan(1))+sec(1)*tan(1))/2
2.054332933256248668692452
2.054332933256248668692452
>>> ellippi(0.25, 53*pi/2, 0.75); 53*ellippi(0.25,0.75)
135.240868757890840755058
135.240868757890840755058
>>> ellippi(0.5,pi/4,0.5); 2*ellipe(pi/4,0.5)-1/sqrt(3)
0.9190227391656969903987269
0.9190227391656969903987269
\end{lstlisting}

Complex arguments are supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> ellippi(0.5, 5+6j-2*pi, -7-8j)
(-0.3612856620076747660410167 + 0.5217735339984807829755815j)
\end{lstlisting}





\newpage
\section{Carlson symmetric elliptic integrals}


The Carlson style elliptic integrals are a complete alternative group to the classical
Legendre style integrals. They are symmetric and the numerical calculation is usually
performed by duplication as described in  \cite{Carlson_1994} and  \cite{Carlson_1995}.
%
%\subsection{Degenerate elliptic integral RC}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{CarlsonRCMpMath? mpNum? the value of the of Carlson's degenerate elliptic integral $R_C$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the of Carlson's degenerate elliptic integral $R_C$ for $x \geq 0$, $y \neq 0$:
%\begin{equation}
%R_C(x,y)=R_F(x,y,y)=\frac{1}{2} \int_0^\infty (t+x)^{-1/2} (t+y)^{-1} dt.
%\end{equation}
%
%
%\subsection{Integral of the 1st kind RF}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{CarlsonRFMpMath? mpNum? the value of the of Carlson's elliptic integral $R_F$ of the first kind.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%	{z? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the of Carlson's elliptic integral $R_F$ of the first kind
%\begin{equation}
%R_F(x,y,z)=\frac{1}{2} \int_0^\infty ((t+x)(t+y)(t+z))^{-1/2}  dt.
%\end{equation}
%with $x, y, z \geq 0$, at most one may be zero. 
%
%
%\subsection{Integral of the 2nd kind RD}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{CarlsonRDMpMath? mpNum? the value of the of Carlson's elliptic integral $R_D$ of the second kind.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%	{z? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the of Carlson's elliptic integral $R_D$ of the second kind
%\begin{equation}
%R_D(x,y,z) = R_J(x,y,z,z)  =\frac{3}{2} \int_0^\infty ((t+x)(t+y))^{-1/2} (t+z)^{-3/2}  dt.
%\end{equation}
%with $z>0$, $x, y \geq 0$, at most one of $x,y$ may be zero. 
%
%
%
%\subsection{Integral of the 3rd kind RJ}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionFour
%	{CarlsonRJMpMath? mpNum? the value of the of Carlson's elliptic integral $R_J$ of the third kind.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%	{z? mpNum? A real number.}
%	{r? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the of Carlson's elliptic integral $R_J$ of the third kind
%\begin{equation}
%R_J(x,y,z,r)  =\frac{3}{2} \int_0^\infty ((t+x)(t+y)(t+z))^{-1/2} (t+r)^{-1}  dt.
%\end{equation}
%with  $x, y, z \geq 0$, at most one of may be zero, and $r \neq 0$. 



\subsection{Symmetric elliptic integral of the first kind, RF}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{elliprf? mpNum? the Carlson symmetric elliptic integral of the first kind.}
	{x? mpNum? A real or complex number.}	
	{y? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


\vpara
The Carlson symmetric elliptic integral of the first kind is given by

\begin{equation}
R_F(x,y,z)=\frac{1}{2} \int_0^{\infty} \frac{dt}{\sqrt{(t+x)(t+y)(t+z)}}
\end{equation}

which is defined for $x,y,z \in (-\infty, 0)$, and with at most one of $x,y,z$ being zero.

For real $x,y,z \geq 0$, the principal square root is taken in the integrand. For complex $x,y,z$, the principal square root is taken as $t \rightarrow \infty$ and as $t \rightarrow 0$ non-principal branches are chosen as necessary so as to make the integrand continuous.

Basic values and limits:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> elliprf(0,1,1); pi/2
1.570796326794896619231322
1.570796326794896619231322
>>> elliprf(0,1,inf)
0.0
>>> elliprf(1,1,1)
1.0
>>> elliprf(2,2,2)**2
0.5
>>> elliprf(1,0,0); elliprf(0,0,1); elliprf(0,1,0); elliprf(0,0,0)
+inf
+inf
+inf
+inf
\end{lstlisting}

With the following arguments, the square root in the integrand becomes discontinuous at $t=1/2$ if the principal branch is used. To obtain the right value, $-\sqrt{r}$ must be taken instead of $\sqrt{r}$ on $t \in (0, 1/2)$:

\lstset{language={Python}}
\begin{lstlisting}
>>> x,y,z = j-1,j,0
>>> elliprf(x,y,z)
(0.7961258658423391329305694 - 1.213856669836495986430094j)
>>> -q(f, [0,0.5]) + q(f, [0.5,inf])
(0.7961258658423391329305694 - 1.213856669836495986430094j)
\end{lstlisting}



\subsection{Degenerate Carlson symmetric elliptic integral of the first kind, RC}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{elliprc? mpNum? the degenerate Carlson symmetric elliptic integral of the first kind.}
	{x? mpNum? A real or complex number.}	
	{y? mpNum? A real or complex number.}
	{Keywords? String? pv=True.}	
\end{mpFunctionsExtract}

\vpara
The degenerate Carlson symmetric elliptic integral of the first kind is given by

\begin{equation}
R_C(x,y) = R_F(x,y,y)=\frac{1}{2} \int_0^{\infty} \frac{dt}{(t+y)\sqrt{(t+x)}}
\end{equation}

If $y \in (-\infty, 0)$, either a value defined by continuity, or with pv=True the Cauchy principal value, can be computed.

If $x \geq 0, y > 0$, the value can be expressed in terms of elementary functions as

\begin{equation}
  R_C(x,y)=\begin{cases}
    \frac{1}{\sqrt{y-x}} \cos^{-1}\left(\sqrt{x/y}\right), & x<y \\
    \frac{1}{\sqrt{y}}, & x=y \\
		\frac{1}{\sqrt{y-x}} \cosh^{-1}\left(\sqrt{x/y}\right), & x>y 
  \end{cases}
\end{equation}


Examples

Some special values and limits:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> elliprc(1,2)*4; elliprc(0,1)*2; +pi
3.141592653589793238462643
3.141592653589793238462643
3.141592653589793238462643
>>> elliprc(1,0)
+inf
>>> elliprc(5,5)**2
0.2
>>> elliprc(1,inf); elliprc(inf,1); elliprc(inf,inf)
0.0
0.0
0.0
\end{lstlisting}

Comparing with numerical integration:

\lstset{language={Python}}
\begin{lstlisting}
>>> q = extradps(25)(quad)
>>> elliprc(2, -3, pv=True)
0.3333969101113672670749334
>>> elliprc(2, -3, pv=False)
(0.3333969101113672670749334 + 0.7024814731040726393156375j)
>>> 0.5*q(lambda t: 1/(sqrt(t+2)*(t-3)), [0,3-j,6,inf])
(0.3333969101113672670749334 + 0.7024814731040726393156375j)
\end{lstlisting}



\subsection{Symmetric elliptic integral of the third kind, RJ}

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{elliprj? mpNum? the Carlson symmetric elliptic integral of the third kind.}
	{x? mpNum? A real or complex number.}	
	{y? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}
	{p? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Carlson symmetric elliptic integral of the third kind is given by

\begin{equation}
R_J(x,y,z,p)=\frac{3}{2} \int_0^{\infty} \frac{dt}{(t+p)\sqrt{(t+x)(t+y)(t+z)}}
\end{equation}

Like elliprf(), the branch of the square root in the integrand is defined so as to be continuous along the path of integration for complex values of the arguments.

Examples

Some values and limits:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> elliprj(1,1,1,1)
1.0
>>> elliprj(2,2,2,2); 1/(2*sqrt(2))
0.3535533905932737622004222
0.3535533905932737622004222
>>> elliprj(0,1,2,2)
1.067937989667395702268688
>>> 3*(2*gamma('5/4')**2-pi**2/gamma('1/4')**2)/(sqrt(2*pi))
1.067937989667395702268688
>>> elliprj(0,1,1,2); 3*pi*(2-sqrt(2))/4
1.380226776765915172432054
1.380226776765915172432054
>>> elliprj(1,3,2,0); elliprj(0,1,1,0); elliprj(0,0,0,0)
+inf
+inf
+inf
>>> elliprj(1,inf,1,0); elliprj(1,1,1,inf)
0.0
0.0
>>> chop(elliprj(1+j, 1-j, 1, 1))
0.8505007163686739432927844
\end{lstlisting}

Comparing with numerical integration:

\lstset{language={Python}}
\begin{lstlisting}
>>> elliprj(1,2,3,4)
0.2398480997495677621758617
>>> f = lambda t: 1/((t+4)*sqrt((t+1)*(t+2)*(t+3)))
>>> 1.5*quad(f, [0,inf])
0.2398480997495677621758617
>>> elliprj(1,2+1j,3,4-2j)
(0.216888906014633498739952 + 0.04081912627366673332369512j)
>>> f = lambda t: 1/((t+4-2j)*sqrt((t+1)*(t+2+1j)*(t+3)))
>>> 1.5*quad(f, [0,inf])
(0.216888906014633498739952 + 0.04081912627366673332369511j)
\end{lstlisting}




\subsection{Symmetric elliptic integral of the second kind, RD}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{elliprd? mpNum? the Carlson symmetric elliptic integral of the second kind.}
	{x? mpNum? A real or complex number.}	
	{y? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}


\vpara
Evaluates the degenerate Carlson symmetric elliptic integral of the third kind or Carlson elliptic integral of the second kind $R_D(x,y,z) = R_j(x,y,z,z)$.

See elliprj() for additional information.



\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> elliprd(1,2,3)
0.2904602810289906442326534
>>> elliprj(1,2,3,3)
0.2904602810289906442326534
\end{lstlisting}



\subsection{Completely symmetric elliptic integral of the second kind, RG}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{elliprg? mpNum? the Carlson completely symmetric elliptic integral of the second kind.}
	{x? mpNum? A real or complex number.}	
	{y? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
The Carlson completely symmetric elliptic integral of the second kind is defined as

\begin{equation}
R_G(x,y,z) = \frac{1}{4} \int_0^{\infty} \frac{t}{\sqrt{(t+x)(t+y)(t+z)}} \left( \frac{x}{t+x} +  \frac{y}{t+y} +  \frac{z}{t+z}  \right) dt
\end{equation}

Evaluation for real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> elliprg(0,1,1)*4; +pi
3.141592653589793238462643
3.141592653589793238462643
>>> elliprg(0,0.5,1)
0.6753219405238377512600874
>>> chop(elliprg(1+j, 1-j, 2))
1.172431327676416604532822
\end{lstlisting}



\newpage
\section{Jacobi theta functions}

%
%\subsection{Jacobi Theta1(q)}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiTheta1MpMath? mpNum? the Jacobi theta function $\theta_1(x,q)$.}
%	{x? mpNum? A real number.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This routine returns the value of the Jacobi theta function $\theta_1(x,q)$, defined as
%\begin{equation}
%\theta_1(x,q) = 2q^{1/4} \sum_{k=0}^\infty (-1)^k q^{k(k+1)} \sin(2k+1) x
%\end{equation}
%
%
%
%\subsection{Jacobi Theta2(q)}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiTheta2MpMath? mpNum? the Jacobi theta function $\theta_2(x,q)$.}
%	{x? mpNum? A real number.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This routine returns the value of the Jacobi theta function $\theta_2(x,q)$, defined as
%\begin{equation}
%\theta_2(x,q) = 2q^{1/4} \sum_{k=0}^\infty q^{k(k+1)} \cos(2k+1) x
%\end{equation}
%
%
%
%\subsection{Jacobi Theta3(q)}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiTheta3MpMath? mpNum? the Jacobi theta function $\theta_3(x,q)$.}
%	{x? mpNum? A real number.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This routine returns the value of the Jacobi theta function $\theta_3(x,q)$, defined as
%\begin{equation}
%\theta_3(x,q) = 1 + 2\sum_{k=0}^\infty q^{k^2} \cos(2kx)
%\end{equation}
%
%
%
%\subsection{Jacobi Theta4(q)}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiTheta4MpMath? mpNum? the Jacobi theta function $\theta_4(x,q)$.}
%	{x? mpNum? A real number.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This routine returns the value of the Jacobi theta function $\theta_4(x,q)$, defined as
%\begin{equation}
%\theta_4(x,q) = 1 + 2\sum_{k=0}^\infty (-1)^k q^{k^2} \cos(2kx)
%\end{equation}
%
%



\begin{mpFunctionsExtract}
	\mpFunctionFour
	{jtheta? mpNum? the Jacobi theta function $\vartheta_n(z,q)$.}
	{n? mpNum? An integer, where $n=1,2,3,4$.}	
	{z? mpNum? A real or complex number.}
	{q? mpNum? A real or complex number.}
	{Keywords? String? derivative=0.}		
\end{mpFunctionsExtract}

\vpara
The Jacobi theta function $\vartheta_n(z,q)$, where $n=1,2,3,4$, is defined by the infinite series:

\begin{equation}
\vartheta_1(z,q) = 2q^{1/4} \sum_{n=0}^\infty (-1)^n q^{n(n+1)} \sin(2n+1) z
\end{equation}
\begin{equation}
\vartheta_2(z,q) = 2q^{1/4} \sum_{n=0}^\infty q^{n(n+1)} \cos(2n+1) z
\end{equation}
\begin{equation}
\vartheta_3(z,q) = 1 + 2\sum_{n=0}^\infty q^{n^2} \cos(2nz)
\end{equation}
\begin{equation}
\vartheta_4(z,q) = 1 + 2\sum_{n=0}^\infty (-1)^n q^{n^2} \cos(2nz)
\end{equation}


The theta functions are functions of two variables:

\vpara
$z$ is the argument, an arbitrary real or complex number

$q$ is the nome, which must be a real or complex number in the unit disk (i.e. $|q|<1$). For $|q|<< 1$, the series converge very quickly, so the Jacobi theta functions can efficiently be evaluated to high precision.

\vpara
The compact notations $\vartheta_n(q) = \vartheta_n(0,q)$ and $\vartheta_n = \vartheta_n(0,q)$ are also frequently encountered. Finally, Jacobi theta functions are frequently considered as functions of the half-period ratio $\tau$ and then usually denoted by $\vartheta_n(z|\tau)$.

\vpara
Optionally, jtheta(n, z, q, derivative=d) with $d>0$ computes a $d$-th derivative with respect to $z$.

Examples and basic properties

Considered as functions of , the Jacobi theta functions may be viewed as
generalizations of the ordinary trigonometric functions cos and sin. They are periodic functions:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> jtheta(1, 0.25, '0.2')
0.2945120798627300045053104
>>> jtheta(1, 0.25 + 2*pi, '0.2')
0.2945120798627300045053104
\end{lstlisting}

jtheta() supports arbitrary precision evaluation and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 50
>>> jtheta(4, sqrt(2), 0.5)
2.0549510717571539127004115835148878097035750653737
>>> mp.dps = 25
>>> jtheta(4, 1+2j, (1+j)/5)
(7.180331760146805926356634 - 1.634292858119162417301683j)
\end{lstlisting}


\newpage
\section{Jacobi elliptic functions}


These procedures return the Jacobi elliptic functions sn, cn, dn for argument $x$ and
complementary parameter $m_c$. A convenient implicit definition of the functions is
\begin{equation}
x = \int_0^{\text{sn}} \frac{dt}{\sqrt{(1-t^2)(1-k^2 t^2)}}, \quad \text{sn}^2 + \text{cn}^2 = 1,  \quad k^2 \text{sn}^2 + \text{cn}^2 = 1
\end{equation}
with $k^2 = 1 - m_c$. There are a lot of equivalent definition of the Jacobi elliptic functions, e.g. with the Jacobi amplitude function (see e.g. \cite{NIST} [30, 22.16.11/12]) 
\begin{center}
	$\text{sn}(x, k) = \sin(\text{am}(x, k))$, 
	
	$\text{cn}(x, k) = \cos(\text{am}(x, k))$, 
\end{center}

or with Jacobi theta functions (cf. [\cite{NIST}, 22.2]).
%
%\subsection{Jacobi elliptic function sn}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiSNMpMath? mpNum? the Jacobi elliptic function $\text{sn}(x, k)$.}
%	{x? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{Jacobi elliptic function cn}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiCNMpMath? mpNum? the Jacobi elliptic function $\text{cn}(x, k)$.}
%	{x? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Jacobi elliptic function dn}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiDNMpMath? mpNum? the Jacobi elliptic function $\text{dn}(x, k)$.}
%	{x? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}

\vpara

\begin{mpFunctionsExtract}
	\mpFunctionFour
	{ellipfun? mpNum? any of the Jacobi elliptic functions.}
	{kind? String? A function identifier.}	
	{u? mpNum? A real or complex number.}
	{m? mpNum? A real or complex number.}
	{Keywords? String?  q=None, k=None, tau=None.}		
\end{mpFunctionsExtract}


\vpara
Computes any of the Jacobi elliptic functions, defined in terms of Jacobi theta functions as

\begin{equation}
\text{sn}(u,m) = \frac{\vartheta_3(0,q)\vartheta_1(t,q)}{\vartheta_2(0,q)\vartheta_4(t,q)}
\end{equation}
\begin{equation}
\text{cn}(u,m) = \frac{\vartheta_4(0,q)\vartheta_2(t,q)}{\vartheta_2(0,q)\vartheta_4(t,q)}
\end{equation}
\begin{equation}
\text{dn}(u,m) = \frac{\vartheta_4(0,q)\vartheta_3(t,q)}{\vartheta_3(0,q)\vartheta_4(t,q)}
\end{equation}

or more generally computes a ratio of two such functions. Here $t=u/\vartheta_3(0,q)^2$, and $q=q(m)$ denotes the nome (see nome()). Optionally, you can specify the nome
directly instead of by passing q=<value>, or you can directly specify the elliptic parameter with k=<value>.

The first argument should be a two-character string specifying the function using any combination of 's', 'c', 'd', 'n'. These letters respectively denote the basic functions \text{sn}(u,m), \text{cn}(u,m), \text{dn}(u,m), and $1$. The identifier specifies the ratio of two such functions. For example, 'ns' identifies the function 

\begin{equation}
\text{cd}(u,m) = \frac{1}{\text{sn}(u,m)}
\end{equation}

and 'cd' identifies the function 

\begin{equation}
\text{ns}(u,m) = \frac{\text{cn}(u,m)}{\text{dn}(u,m)}
\end{equation}


If called with only the first argument, a function object evaluating the chosen function for given arguments is returned.

Examples

Basic evaluation

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> ellipfun('cd', 3.5, 0.5)
-0.9891101840595543931308394
>>> ellipfun('cd', 3.5, q=0.25)
0.07111979240214668158441418
\end{lstlisting}


%
%\section{Inverse Jacobi Elliptic Functions}
%\label{EllipticIntegralMpMath}
%
%The inverse Jacobi elliptic functions can be defined like the inverse trigonometric
%functions: e.g. if $\text{sn}(y, k) = x$ then $y = \text{arcsn}(x, k)$; they are multivalued and the MpMath functions return their principal values. They can be represented as elliptic integrals [\cite{NIST}, §22.15(ii)] and they are computed with the incomplete elliptic integral $F(., k)$ using the table from \cite{abramowitz_handbook_1970} [1, p.596].
%The standard range for $k$ is $0 \leq k \leq 1$. MpMath forces $k \geq 0$, and $k > 1$ is normally handled with the computation of $F(., k)$, where the function performs a reciprocal-modulus transformation [\cite{NIST}, 19.7.4].
%
%\subsection{Inverse Jacobi elliptic function arcsn}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiArcSNMpMath? mpNum? the inverse Jacobi elliptic function $\text{arcsn}(x, k)$.}
%	{x? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the inverse Jacobi elliptic function $\text{arcsn}(x, k)$ for $|x| \leq 1$ and $|kx| \leq 1$. The function handles the special case $\text{arcsn}(x, 1) = \text{arctanh}(x)$, otherwise it returns $F(\arcsin(x), k)$, where $F(., k)$ denotes the incomplete Legendre elliptic integral  of the 1st kind (see section \ref{Legendre elliptic integral of the 1st kind MpMath}).
%
%
%
%
%\subsection{Inverse Jacobi elliptic function arccn}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiArcCNMpMath? mpNum? the inverse Jacobi elliptic function $\text{arccn}(x, k)$.}
%	{x? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the  the inverse Jacobi elliptic function $\text{arccn}(x, k)$ for $|x| \leq 1$ if $k \leq 1$,  and $x^2>1-1/k^2$ if $k>1$. 
%
%The function handles the special case $\text{arccn}(x, 1) = \text{arcsech}(x)$, otherwise it returns $F(\arccos(x), k)$, where $F(., k)$ denotes the incomplete Legendre elliptic integral  of the 1st kind (see section \ref{Legendre elliptic integral of the 1st kind MpMath}).
%
%
%
%
%\subsection{Inverse Jacobi elliptic function arcdn}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{JacobiArcDNMpMath? mpNum? the inverse Jacobi elliptic function $\text{arcdn}(x, k)$.}
%	{x? mpNum? A real number.}
%	{k? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes the value of the inverse Jacobi elliptic function  $\text{arcdn}(x, k)$ for $0 \leq x \leq 1$ and $k^2 + x^2 > 1$ if $|k| < 1$; and $|x| \leq 1$ if $|k| > 1$. The function handles the special case $\text{arcdn}(x, 1) = \text{arcsech}(x)$, for $x \geq 0$ it returns
%\begin{eqnarray}
%\text{arcdn}(x, k) = F\left(\arcsin\left(\sqrt{\frac{1-x^2}{k^2}}\right),k\right)
%\end{eqnarray}
%and for negative $x$ and $|k|>1$ the result is
%\begin{eqnarray}
%\text{arcdn}(x, k) = \frac{2}{k} K \left(\frac{1}{k} \right) - \text{arcdn}(|x|, k),
%\end{eqnarray}
%where $F(., k)$ denotes the incomplete Legendre elliptic integral  of the 1st kind (see section \ref{Legendre elliptic integral of the 1st kind MpMath}).


\newpage
\section{Klein j-invariant}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{kleinj? mpNum? the Klein j-invariant.}
	{tau? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The Klein j-invariant is a modular function defined for $\tau$ in the upper half-plane as

\begin{equation}
J(\tau) = \frac{g_2^3(\tau)}{g_2^3(\tau) - 27g_3^2(\tau)}
\end{equation}

where $g_2$ and $g_3$ are the modular invariants of the Weierstrass elliptic function,

\begin{equation}
g_2(\tau) = 60 \sum_{(m,n)\in \mathbb{Z}^2\setminus(0,0)} (m \tau + n)^{-4}
\end{equation}
\begin{equation}
g_3(\tau) = 140 \sum_{(m,n)\in \mathbb{Z}^2\setminus(0,0)} (m \tau + n)^{-6}
\end{equation}

An alternative, common notation is that of the j-function $j(\tau)=1728J(\tau)$.

Examples

Verifying the functional equation $J(\tau)=J(\tau+1)=J(-\tau^{-1})$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> tau = 0.625+0.75*j
>>> tau = 0.625+0.75*j
>>> kleinj(tau)
(-0.1507492166511182267125242 + 0.07595948379084571927228948j)
>>> kleinj(tau+1)
(-0.1507492166511182267125242 + 0.07595948379084571927228948j)
>>> kleinj(-1/tau)
(-0.1507492166511182267125242 + 0.07595948379084571927228946j)
\end{lstlisting}





\newpage
\chapter{Zeta functions, L-series and polylogarithms}
This section includes the Riemann zeta functions and associated functions pertaining to analytic number theory.

%
%\section{Zeta Functions and Polylogarithms}
%\label{ZetaFunctionsMpMath}
%
%
%
%\subsection{\texorpdfstring{$\text{Riemann }\zeta(s)\text{ function}$}{RiemannZeta}}
%\label{RiemannZeta}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RiemannZeta? mpNum? the Riemann zeta function.}
%	{s? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Riemann zeta function $\zeta(s)$ for $s \neq 1$ is defined as
%\begin{equation}
%	\zeta(s) = \sum_{k=1}^\infty \frac{1}{k^s}, \quad s>1.
%\end{equation}
%If $s<0$, the reflection formula is used:
%\begin{equation}
%	\zeta(s) = 2(2\pi)^{s-1} \sin\left(\tfrac{1}{2} \pi s\right) \Gamma(1-s) \zeta(1-s)
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Riemann }\zeta(s)\text{ function}$}{Riemann zeta}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RiemannZetaMpMath? mpNum? the Riemann zeta function.}
%	{s? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%%See section \ref{RiemannZeta}
%This function calculates the Riemann zeta function $\zeta(s)$ for $s \neq 1$, defined by
%\begin{equation}
%\zeta(s) = \sum_{k=1}^\infty \frac{1}{k^s}, \quad s>1.
%\end{equation}
%If $s<0$, the reflection formula is used:
%\begin{equation}
%\zeta(s) = 2(2\pi)^{s-1} \sin\left(\tfrac{1}{2} \pi s\right) \Gamma(1-s) \zeta(1-s)
%\end{equation}
%
%
%
%\subsection{\texorpdfstring{$\text{Riemann }\zeta(n)\text{ for integer arguments}$}{Riemann zeta}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RiemannZetaIntMpMath? mpNum? the Riemann zeta function $\zeta(n)$  for integer arguments $n \neq 1$.}
%	{s? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the Riemann zeta function $\zeta(n)$  for integer arguments $n \neq 1$. For $n > 63$ the result is 1, for $0 \leq n  \leq 63$ the value is taken from table, otherwise the Bernoulli numbers are used: $\zeta(n) = B_{1−n}/(n -1)$ = for $n < 0$.
%
%
%
%
%\subsection{\texorpdfstring{$\text{Riemann }\zeta(1+x)$}{Riemann zeta(1 + x)}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RiemannZetaP1MpMath? mpNum? the Riemann zeta function $\zeta(1+x)$ for $s \neq 0$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function calculates the Riemann zeta function $\zeta(1+x)$ for $s \neq 0$. Normally used with $|x| << 1$ for increased accuracy near the pole of $\zeta(s)$ at $s = 1$. 
%
%
%
%
%\subsection{\texorpdfstring{$\text{Riemann }\zeta(s)-1$}{RiemannZetam1}}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RiemannZetam1MpMath? mpNum? the Riemann zeta function $\zeta(s)-1$ for $s \neq 1$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function calculates the Riemann zeta function $\zeta(s)-1$ for $s \neq 1$.
%
%
%
%\subsection{Prime Zeta Functions}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{PrimeZetaMpMath? mpNum? the prime zeta function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function calculates the prime zeta function
%\begin{equation}
%P(x) = \sum_{p prime} p^{-x}, \quad x>1.
%\end{equation}
%
%
%
%\subsection{Dirichlet eta function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{DirichletEtaMpMath? mpNum? the Dirichlet function $\eta(s)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the Dirichlet function $\eta(s)$, also known as the alternating zeta function, defined for $s > 0$ as
%\begin{equation}
%\eta(s) = \sum_{n=1}^\infty \frac{(-1)^{n-1}}{n^s}
%\end{equation}
%and by analytic continuation for $s \leq 0$. The important relation to the Riemann zeta function is $\eta(s) = (1 - 2^{1-s})\zeta(s)$, which is directly evaluated for $s \leq -8$. In the range $-8 < s < -\eta_\epsilon$ the reflection formula for $\eta$ is used:
%\begin{equation}
%\eta(s) = \frac{2(1-2^{1-s} \Gamma(1-s) \cos\left(\tfrac{1}{2}\pi(1-s)\right)}{(1-s^s)(2\pi)^{1-s}} \eta (1-s).
%\end{equation}
%
%
%
%\subsection{Dirichlet eta function for integer arguments}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{DirichletEtaIntMpMath? mpNum? the Dirichlet eta function $\eta(n)$4 for integer arguments.}
%	{x? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the Dirichlet eta function $\eta(n)$4 for integer arguments. For $n > 64$ the result is $1$, for $0 \leq n \leq 64$ the value is taken from table, otherwise for $n < 0$ the Bernoulli numbers are used: $\eta(n) = (2^{1-n} - 1)B_{1-n}/(1 - n)$.
%
%
%
%
%\subsection{Hurwitz Zeta Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{HurwitzZetaMpMath? mpNum? the Hurwitz zeta function $\zeta(s,a)$.}
%	{s? mpNum? A real number.}
%	{a? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function calculates the Hurwitz zeta function $\zeta(s,a)$ defined as
%\begin{equation}
%\zeta(s,a)=\sum_{k=0}^\infty \frac{1}{(k+a)^s} \quad (s>1, a \neq 0,-1,-2,\cdots),
%\end{equation}
%and by continuation to $s<1$. Note: the current implementation restricts the arguments to $s \neq 1$ and $a>0$. If $a=1$ then $\zeta(s)$ is returned, and if $s=0$ the result is $0.5-a$.
%
%
%
%
%\subsection{Lerch Transcendent}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{LerchTranscendentMpMath? mpNum? the Lerch transcendent $\Phi(z, s, a)$.}
%	{z? mpNum? A real number.}
%	{s? mpNum? A real number.}
%	{a? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function calculates the Lerch transcendent (sometimes called Hurwitz-Lerch zeta function) $\Phi(z, s, a)$ defined for complex arguments as
%\begin{equation}
%\Phi(z, s, a)=\sum_{n=0}^\infty \frac{z^{n}}{(a+n)^s}, \quad a \neq 0,-1,-2,\ldots,|z|<1; \quad \Re s >1, |z|=1.
%\end{equation}
%and by continuation for other $z$ values. The current implementation is restricted to real arguments $|z| \leq 1, s \geq 0, a>0$.
%
%
%
%
%\subsection{Polylogarithms of Integer Order}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{PolylogarithmsIntMpMath? mpNum? the polylogarithm function of integer order $n$.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the polylogarithm function of integer order $n$
%\begin{equation}
%\text{Li}_n(x)=\sum_{k=1}^\infty \frac{x^{k}}{k^n}, \quad n \in  \mathbb{Z},  |x|<1.
%\end{equation}
%or its analytic continuation; for $n>0$ there is the arguments restriction $x\leq 1$.
%
%
%
%
%\subsection{Polylogarithms of Real Order}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{PolylogarithmsMpMath? mpNum? the polylogarithm function of real order $s$.}
%	{s? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the polylogarithm function of real order $s$
%\begin{equation}
%\text{Li}_s(x)=\sum_{k=1}^\infty \frac{x^{k}}{k^s}, \quad s >0,  |x|<1.
%\end{equation}
%for $s\leq 1$ there is the additional arguments restriction $x\neq 1$.
%
%
%\begin{equation}
%\text{Li}_s(z)=z \Phi(z,s,1)
%\end{equation}
%
%
%
%
%\subsection{Dilogarithm Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{DilogarithmMpMath? mpNum? the dilogarithm function $\text{Li}_2(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the dilogarithm function
%\begin{equation}
%\text{dilog}(x) = \Re \text{Li}_2(x) = -\Re \int_0^x \frac{\ln(1-t)}{t}dt.
%\end{equation}
%Note that there is some confusion about the naming: some authors and/or computer algebra systems use $\text{dilog}(x) = \text{Li}_2(1-x)$ and then call $\text{Li}_2(x)$ Spence function/integral or similar.
%
%
%
%
%\subsection{Trilogarithm Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TrilogarithmMpMath? mpNum? the trilogarithm function $\text{Li}_2(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%This function returns the trilogarithm function
%\begin{equation}
%\text{trilog}(x) = \Re \text{Li}_3(x) = -\Re \int_0^x \frac{\ln(1-t)}{t}dt.
%\end{equation}
%Note that the formula needs updating.
%
%
%
%\subsection{Clausen Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ClausenMpMath? mpNum? the Clausen function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the Clausen function
%\begin{equation}
%\text{Cl}_2(x) = \Im \text{Li}_2(e^{ix}) = -\int_0^x \ln \left\vert 2 \sin\left( \tfrac{1}{2} t \right)\right\vert dt.
%\end{equation}
%
%
%
%\newpage


\section{Riemann and Hurwitz zeta functions}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{zeta? mpNum? the Riemann zeta function}
	{s? mpNum? A real or complex number.}
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}


\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{hurwitz? mpNum? the  Hurwitz  zeta function}
	{s? mpNum? A real or complex number.}
	{a? mpNum? A real or complex number.}	
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}


\vpara
Computes the Riemann zeta function or the Hurwitz  zeta function.

\begin{equation}
\zeta(s) = 1+\frac{1}{2^s}+\frac{1}{3^s}+\frac{1}{4^s} + \ldots
\end{equation}

or, with $a \neq 1$, the more general Hurwitz zeta function

\begin{equation}
\zeta(s, a) = \sum_{k=0}^{\infty} \frac{1}{(a+k)^s}.
\end{equation}

Optionally, zeta(s, a, n) computes the $n$-th derivative with respect to $s$,

\begin{equation}
\zeta^{(n)}(s, a) = (-1)^n \sum_{k=0}^{\infty} \frac{\log^n(a+k)}{(a+k)^s}.
\end{equation}


Although these series only converge for $\Re(s)>1$, the Riemann and Hurwitz zeta functions are defined through analytic continuation for arbitrary complex $s \neq 1$($s=1$ is a pole).

\vpara
The implementation uses three algorithms: the Borwein algorithm for the Riemann zeta function when $s$ is close to the real line; the Riemann-Siegel formula for the Riemann zeta function when $s$ is large imaginary, and Euler-Maclaurin summation in all other cases. The reflection formula for $\Re(s) < 0$ is implemented in some cases. The algorithm can be chosen with method = 'borwein', method='riemann-siegel' or method = 'euler-maclaurin'.

\vpara
The parameter $a$ is usually a rational number $a=p/q$, and may be specified as such by passing an integer tuple $(p,q)$. Evaluation is supported for arbitrary complex $a$, but may be slow and/or inaccurate when $\Re(s) < 0$ for nonrational $a$ or when computing derivatives.

Examples

Some values of the Riemann zeta function:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> zeta(2); pi**2 / 6
1.644934066848226436472415
1.644934066848226436472415
>>> zeta(0)
-0.5
>>> zeta(-1)
-0.08333333333333333333333333
>>> zeta(-2)
0.0
\end{lstlisting}

Evaluation is supported for complex $s$ and $a$:

\lstset{language={Python}}
\begin{lstlisting}
>>> zeta(-3+4j)
(-0.03373057338827757067584698 + 0.2774499251557093745297677j)
>>> zeta(2+3j, -1+j)
(389.6841230140842816370741 + 295.2674610150305334025962j)
\end{lstlisting}

Some values of the Hurwitz zeta function:

\lstset{language={Python}}
\begin{lstlisting}
>>> zeta(2, 3); -5./4 + pi**2/6
0.3949340668482264364724152
0.3949340668482264364724152
>>> zeta(2, (3,4)); pi**2 - 8*catalan
2.541879647671606498397663
2.541879647671606498397663
\end{lstlisting}



\newpage
\section{Dirichlet L-series}

\subsection{Dirichlet eta function}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{altzeta? mpNum? the Dirichlet eta function, $\eta(s)$}
	{s? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


The Dirichlet eta function, $\eta(s)$ is also known as the alternating zeta function. This function is defined in analogy with the Riemann zeta function as providing the sum of the alternating series

\begin{equation}
\eta(s) = \sum_{k=0}^{\infty} \frac{(-1)^k}{k^s} = 1- \frac{1}{2^s} + \frac{1}{3^s}  - \frac{1}{4^s} + \ldots
\end{equation}

The eta function, unlike the Riemann zeta function, is an entire function, having a finite value for all complex $s$. The special case $\eta(1)=\log(2)$ gives the value of the alternating harmonic series.

\vpara
The alternating zeta function may expressed using the Riemann zeta function as 

$\eta(s)=(1-2^{1-s}) \zeta(s)$. It can also be expressed in terms of the Hurwitz zeta function, for example using dirichlet() (see documentation for that function).

Examples

Some special values are:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> altzeta(1)
0.693147180559945
>>> altzeta(0)
0.5
>>> altzeta(-1)
0.25
>>> altzeta(-2)
0.0
\end{lstlisting}



\subsection{\texorpdfstring{$\text{Dirichlet }\eta(s)-1$}{Gammax}}

\begin{mpFunctionsExtract}
	\mpFunctionOneNotImplemented
	{DirichletEtam1MpMath? mpNum? the Dirichlet function $\eta(s) - 1$.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the Dirichlet function $\eta(s) - 1$.




\subsection{Dirichlet Beta Function}

\begin{mpFunctionsExtract}
	\mpFunctionOneNotImplemented
	{DirichletBetaMpMath? mpNum? the Dirichlet function $\beta(s)$.}
	{s? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the Dirichlet function $\beta(s)$, defined for $s > 0$ as
\begin{equation}
	\beta(s) = \sum_{n=1}^\infty \frac{(-1)^{n}}{(2n+1)^s} = 2^{-s} \Phi\left(-1,s,\tfrac{1}{2} \right)
\end{equation}




\subsection{Dirichlet Lambda Function}

\begin{mpFunctionsExtract}
	\mpFunctionOneNotImplemented
	{DirichletLambdaMpMath? mpNum? the Dirichlet function $\beta(s)$.}
	{s? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the Dirichlet function $\lambda(s)$, defined for $s > 0$ as
\begin{equation}
	\lambda(s) = \sum_{n=0}^\infty (2n+1)^s
\end{equation}
and by analytic continuation for $s<1$. The function is calculated as
\begin{equation}
	\lambda(s) = (1-2^{-s}) \eta(s).
\end{equation}








\subsection{Dirichlet L-function}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{dirichlet? mpNum? the Dirichlet L-function}
	{s? mpNum? A real or complex number.}
	{chi? mpNum? A periodic sequence.}	
	{Keywords? mpNum? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
The Dirichlet L-function is defined as

\begin{equation}
L(s,\chi)=\sum_{k=1}^{\infty} \frac{\chi(k)}{k^s}
\end{equation}

where $\chi$ is a periodic sequence of length $q$ which should be supplied in the form of a list $[\chi(0), \chi(1),\ldots,\chi(q-1)]$. Strictly, $\chi$ should be a Dirichlet character, but any periodic sequence will work.

\vpara
For example, dirichlet(s, [1]) gives the ordinary Riemann zeta function and dirichlet(s, [-1,1]) gives the alternating zeta function (Dirichlet eta function).

Also the derivative with respect to (currently only a first derivative) can be evaluated.

Examples

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> dirichlet(3, [1]); zeta(3)
1.202056903159594285399738
1.202056903159594285399738
>>> dirichlet(1, [1])
+inf
\end{lstlisting}


\newpage
\section{Stieltjes constants}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{stieltjes? mpNum? the $n$-th Stieltjes constant}
	{n? mpNum? A real or complex number.}
	{a? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}



For a nonnegative integer $n$, stieltjes(n) computes the $n$-th Stieltjes constant $\gamma_n$, defined as the $n$-th coefficient in the Laurent series expansion of the Riemann zeta function around the pole at $s=1$. That is, we have:

\begin{equation}
\zeta(s) = \frac{1}{s-1} \sum_{n=0}^{\infty} \frac{(-1)^n}{n!} \gamma_n(s-1)^n
\end{equation}

More generally, stieltjes(n, a) gives the corresponding coefficient $\gamma_n(a)$ for the Hurwitz zeta function $\zeta(s,a)$ (with $\gamma_n=\gamma_n(1)$).

stieltjes() numerically evaluates the integral in the following representation due to Ainsworth, Howell and Coffey [1], [2]:

\begin{equation}
\gamma_n(a) = \frac{\log^n a}{2a} \ \frac{\log^{n+1}(a)}{n+1} + \frac{2}{a} \Re \int_0^{\infty} \frac{(x/a - i) \log^n(a-ix)}{(1+x^2/a^2)(e^{2\pi x}-1)} dx
\end{equation}

Examples

The zeroth Stieltjes constant is just Euler's constant $\gamma$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> stieltjes(0)
0.577215664901533
\end{lstlisting}

Some more values are:

\lstset{language={Python}}
\begin{lstlisting}
>>> stieltjes(1)
-0.0728158454836767
>>> stieltjes(10)
0.000205332814909065
>>> stieltjes(30)
0.00355772885557316
>>> stieltjes(1000)
-1.57095384420474e+486
>>> stieltjes(2000)
2.680424678918e+1109
>>> stieltjes(1, 2.5)
-0.23747539175716
\end{lstlisting}


\newpage
\section{Zeta function zeros}
These functions are used for the study of the Riemann zeta function in the critical strip.

\vpara

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{zetazero? mpNum? the $n$-th nontrivial zero of $\zeta(s)$ on the critical line}
	{n? mpNum? An integer.}
	{Keywords? String? verbose=False.}	
\end{mpFunctionsExtract}

\vpara
Computes the $n$-th nontrivial zero of $\zeta(s)$ on the critical line, i.e. returns an approximation of the $n$-th largest complex number $s=\tfrac{1}{2}+ti$ for which $\zeta(s)=0$.

Equivalently, the imaginary part $t$ is a zero of the Z-function (siegelz()).

Examples

The first few zeros:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> zetazero(1)
(0.5 + 14.13472514173469379045725j)
>>> zetazero(2)
(0.5 + 21.02203963877155499262848j)
>>> zetazero(20)
(0.5 + 77.14484006887480537268266j)
\end{lstlisting}

Verifying that the values are zeros:

\lstset{language={Python}}
\begin{lstlisting}
>>> for n in range(1,5):
... s = zetazero(n)
... chop(zeta(s)), chop(siegelz(s.imag))
...
(0.0, 0.0)
(0.0, 0.0)
(0.0, 0.0)
(0.0, 0.0)
\end{lstlisting}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{nzeros? mpNum? the number of zeros of the Riemann zeta function in $(0,1) \times (0,t)$, usually denoted by $N(t)$.}
	{t? mpNum? An integer.}	
\end{mpFunctionsExtract}


Examples

The first zero has imaginary part between 14 and 15:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> nzeros(14)
0
>>> nzeros(15)
1
>>> zetazero(1)
(0.5 + 14.1347251417347j
\end{lstlisting}


\newpage
\section{Riemann-Siegel Z function and related functions}

\subsection{Riemann-Siegel Z}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{siegelz? mpNum? the Riemann-Siegel Z function}
	{t? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The Riemann-Siegel Z function is defined as

\begin{equation}
Z(t) = e^{i\theta(t)} \zeta(1/2+it)
\end{equation}

where $\zeta(s) $ is the Riemann zeta function (zeta()) and where $\theta(t)$ denotes the Riemann-Siegel theta function (see siegeltheta()).

Evaluation is supported for real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> siegelz(1)
-0.7363054628673177346778998
>>> siegelz(3+4j)
(-0.1852895764366314976003936 - 0.2773099198055652246992479j)
\end{lstlisting}

The first four derivatives are supported, using the optional derivative keyword argument:

\lstset{language={Python}}
\begin{lstlisting}
>>> siegelz(1234567, derivative=3)
56.89689348495089294249178
>>> diff(siegelz, 1234567, n=3)
56.89689348495089294249178
\end{lstlisting}


\subsection{Riemann-Siegel theta function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{siegeltheta? mpNum? the Riemann-Siegel theta function}
	{t? mpNum? A real or complex number.}
\end{mpFunctionsExtract}

\vpara
The Riemann-Siegel theta function is defined as

\begin{equation}
\theta(t) = \frac{\log\Gamma(\frac{1+2it}{4}) - \log\Gamma(\frac{1-2it}{4})}{2i} - \frac{\log \pi}{2} t.
\end{equation}

The Riemann-Siegel theta function is important in providing the phase factor for the Zfunction (see siegelz()). Evaluation is supported for real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> siegeltheta(0)
0.0
>>> siegeltheta(inf)
+inf
>>> siegeltheta(-inf)
-inf
>>> siegeltheta(1)
-1.767547952812290388302216
>>> siegeltheta(10+0.25j)
(-3.068638039426838572528867 + 0.05804937947429712998395177j)
\end{lstlisting}

Arbitrary derivatives may be computed with derivative = k

\lstset{language={Python}}
\begin{lstlisting}
>>> siegeltheta(1234, derivative=2)
0.0004051864079114053109473741
>>> diff(siegeltheta, 1234, n=2)
0.0004051864079114053109473741
\end{lstlisting}


\subsection{Gram point (Riemann-Siegel Z function)}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{grampoint? mpNum? the $n$-th Gram point $g_n$, defined as the solution to the equation $\theta(g_n)=\pi n$ where $\theta(t)$ is the Riemann-Siegel theta function}
	{n? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


The first few Gram points are:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> grampoint(0)
17.84559954041086081682634
>>> grampoint(1)
23.17028270124630927899664
>>> grampoint(2)
27.67018221781633796093849
>>> grampoint(3)
31.71797995476405317955149
\end{lstlisting}


\subsection{Backlunds function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{backlunds? mpNum? the function $S(t) = \text{arg}\zeta\left(\tfrac{1}{2}+it\right)/\pi$.}
	{t? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


\vpara
See Titchmarsh Section 9.3 for details of the definition.

Examples

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> backlunds(217.3)
0.16302205431184
\end{lstlisting}



\newpage
\section{Lerch transcendent and related functions}


\begin{mpFunctionsExtract}
	\mpFunctionThree
	{lerchphi? mpNum? the Lerch transcendent}
	{z? mpNum? A real or complex number.}
	{s? mpNum? A real or complex number.}	
	{a? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Lerch transcendent, defined for $|z|<1$ and $\Re a >0$, is given by

\begin{equation}
\Phi(z,s,a) = \sum_{k=0}^{\infty} \frac{z^k}{(a+k)^s}
\end{equation}

and generally by the recurrence $\Phi(z,s,a) = z\Phi(z,s,a+1) +a^{-s}$  along with the integral representation valid for $\Re a>0$

\begin{equation}
\Phi(z,s,a) = \frac{1}{2a^s} + \int_0^{\infty} \frac{z^t}{(a+t)^s} dt - 2 \int_0^{\infty} \frac{\sin(t\log z) - s \arctan(t/a)}{(a^2+t^2)^{s/2}(e^{2\pi t}-1)} dt.
\end{equation}


The Lerch transcendent generalizes the Hurwitz zeta function zeta() ($z=1$) and the polylogarithm polylog() ($a=1$).

Examples

Several evaluations in terms of simpler functions:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> lerchphi(-1,2,0.5); 4*catalan
3.663862376708876060218414
3.663862376708876060218414
>>> diff(lerchphi, (-1,-2,1), (0,1,0)); 7*zeta(3)/(4*pi**2)
0.2131391994087528954617607
0.2131391994087528954617607
>>> lerchphi(-4,1,1); log(5)/4
0.4023594781085250936501898
0.4023594781085250936501898
>>> lerchphi(-3+2j,1,0.5); 2*atanh(sqrt(-3+2j))/sqrt(-3+2j)
(1.142423447120257137774002 + 0.2118232380980201350495795j)
(1.142423447120257137774002 + 0.2118232380980201350495795j)
\end{lstlisting}

Evaluation works for complex arguments and $|z|\geq 1$:
\lstset{language={Python}}
\begin{lstlisting}
>>> lerchphi(1+2j, 3-j, 4+2j)
(0.002025009957009908600539469 + 0.003327897536813558807438089j)
>>> lerchphi(-2,2,-2.5)
-12.28676272353094275265944
>>> lerchphi(10,10,10)
(-4.462130727102185701817349e-11 + 1.575172198981096218823481e-12j)
>>> lerchphi(10,10,-10.5)
(112658784011940.5605789002 + 498113185.5756221777743631j)
\end{lstlisting}





\subsection{Fermi-Dirac integrals of integer order}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{FermiDiracIntMpMath? mpNum? the complete Fermi-Dirac integrals $F_n(x)$ of integer order.}
	{x? mpNum? A real number.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function returns the complete Fermi-Dirac integrals $F_n(x)$ of integer order. They are defined for real orders $s>-1$ by
\begin{equation}
	F_s(x)=\frac{1}{\Gamma(s+1)} \int_0^\infty \frac{t^s}{e^{t-x}+1} dt
\end{equation}
and by analytic continuation for $s \leq -1$ using polylogarithms
\begin{equation}
	F_s(x)=-\text{Li}_{s+1}(-e^x) = e^x \Phi(-e^x,s+1,1).
\end{equation}




\subsection{\texorpdfstring{$\text{Fermi-Dirac integral }F_{-1/2}(x)$}{FermiDiracM1}}

\begin{mpFunctionsExtract}
	\mpFunctionOneNotImplemented
	{FermiDiracPHalfMpMath? mpNum? the complete Fermi-Dirac integral $F_{-1/2}(x)$.}
	{s? mpNum? A real number.}
\end{mpFunctionsExtract}




\subsection{\texorpdfstring{$\text{Fermi-Dirac integral }F_{1/2}(x)$}{FermiDiracP1}}

\begin{mpFunctionsExtract}
	\mpFunctionOneNotImplemented
	{FermiDiracHalfMpMath? mpNum? the complete Fermi-Dirac integral $F_{1/2}(x)$.}
	{s? mpNum? A real number.}
\end{mpFunctionsExtract}




\subsection{\texorpdfstring{$\text{Fermi-Dirac integral }F_{3/2}(x)$}{FermiDiracP1}}

\begin{mpFunctionsExtract}
	\mpFunctionOneNotImplemented
	{FermiDirac3HalfMpMath? mpNum? the complete Fermi-Dirac integral $F_{3/2}(x)$.}
	{s? mpNum? A real number.}
\end{mpFunctionsExtract}




\subsection{Legendre Chi-Function}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{LegendreChiMpMath? mpNum? the Legendre Chi-Function function $\chi_s(x)$.}
	{s? mpNum? A real number.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function calculates the Legendre Chi-Function function $\chi_s(x)$ defined for $s \geq 0, |x|\leq 1$ by
\begin{equation}
	\chi_s(x)=\sum_{n=0}^\infty \frac{x^{2n+1}}{(2n+1)^s}.
\end{equation}
The function can be expressed as 
\begin{equation}
	\chi_s(x)=2^{-s} x \Phi\left(x^2,s,\tfrac{1}{2}\right) = \tfrac{1}{2}\left(\text{Li}_s(x)-\text{Li}_s(-x) \right).
\end{equation}
For large $s > 22.8$ the function adds up to three terms of the sum,
for $s = 0$ or $s = 1$ the $Li_s$ relation is used, otherwise the result is computed with Lerch's transcendent.




\subsection{Inverse Tangent Integral}

\begin{mpFunctionsExtract}
	\mpFunctionOneNotImplemented
	{InverseTangentMpMath? mpNum? the inverse-tangent integral.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
This function returns the inverse-tangent integral
\begin{equation}
	\text{Ti}_2(x) = \int_0^x \frac{\arctan(t)}{t} dt. = \tfrac{1}{4} x \Phi \left(-x^2,2,\tfrac{1}{2}\right)
\end{equation}
For $x>1$ the relation
\begin{equation}
	\text{Ti}_2(x) = \text{Ti}_2\left(\frac{1}{x}\right) + \frac{\pi}{2} \ln(x)
\end{equation}
is used, and for $x<0$ the result is $\text{Ti}_2(x) = -\text{Ti}_2(-x)$.






\newpage
\section{Polylogarithms and Clausen functions}

\subsection{Polylogarithm}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{polylog? mpNum? the polylogarithm}
	{s? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

The polylogarithm is defined by the sum

\begin{equation}
\text{Li}_s(z) = \sum_{k=1}^{\infty} \frac{z^k}{k^s}.
\end{equation}

This series is convergent only for $|z|<1$, so elsewhere the analytic continuation is implied.

\vpara
The polylogarithm should not be confused with the logarithmic integral (also denoted by Li or li), which is implemented as li().

Examples

The polylogarithm satisfies a huge number of functional identities. A sample of polylogarithm evaluations is shown below:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> polylog(1,0.5), log(2)
(0.693147180559945, 0.693147180559945)
>>> polylog(2,0.5), (pi**2-6*log(2)**2)/12
(0.582240526465012, 0.582240526465012)
>>> polylog(2,-phi), -log(phi)**2-pi**2/10
(-1.21852526068613, -1.21852526068613)
>>> polylog(3,0.5), 7*zeta(3)/8-pi**2*log(2)/12+log(2)**3/6
(0.53721319360804, 0.53721319360804)
\end{lstlisting}

polylog() can evaluate the analytic continuation of the polylogarithm when $s$ is an integer:

\lstset{language={Python}}
\begin{lstlisting}
>>> polylog(2, 10)
(0.536301287357863 - 7.23378441241546j)
>>> polylog(2, -10)
-4.1982778868581
>>> polylog(2, 10j)
(-3.05968879432873 + 3.71678149306807j)
>>> polylog(-2, 10)
-0.150891632373114
>>> polylog(-2, -10)
0.067618332081142
>>> polylog(-2, 10j)
(0.0384353698579347 + 0.0912451798066779j)
\end{lstlisting}




\subsection{Dilogarithm Function}
\label{DiGammaFunction}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{dilog? mpNum? the dilogarithm function $\text{Li}_2(x)$.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
The dilogarithm function is defined as
\begin{equation}
	\text{dilog}(x) = \Re \text{Li}_2(x) = -\Re \int_0^x \frac{\ln(1-t)}{t}dt.
\end{equation}
Note that there is some confusion about the naming: some authors and/or computer algebra systems use $\text{dilog}(x) = \text{Li}_2(1-x)$ and then call $\text{Li}_2(x)$ Spence function/integral or similar.




\subsection{Debye Functions}

\begin{mpFunctionsExtract}
	\mpFunctionTwoNotImplemented
	{DebyeMpMath? mpNum? the Debye function of order $n$.}
	{n? mpNum? An Integer.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
This routine returns the Debye functions
\begin{equation}
\text{D}_n(x) = \frac{n}{x^n} \int_0^x \frac{t^n}{e^t-1} dt \quad (n>0, x \geq 0).
\end{equation}

\begin{equation}
\text{D}_k(x) = \frac{k}{x^{k+1}} \left[(-1)^k k! \zeta(k+1) + \sum_{m=0}^k (-1)^{k-m+1} \frac{k!}{m!} x^m \text{Li}_{k-m+1}(e^x) \right] - \frac{k}{k+1},
\end{equation}

where $\text{Li}_s$ denotes the polylogarithm (see \cite{Dubinov_2008}).



\subsection{Clausen sine function}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{clsinlog? mpNum? the Clausen sine function}
	{s? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Clausen sine function is defined formally by the series

\begin{equation}
\text{Cl}_s(z) = \sum_{k=1}^{\infty} \frac{\sin(kz)}{k^s}.
\end{equation}

The special case $\text{Cl}_2(z)$ (i.e. clsin(2,z)) is the classical 'Clausen function'. More generally, the Clausen function is defined for complex $s$ and $z$, even when the series does not converge. The Clausen function is related to the polylogarithm (polylog()) as

\begin{equation}
\text{Cl}_s(z) = \frac{1}{2i}\left[ \text{Li}_s\left(e^{iz}\right) - \text{Li}_s\left(e^{-iz}\right) \right]
\end{equation}
\begin{equation}
\text{Cl}_s(z) = \Im\left[ \text{Li}_s\left(e^{iz}\right) \right], \quad (s,z \in \mathbb{R}),
\end{equation}

and this representation can be taken to provide the analytic continuation of the series. The complementary function clcos() gives the corresponding cosine sum.

Examples

Evaluation for arbitrarily chosen $s$ and $z$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> s, z = 3, 4
>>> clsin(s, z); nsum(lambda k: sin(z*k)/k**s, [1,inf])
-0.6533010136329338746275795
-0.6533010136329338746275795
\end{lstlisting}

The classical Clausen function $\text{Cl}_s(z)$ gives the value of the integral $\int_0^{\theta} -\ln(2\sin(x/2)) dx$ for $0<\theta<2\pi$:

\lstset{language={Python}}
\begin{lstlisting}
>>> cl2 = lambda t: clsin(2, t)
>>> cl2(3.5)
-0.2465045302347694216534255
>>> -quad(lambda x: ln(2*sin(0.5*x)), [0, 3.5])
-0.2465045302347694216534255
\end{lstlisting}



\subsection{Clausen cosine function}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{clcos? mpNum? the Clausen cosine function}
	{s? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


\vpara
The Clausen cosine function is defined formally by the series

\begin{equation}
\widetilde{\text{Cl}}_s(z) = \sum_{k=1}^{\infty} \frac{\cos(kz)}{k^s}.
\end{equation}

This function is complementary to the Clausen sine function clsin(). In terms of the polylogarithm,

\begin{equation}
\widetilde{\text{Cl}}_s(z) = \frac{1}{2}\left[ \text{Li}_s\left(e^{iz}\right) - \text{Li}_s\left(e^{-iz}\right) \right]
\end{equation}
\begin{equation}
\widetilde{\text{Cl}}_s(z) = \Re\left[ \text{Li}_s\left(e^{iz}\right) \right], \quad (s,z \in \mathbb{R}),
\end{equation}

Examples

Evaluation for arbitrarily chosen $s$ and $z$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> s, z = 3, 4
>>> clcos(s, z); nsum(lambda k: cos(z*k)/k**s, [1,inf])
-0.6518926267198991308332759
-0.6518926267198991308332759
\end{lstlisting}



\subsection{Polyexponential function}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{polyexp? mpNum? the polyexponential function}
	{s? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The polyexponential function is defined for arbitrary complex $s$, $z$ by the series

\begin{equation}
E_s(z) = \sum_{k=1}^{\infty} \frac{k^s}{k!} z^k.
\end{equation}

$E_s(z)$ is constructed from the exponential function analogously to how the polylogarithm is constructed from the ordinary logarithm; as a function of $s$ (with $z$ fixed), $E_s$ is an L-series. It is an entire function of both $s$ and $z$.

The polyexponential function provides a generalization of the Bell polynomials $B_n(x)$ (see bell()) to noninteger orders $n$. In terms of the Bell polynomials,

\begin{equation}
E_s(z) = e^z B_s(z) - \text{sinc}(\pi s).
\end{equation}

Note that $B_n(x)$ and $e^{-x} E_n(x)$ are identical if $n$ is a nonzero integer, but not otherwise. In particular, they differ at $n=0$.

Examples

Evaluating a series:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> nsum(lambda k: sqrt(k)/fac(k), [1,inf])
2.101755547733791780315904
>>> polyexp(0.5,1)
2.101755547733791780315904
\end{lstlisting}

Evaluation for arbitrary arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> polyexp(-3-4j, 2.5+2j)
(2.351660261190434618268706 + 1.202966666673054671364215j)
\end{lstlisting}


\newpage
\section{Zeta function variants}

\subsection{Prime zeta function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{primezeta? mpNum? the prime zeta function.}
	{s? mpNum? A real or complex number.}
\end{mpFunctionsExtract}


\vpara
The prime zeta function is defined in analogy with the Riemann zeta function (zeta()) as

\begin{equation}
P(s) = \sum_p \frac{1}{p^s}
\end{equation}

where the sum is taken over all prime numbers $p$. Although this sum only converges for $\Re(s)>1$, the function is defined by analytic continuation in the half-plane $\Re(s)>0$.

Examples

Arbitrary-precision evaluation for real and complex arguments is supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 30; mp.pretty = True
>>> primezeta(2)
0.452247420041065498506543364832
>>> primezeta(pi)
0.15483752698840284272036497397
>>> mp.dps = 50
>>> primezeta(3)
0.17476263929944353642311331466570670097541212192615
>>> mp.dps = 20
>>> primezeta(3+4j)
(-0.12085382601645763295 - 0.013370403397787023602j)
\end{lstlisting}

The analytic continuation to $0<\Re(s) \leq 1$ is implemented. In this strip the function exhibits very complex behavior; on the unit interval, it has poles at $1/n$ for every squarefree integer $n$:

\lstset{language={Python}}
\begin{lstlisting}
>>> primezeta(0.5) # Pole at s = 1/2
(-inf + 3.1415926535897932385j)
>>> primezeta(0.25)
(-1.0416106801757269036 + 0.52359877559829887308j)
>>> primezeta(0.5+10j)
(0.54892423556409790529 + 0.45626803423487934264j)
\end{lstlisting}


\subsection{Secondary zeta function }

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{secondzeta? mpNum? the secondary zeta function}
	{s? mpNum? A real or complex number.}
	{Keywords? String? a=0.015, error=False.}	
\end{mpFunctionsExtract}

\vpara
The secondary zeta function $Z(s)$ is defined for $\Re(s)>1$ by

\begin{equation}
Z(s)=\sum_{n=1}^{\infty} \frac{1}{\tau_n^s}
\end{equation}

where $\tfrac{1}{2}+i\tau_n$ runs through the zeros of $\zeta(s)$ with imaginary part positive.

\vpara
$Z(s)$ extends to a meromorphic function on $\mathbb{C}$ with a double pole at $s=1$ and simple poles at the points $-2n$ for $n=0,1,2,\ldots$.

Examples

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.pretty = True; mp.dps = 15
>>> secondzeta(2)
0.023104993115419
>>> xi = lambda s: 0.5*s*(s-1)*pi**(-0.5*s)*gamma(0.5*s)*zeta(s)
>>> Xi = lambda t: xi(0.5+t*j)
>>> -0.5*diff(Xi,0,n=2)/Xi(0)
(0.023104993115419 + 0.0j)
\end{lstlisting}

We may ask for an approximate error value:

\lstset{language={Python}}
\begin{lstlisting}
>>> secondzeta(0.5+100j, error=True)
((-0.216272011276718 - 0.844952708937228j), 2.22044604925031e-16)
\end{lstlisting}



\newpage
\chapter{Number-theoretical, combinatorial and integer functions}
For factorial-type functions, including binomial coefficients, double factorials, etc., see the separate section Factorials and gamma functions.


\section{Fibonacci numbers}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{fibonacci? mpNum? the $n$-th Fibonacci number, $F(n)$}
	{n? mpNum? A real or complex number.}
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}


\vspace{0.6cm}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{fib? mpNum? the $n$-th Fibonacci number, $F(n)$}
	{n? mpNum? A real or complex number.}
	{Keywords? String? derivative=0.}	
\end{mpFunctionsExtract}

\vpara
The Fibonacci numbers are defined by the recurrence $F(n)=F(n-1)+F(n-2)$ with the initial values $F(0)=0$, $F(1)=1$. fibonacci() extends this definition to arbitrary real and complex arguments using the formula

\begin{equation}
F(z) = \frac{\phi^z - \cos(\pi z) \phi^{-z}}{\sqrt{5}}
\end{equation}

where $\phi$ is the golden ratio. fibonacci() also uses this continuous formula to compute $F(n)$ for extremely large $n$, where calculating the exact integer would be wasteful.

For convenience, fib() is available as an alias for fibonacci().

Basic examples

Some small Fibonacci numbers are:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for i in range(10):
... print(fibonacci(i))
...
0.0
1.0
1.0
2.0
3.0
5.0
8.0
13.0
21.0
34.0
>>> fibonacci(50)
12586269025.0
\end{lstlisting}


fibonacci() can compute approximate Fibonacci numbers of stupendous size:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15
>>> fibonacci(10**25)
3.49052338550226e+2089876402499787337692720
\end{lstlisting}



The extended Fibonacci function is an analytic function. The property $F(z)=F(z-1)+F(z-2)$ holds for arbitrary $z$:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15
>>> fib(pi)
2.1170270579161
>>> fib(pi-1) + fib(pi-2)
2.1170270579161
>>> fib(3+4j)
(-5248.51130728372 - 14195.962288353j)
>>> fib(2+4j) + fib(1+4j)
(-5248.51130728372 - 14195.962288353j)
\end{lstlisting}



%
%\newpage
%
%
%
%\subsection{Bernoulli numbers}
%\label{BernoulliNumbersAndPolynomialsMpMath}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{BernoulliMpMath? mpNum? the Bernoulli numbers $B_n$.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Bernoulli polynomials}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{BernoulliPolyMpMath? mpNum? the Bernoulli polynomials $B_n (x)$ of degree $n \geq 0$.}
%	{n? mpNum? An Integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%



\newpage
\section{Bernoulli numbers and polynomials}
\label{BernoulliNumbersAndPolynomials}

\subsection{Bernoulli numbers}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{bernoulli? mpNum? the $n$th Bernoulli number, $B_n$, for any integer $n>0$}
	{n? mpNum? An integer}	
\end{mpFunctionsExtract}


\vspace{0.3cm}
The Bernoulli numbers $B_n$ are defined by their generating function
\begin{equation}
\frac{t}{e^t - 1} = \sum_{n=0}^{\infty} B_n \frac{t^n}{n!}, \quad |t| < 2\pi.
\end{equation}
If $n < 0$ or if $n > 2$ is odd, the result is 0, and $B_1 = -1/2$. If $n \leq 120$ the function value is taken from a pre-calculated table. For large $n$ the asymptotic  approximation [30, 24.11.1]
\begin{equation}
(-1)^{n+1} B_{2n} \approx \frac{2(2n)!}{(2\pi)^{2n}} ,
\end{equation}
gives an asymptotic recursion formula

\begin{equation}
B_{2n+2} \approx - \frac{(2n + 1)(2n + 2)}{(2\pi)^2} B_{2n},
\end{equation}

which is used for computing $B_n$ for $120 < n \leq 2312$ from a pre-calculated table of
values $B_{32k+128} (0 \leq  k \leq  68)$. The average iteration count is 4, and the maximum relative error of 4.5 eps occurs for $n = 878$.



Computes the $n$th Bernoulli number, $B_n$, for any integer $n>0$.
The Bernoulli numbers are rational numbers, but this function returns a floating-point approximation. To obtain an exact fraction, use  bernfrac() instead.

For small $n$ ($n<3000$) bernoulli() uses a recurrence formula due to Ramanujan. All results in this range are cached, so sequential computation of small Bernoulli numbers is guaranteed to be fast.
For larger $n$, $B_n$ is evaluated in terms of the Riemann zeta function




Examples

Numerical values of the first few Bernoulli numbers:


\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(15):
... print("%s %s" % (n, bernoulli(n)))
...
0 1.0
1 -0.5
2 0.166666666666667
3 0.0
4 -0.0333333333333333
5 0.0
6 0.0238095238095238
7 0.0
8 -0.0333333333333333
9 0.0
10 0.0757575757575758
11 0.0
12 -0.253113553113553
13 0.0
14 1.16666666666667
\end{lstlisting}

Bernoulli numbers can be approximated with arbitrary precision:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 50
>>> bernoulli(100)
-2.8382249570693706959264156336481764738284680928013e+78
\end{lstlisting}

Arbitrarily large are supported:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15
>>> bernoulli(10**20 + 2)
3.09136296657021e+1876752564973863312327
\end{lstlisting}


\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionOne
	{bernfrac? mpNum? a tuple of integers $(p,q)$ such that $p/q=B_n$ exactly, where $B_n$denotes the $n$-th Bernoulli number.}
	{n? mpNum? An integer}	
\end{mpFunctionsExtract}

\vpara
The fraction is always reduced to lowest terms. Note that for $n>1$ and $n$ odd, $B_n=0$, and $(0,1)$ is returned.

\vpara
bernoulli() computes a floating-point approximation directly, without computing the exact fraction first. This is much faster for large $n$.

\vpara
bernfrac() works by computing the value of $B_n$ numerically and then using the von Staudt-Clausen theorem [1] to reconstruct the exact fraction. For large $n$, this is significantly faster than computing $B_1,B_2,\ldots,B_n$ recursively with exact arithmetic.

\vpara
The implementation has been tested for $n=10^m$ up to $m=6$. In practice, bernfrac() appears to be about three times slower than the specialized program calcbn.exe [2]

\vpara
Examples

The first few Bernoulli numbers are exactly:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> for n in range(15):
... p, q = bernfrac(n)
... print("%s %s/%s" % (n, p, q))
...
0 1/1
1 -1/2
2 1/6
3 0/1
4 -1/30
5 0/1
6 1/42
7 0/1
8 -1/30
9 0/1
10 5/66
11 0/1
12 -691/2730
13 0/1
14 7/6
\end{lstlisting}

This function works for arbitrarily large $n$:

\lstset{language={Python}}
\begin{lstlisting}
>>> p, q = bernfrac(10**4)
>>> print(q)
2338224387510
>>> print(len(str(p)))
27692
>>> mp.dps = 15
>>> print(mpf(p) / q)
-9.04942396360948e+27677
>>> print(bernoulli(10**4))
-9.04942396360948e+27677
\end{lstlisting}





\subsection{Bernoulli polynomials}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{bernpoly? mpNum? the Bernoulli polynomial $B_n(z)$}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


\vspace{0.3cm}
The Bernoulli polynomials $B_n (x)$ of degree $n \geq 0$ are defined by the generating function [30, 24.2.3]
\begin{equation}
\frac{te^{xt}}{e^t - 1} = \sum_{n=0}^{\infty} B_n(x) \frac{t^n}{n!}, \quad |t| < 2\pi.
\end{equation}
or the simple explicit representation [30, 24.2.5]
\begin{equation}
B_n(x) = \sum_{n=0}^{\infty} \binom{n}{k} B_k(x) x^{n-k}.
\end{equation}

\vpara
The first few Bernoulli polynomials are:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(6):
... nprint(chop(taylor(lambda x: bernpoly(n,x), 0, n)))
...
[1.0]
[-0.5, 1.0]
[0.166667, -1.0, 1.0]
[0.0, 0.5, -1.5, 1.0]
[-0.0333333, 0.0, 1.0, -2.0, 1.0]
[0.0, -0.166667, 0.0, 1.66667, -2.5, 1.0]
\end{lstlisting}

Evaluation is accurate for large and small $z$:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 25
>>> bernpoly(100, 0.5)
2.838224957069370695926416e+78
>>> bernpoly(1000, 10.5)
5.318704469415522036482914e+1769
\end{lstlisting}



\newpage
\section{Euler numbers and polynomials}


\subsection{Euler numbers}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{eulernum? mpNum? the $n$-th Euler number}
	{n? mpNum? An integer}	
\end{mpFunctionsExtract}

\vpara
The $n$-th Euler number is defined as the $n$-th derivative of $\text{sech}(t)=1/\text{cosh}(t)$ evaluated at $t=0$. Equivalently, the Euler numbers give the coefficients of the Taylor series

\begin{equation}
\text{sech}(t) = \sum_{n=0}^{\infty} \frac{E_n}{n!} t^n.
\end{equation}

The Euler numbers are closely related to Bernoulli numbers and Bernoulli polynomials. They can also be evaluated in terms of Euler polynomials (see eulerpoly()) as $E_n=2^n E_n(1/2)$.

Examples

Euler numbers grow very rapidly. eulernum() efficiently computes numerical approximations for large indices:

\lstset{language={Python}}
\begin{lstlisting}
>>> eulernum(50)
-6.053285248188621896314384e+54
>>> eulernum(1000)
3.887561841253070615257336e+2371
>>> eulernum(10**20)
4.346791453661149089338186e+1936958564106659551331
\end{lstlisting}

Pass exact=True to obtain exact values of Euler numbers as integers:

\lstset{language={Python}}
\begin{lstlisting}
>>> print(eulernum(50, exact=True))
-6053285248188621896314383785111649088103498225146815121
>>> print(eulernum(200, exact=True) % 10**10)
1925859625
>>> eulernum(1001, exact=True)
0
\end{lstlisting}


\subsection{Euler polynomials}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{eulerpoly? mpNum? the Euler polynomial $E_n(z)$}
	{n? mpNum? A real or complex number.}
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Euler polynomial $E_n(z)$ is defined by the generating function representation

\begin{equation}
\frac{2e^{zt}}{e^t +1} = \sum_{n=0}^{\infty} E_n(z) \frac{t^n}{n!}.
\end{equation}

The Euler polynomials may also be represented in terms of Bernoulli polynomials (see bernpoly()) using various formulas, for example

\begin{equation}
En(z) = \frac{2}{n+1} \left(B_n(z) - 2^{n+2} B_n(z/2)   \right)
\end{equation}

Special values include the Euler numbers $E_n=2^{n+1}E_n(1/2)$ (see eulernum()).

Examples

Evaluation for arbitrary $z$:

\lstset{language={Python}}
\begin{lstlisting}
>>> eulerpoly(2,3)
6.0
>>> eulerpoly(5,4)
423.5
>>> eulerpoly(35, 11111111112)
3.994957561486776072734601e+351
>>> eulerpoly(4, 10+20j)
(-47990.0 - 235980.0j)
>>> eulerpoly(2, '-3.5e-5')
0.000035001225
>>> eulerpoly(3, 0.5)
0.0
>>> eulerpoly(55, -10**80)
-1.0e+4400
>>> eulerpoly(5, -inf)
-inf
>>> eulerpoly(6, -inf)
+inf
\end{lstlisting}




\newpage
\section{Bell numbers and polynomials}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{bell? mpNum? the Bell polynomial $B_n(x)$}
	{n? mpNum? A non-negative integer.}
	{x? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The Bell polynomial $B_n(x)$ are feinde for $n>0$. The first few are

\begin{equation}
B_0(x) = 1; \quad B_1(x)=x; \quad B_2(x) = x^2+x; \quad B_3(x) = x^3+3x^2+x.
\end{equation}

If $x=1$ or bell() is called with only one argument, it gives the $n$-th Bell number $B_n$, which is the number of partitions of a set with $n$ elements. By setting the precision to at least  $\log_{10}B_n$ digits, bell() provides fast calculation of exact Bell numbers.

In general, bell() computes

\begin{equation}
B_n(x) = e^{-x} \left(\text{sinc}(\pi n) + E_n(x)  \right)
\end{equation}

where $E_n(x)$ is the generalized exponential function implemented by polyexp(). This is an extension of Dobinski's formula [1], where the modification is the sinc term ensuring that $B_n(x)$ is continuous in $n$ ; bell() can thus be evaluated, differentiated, etc for arbitrary complex arguments.

Examples

Simple evaluations:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> bell(0, 2.5)
1.0
>>> bell(1, 2.5)
2.5
>>> bell(2, 2.5)
8.75
\end{lstlisting}

Evaluation for arbitrary complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> bell(5.75+1j, 2-3j)
(-10767.71345136587098445143 - 15449.55065599872579097221j)
\end{lstlisting}



\newpage
\section{Stirling numbers}

\subsection{Stirling number of the first kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{stirling1? mpNum? the Stirling number of the first kind $s(n,k)$}
	{n? mpNum? A real or complex number.}
	{k? mpNum? A real or complex number.}	
	{Keywords? String? exact=False.}	
\end{mpFunctionsExtract}

The Stirling number of the first kind $s(n,k)$ is defined by

\begin{equation}
x(x-1)(x-2)\cdots(x-n+1) = \sum_{k=0}^n s(n,k) x^k.
\end{equation}

The value is computed using an integer recurrence. The implementation is not optimized for approximating large values quickly.

Examples

Comparing with the generating function:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> taylor(lambda x: ff(x, 5), 0, 5)
[0.0, 24.0, -50.0, 35.0, -10.0, 1.0]
>>> [stirling1(5, k) for k in range(6)]
[0.0, 24.0, -50.0, 35.0, -10.0, 1.0]
\end{lstlisting}

Pass exact=True to obtain exact values of Stirling numbers as integers:

\lstset{language={Python}}
\begin{lstlisting}
>>> stirling1(42, 5)
-2.864498971768501633736628e+50
>>> print stirling1(42, 5, exact=True)
-286449897176850163373662803014001546235808317440000
\end{lstlisting}



\subsection{Stirling number of the second kind}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{stirling2? mpNum? the Stirling number of the second kind $s(n,k)$}
	{n? mpNum? A real or complex number.}
	{k? mpNum? A real or complex number.}	
	{Keywords? String? exact=False.}	
\end{mpFunctionsExtract}


The Stirling number of the second kind $S(n,k)$ is defined by

\begin{equation}
x^n = \sum_{k=0}^n S(n,k) x(x-1)(x-2)\cdots(x-k+1).
\end{equation}

The value is computed using integer arithmetic to evaluate a power sum. The implementation is not optimized for approximating large values quickly.

Examples

Comparing with the generating function:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> taylor(lambda x: sum(stirling2(5,k) * ff(x,k) for k in range(
[0.0, 0.0, 0.0, 0.0, 0.0, 1.0]
\end{lstlisting}

Pass exact=True to obtain exact values of Stirling numbers as integers:

\lstset{language={Python}}
\begin{lstlisting}
>>> stirling2(52, 10)
2.641822121003543906807485e+45
>>> print stirling2(52, 10, exact=True)
2641822121003543906807485307053638921722527655
\end{lstlisting}




\newpage
\section{Prime counting functions}

\subsection{Exact prime counting function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{primepi? mpNum? the prime counting function}
	{x? mpNum? A real number}	
\end{mpFunctionsExtract}

\vpara
The prime counting function, $\pi(x)$, gives the number of primes less than or equal to $x$. The argument $x$ may be fractional.

The prime counting function is very expensive to evaluate precisely for large $x$, and the present implementation is not optimized in any way. For numerical approximation of the prime counting function, it is better to use primepi2() or riemannr().

Some values of the prime counting function:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> [primepi(k) for k in range(20)]
[0, 0, 1, 2, 2, 3, 3, 4, 4, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 8]
>>> primepi(3.5)
2
>>> primepi(100000)
9592
\end{lstlisting}


\subsection{Prime counting function interval}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{primepi2? mpNum? an interval (as an mpi instance) providing bounds for the value of the prime counting function $\pi(x)$}
	{x? mpNum? A real number}	
\end{mpFunctionsExtract}

\vpara
For small $x$, primepi2() returns an exact interval based on the output of primepi(). For $x>2656$, a loose interval based on Schoenfeld's inequality

\begin{equation}
|\pi(x)|-\text{li}(x) < \frac{\sqrt{x}\log x}{8\pi}
\end{equation}

is returned. This estimate is rigorous assuming the truth of the Riemann hypothesis, and can be computed very quickly.

Examples

Exact values of the prime counting function for small $x$:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> iv.dps = 15; iv.pretty = True
>>> primepi2(10)
[4.0, 4.0]
>>> primepi2(100)
[25.0, 25.0]
>>> primepi2(1000)
[168.0, 168.0]
\end{lstlisting}

Loose intervals are generated for moderately large $x$:

\lstset{language={Python}}
\begin{lstlisting}
>>> primepi2(10000), primepi(10000)
([1209.0, 1283.0], 1229)
>>> primepi2(50000), primepi(50000)
([5070.0, 5263.0], 5133)
\end{lstlisting}

As $x$ increases, the absolute error gets worse while the relative error improves. The exact value of $\pi(10^{23})$ is 1925320391606803968923, and primepi2() gives 9 significant digits:

\lstset{language={Python}}
\begin{lstlisting}
>>> p = primepi2(10**23)
>>> p
[1.9253203909477020467e+21, 1.925320392280406229e+21]
>>> mpf(p.delta) / mpf(p.a)
6.9219865355293e-10
\end{lstlisting}


A more precise, nonrigorous estimate for $\pi(x)$ can be obtained using the Riemann R function (riemannr()). For large enough $x$, the value returned by primepi2() essentially amounts to a small perturbation of the value returned by riemannr():

\lstset{language={Python}}
\begin{lstlisting}
>>> primepi2(10**100)
[4.3619719871407024816e+97, 4.3619719871407032404e+97]
>>> riemannr(10**100)
4.3619719871407e+97
\end{lstlisting}



\subsection{ Riemann R function}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{riemannr? mpNum? the Riemann R function, a smooth approximation of the prime counting function $\pi(x)$}
	{x? mpNum? A real number}	
\end{mpFunctionsExtract}

\vpara
The Riemann R function gives a fast numerical approximation useful e.g. to roughly estimate the number of primes in a given interval (see primepi()).

The Riemann R function is computed using the rapidly convergent Gram series,

\begin{equation}
R(x) = 1 + \sum_{k=1}^{\infty} \frac{\log^k x}{k k! \zeta(k+1)}.
\end{equation}

From the Gram series, one sees that the Riemann R function is a well-defined analytic function (except for a branch cut along the negative real half-axis); it can be evaluated for arbitrary real or complex arguments.

The Riemann R function gives a very accurate approximation of the prime counting function. For example, it is wrong by at most 2 for $x<1000$, and for $x=10^9$ differs from the exact value of $\pi(x)$ by 79, or less than two parts in a million. It is about 10 times more accurate than the logarithmic integral estimate (see li()), which however is even faster to evaluate. It is orders of magnitude more accurate than the extremely fast $x/\log x$ estimate.

\vpara
For small arguments, the Riemann R function almost exactly gives the prime counting function if rounded to the nearest integer:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> primepi(50), riemannr(50)
(15, 14.9757023241462)
>>> max(abs(primepi(n)-int(round(riemannr(n)))) for n in range(100))
1
>>> max(abs(primepi(n)-int(round(riemannr(n)))) for n in range(300))
2
\end{lstlisting}

The Riemann R function can be evaluated for arguments far too large for exact determination of $\pi(x)$ to be computationally feasible with any presently known algorithm:

\lstset{language={Python}}
\begin{lstlisting}
>>> riemannr(10**30)
1.46923988977204e+28
>>> riemannr(10**100)
4.3619719871407e+97
>>> riemannr(10**1000)
4.3448325764012e+996
\end{lstlisting}

Evaluation is supported for arbitrary arguments and at arbitrary precision:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 30
>>> riemannr(7.5)
3.72934743264966261918857135136
>>> riemannr(-4+2j)
(-0.551002208155486427591793957644 + 2.16966398138119450043195899
\end{lstlisting}


\newpage
\section{Miscellaneous functions}

\subsection{Cyclotomic polynomials}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{cyclotomic? mpNum? the cyclotomic polynomial $\Phi_n(x)$}
	{n? mpNum? A real or complex number.}
	{x? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The cyclotomic polynomial $\Phi_n(x)$ is defined by

\begin{equation}
\Phi_n(x) = \prod_{\zeta} (x-\zeta)
\end{equation}

where $\zeta$ ranges over all primitive $n$-th roots of unity (see unitroots()). An equivalent representation, used for computation, is

\begin{equation}
\Phi_n(x) = \prod_{d|n}(x^d - 1)^{\mu(n/d)}
\end{equation}

where $\mu(m)$ denotes the Moebius function. The cyclotomic polynomials are integer polynomials, the first of which can be written explicitly as

\begin{equation}
\Phi_0(x) = 1; \quad \Phi_1(x) = x-1; \quad \Phi_2(x) = x+1; \quad \Phi_3(x) = x^3+x^2+1
\end{equation}
\begin{equation}
\Phi_4(x) = x^2+1; \quad \Phi_5(x) = x^4+x^3+x^2+x+1; \quad \Phi_6(x) = x^2-x+1.
\end{equation}

The coefficients of low-order cyclotomic polynomials can be recovered using Taylor expansion:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> for n in range(9):
... p = chop(taylor(lambda x: cyclotomic(n,x), 0, 10))
... print("%s %s" % (n, nstr(p[:10+1-p[::-1].index(1)])))
...
0 [1.0]
1 [-1.0, 1.0]
2 [1.0, 1.0]
3 [1.0, 1.0, 1.0]
4 [1.0, 0.0, 1.0]
5 [1.0, 1.0, 1.0, 1.0, 1.0]
6 [1.0, -1.0, 1.0]
7 [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]
8 [1.0, 0.0, 0.0, 0.0, 1.0]
\end{lstlisting}



\newpage
\subsection{von Mangoldt function}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{mangoldt? mpNum? the von Mangoldt function}
	{n? mpNum? An integer}	
\end{mpFunctionsExtract}


The von Mangoldt function is defined as $\Lambda(n)=\log p$ if $n=p^k$ is a power of a prime, and $\Lambda(n)=0$ otherwise.

Examples

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> [mangoldt(n) for n in range(-2,3)]
[0.0, 0.0, 0.0, 0.0, 0.6931471805599453094172321]
>>> mangoldt(6)
0.0
>>> mangoldt(7)
1.945910149055313305105353
>>> mangoldt(8)
0.6931471805599453094172321
>>> fsum(mangoldt(n) for n in range(101))
94.04531122935739224600493
>>> fsum(mangoldt(n) for n in range(10001))
10013.39669326311478372032
\end{lstlisting}





\newpage
\chapter{q-functions}

\section{q-Pochhammer symbol}


\begin{mpFunctionsExtract}
	\mpFunctionThree
	{qp? mpNum? the q-Pochhammer symbol (or q-rising factorial)}
	{a? mpNum? A real or complex number.}
	{q? mpNum? A real or complex number.}	
	{n? mpNum? An integer.}		
\end{mpFunctionsExtract}

\vpara
The q-Pochhammer symbol (or q-rising factorial) is defined as

\begin{equation}
(a; q)_n = \prod_{k=0}^{n-1} (1-aq^k)
\end{equation}

where $n=\infty$ is permitted if $|q|<1$. Called with two arguments, qp(a,q) computes $(a;q)_{\infty}$; with a single argument, qp(q) computes $(q;q)_{\infty}$. The special case

\begin{equation}
\phi(q) = (q;q)_{\infty} = \prod_{k=1}^{\infty}(1-q^k) = \sum_{k=-\infty}^{\infty}(-1)^k q^{(3k^2-k)/2}
\end{equation}

is also known as the Euler function, or (up to a factor $q^{-1/24}$) the Dedekind eta function.

Examples

If $n$ is a positive integer, the function amounts to a finite product:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> qp(2,3,5)
-725305.0
>>> fprod(1-2*3**k for k in range(5))
-725305.0
>>> qp(2,3,0)
1.0
\end{lstlisting}

Complex arguments are allowed:

\lstset{language={Python}}
\begin{lstlisting}
>>> qp(2-1j, 0.75j)
(0.4628842231660149089976379 + 4.481821753552703090628793j)
\end{lstlisting}


\newpage
\section{q-gamma and factorial}

\subsection{q-gamma}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{qgamma? mpNum? the q-gamma function}
	{z? mpNum? A real or complex number.}
	{q? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}

\vpara
The q-gamma function is defined as

\begin{equation}
\Gamma_q(z) = \frac{(q;q)_{\infty}}{(q^z;q)_{\infty}} (1-q)^{1-z}.
\end{equation}

Examples

Evaluation for real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> qgamma(4,0.75)
4.046875
>>> qgamma(6,6)
121226245.0
>>> qgamma(3+4j, 0.5j)
(0.1663082382255199834630088 + 0.01952474576025952984418217j)
\end{lstlisting}


\subsection{q-factorial}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{qfac? mpNum? the  q-factorial}
	{z? mpNum? A real or complex number.}
	{q? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


The q-factorial is defined as

\begin{equation}
\left\lceil n \right\rceil_q! = (1+q)(1+q+q^2)\cdots(1+q+\cdots+q^{n-1})
\end{equation}

or more generally

\begin{equation}
[z]_q! = \frac{(q;q)_z}{(1-q)^z}
\end{equation}

Examples

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> qfac(0,0)
1.0
>>> qfac(4,3)
2080.0
>>> qfac(5,6)
121226245.0
>>> qfac(1+1j, 2+1j)
(0.4370556551322672478613695 + 0.2609739839216039203708921j)
\end{lstlisting}


\newpage
\section{Hypergeometric q-series}


\begin{mpFunctionsExtract}
	\mpFunctionFour
	{qhyper? mpNum? the hypergeometric q-series}
	{as? mpNum? A real or complex number.}
	{bs? mpNum? A real or complex number.}	
	{q? mpNum? A real or complex number.}		
	{z? mpNum? A real or complex number.}		
\end{mpFunctionsExtract}


The basic hypergeometric series or hypergeometric q-series is defined as

\begin{equation}
\text{qhyper}(A, B, q, z) = \sum_{n=0}^{\infty} \frac{(a_1;q)_n,\ldots,(a_r;q)_n)}{(b_1;q)_n,\ldots,(b_s;q)_n)} \left((-1)^n q^{\binom{n}{2}}  \right)^{1+s-r} \frac{z^n}{(q;q)_n}
\end{equation}

where $(a;q)_n$ denotes the q-Pochhammer symbol (see qp()).

Examples

Evaluation works for real and complex arguments:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 25; mp.pretty = True
>>> qhyper([0.5], [2.25], 0.25, 4)
-0.1975849091263356009534385
>>> qhyper([0.5], [2.25], 0.25-0.25j, 4)
(2.806330244925716649839237 + 3.568997623337943121769938j)
>>> qhyper([1+j], [2,3+0.5j], 0.25, 3+4j)
(9.112885171773400017270226 - 1.272756997166375050700388j)
\end{lstlisting}





\chapter{Matrix functions}

\section{Matrix exponential}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{expm? mpNum? the matrix exponential of a square matrix $A$}
	{A? mpNum? A real or complex matrix.}
	{Keywords? String? method='taylor'.}	
\end{mpFunctionsExtract}

\vpara
The matrix exponential of a square matrix $A$ is defined by the power series

\begin{equation}
\exp(A) = I + A + \frac{A^2}{2!}+ \frac{A^3}{3!} + \ldots
\end{equation}

With method='taylor', the matrix exponential is computed using the Taylor series. With method='pade', Pade approximants are used instead.

\vpara
\textbf{Examples}

Basic examples:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> expm(zeros(3))
[1.0  0.0  0.0]
[0.0  1.0  0.0]
[0.0  0.0  1.0]
>>> expm(eye(3))
[2.71828182845905               0.0               0.0]
[             0.0  2.71828182845905               0.0]
[             0.0               0.0  2.71828182845905]
>>> expm([[1,1,0],[1,0,1],[0,1,0]])
[ 3.86814500615414  2.26812870852145  0.841130841230196]
[ 2.26812870852145  2.44114713886289   1.42699786729125]
[0.841130841230196  1.42699786729125    1.6000162976327]
>>> expm([[1,1,0],[1,0,1],[0,1,0]], method='pade')
[ 3.86814500615414  2.26812870852145  0.841130841230196]
[ 2.26812870852145  2.44114713886289   1.42699786729125]
[0.841130841230196  1.42699786729125    1.6000162976327]
>>> expm([[1+j, 0], [1+j,1]])
[(1.46869393991589 + 2.28735528717884j)                        0.0]
[  (1.03776739863568 + 3.536943175722j)  (2.71828182845905 + 0.0j)]
\end{lstlisting}

Matrices with large entries are allowed:

\lstset{language={Python}}
\begin{lstlisting}
>>> expm(matrix([[1,2],[2,3]])**25)
[5.65024064048415e+2050488462815550  9.14228140091932e+2050488462815550]
[9.14228140091932e+2050488462815550  1.47925220414035e+2050488462815551]
\end{lstlisting}

The identity $\exp(A+B) = \exp(A) \exp(B)$ does not hold for noncommuting matrices:

\lstset{language={Python}}
\begin{lstlisting}
>>> A = hilbert(3)
>>> B = A + eye(3)
>>> chop(mnorm(A*B - B*A))
0.0
>>> chop(mnorm(expm(A+B) - expm(A)*expm(B)))
0.0
>>> B = A + ones(3)
>>> mnorm(A*B - B*A)
1.8
>>> mnorm(expm(A+B) - expm(A)*expm(B))
42.0927851137247
\end{lstlisting}


\newpage
\section{Matrix cosine}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{cosm? mpNum? the matrix cosine of a square matrix $A$}
	{A? mpNum? A real or complex matrix.}	
\end{mpFunctionsExtract}

\vpara
The cosine of a square matrix $A$ is defined in analogy with the matrix exponential.

Examples:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> X = eye(3)
>>> cosm(X)
[0.54030230586814               0.0               0.0]
[             0.0  0.54030230586814               0.0]
[             0.0               0.0  0.54030230586814]
>>> X = hilbert(3)
>>> cosm(X)
[ 0.424403834569555  -0.316643413047167  -0.221474945949293]
[-0.316643413047167   0.820646708837824  -0.127183694770039]
[-0.221474945949293  -0.127183694770039   0.909236687217541]
>>> X = matrix([[1+j,-2],[0,-j]])
>>> cosm(X)
[(0.833730025131149 - 0.988897705762865j)  (1.07485840848393 - 0.17192140544213j)]
[                                     0.0               (1.54308063481524 + 0.0j)]
\end{lstlisting}


\newpage
\section{Matrix sine}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{sinm? mpNum? the matrix sine of a square matrix $A$}
	{A? mpNum? A real or complex matrix.}	
\end{mpFunctionsExtract}

\vpara
The sine of a square matrix $A$ is defined in analogy with the matrix exponential.

Examples:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> X = eye(3)
>>> sinm(X)
[0.841470984807897                0.0                0.0]
[              0.0  0.841470984807897                0.0]
[              0.0                0.0  0.841470984807897]
>>> X = hilbert(3)
>>> sinm(X)
[0.711608512150994  0.339783913247439  0.220742837314741]
[0.339783913247439  0.244113865695532  0.187231271174372]
[0.220742837314741  0.187231271174372  0.155816730769635]
>>> X = matrix([[1+j,-2],[0,-j]])
>>> sinm(X)
[(1.29845758141598 + 0.634963914784736j)  (-1.96751511930922 + 0.314700021761367j)]
[                                    0.0                  (0.0 - 1.1752011936438j)]
\end{lstlisting}



\newpage
\section{Matrix square root}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{sqrtm? mpNum? a square root of a square matrix $A$}
	{A? mpNum? A real or complex matrix.}
	{Keywords? String?  mayrotate=2.}	
\end{mpFunctionsExtract}


\vpara
A square root of the square matrix $A$ is a matrix $B=A^{1/2}$ such that $B^2=A$. The square root of a matrix, if it exists, is not unique

\vpara
\textbf{Examples}:

Square roots of some simple matrices:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> sqrtm([[1,0], [0,1]])
[1.0  0.0]
[0.0  1.0]
>>> sqrtm([[0,0], [0,0]])
[0.0  0.0]
[0.0  0.0]
>>> sqrtm([[2,0],[0,1]])
[1.4142135623731  0.0]
[            0.0  1.0]
>>> sqrtm([[1,1],[1,0]])
[ (0.920442065259926 - 0.21728689675164j)  (0.568864481005783 + 0.351577584254143j)]
[(0.568864481005783 + 0.351577584254143j)  (0.351577584254143 - 0.568864481005783j)]
>>> sqrtm([[1,0],[0,1]])
[1.0  0.0]
[0.0  1.0]
>>> sqrtm([[-1,0],[0,1]])
[(0.0 - 1.0j)           0.0]
[         0.0  (1.0 + 0.0j)]
>>> sqrtm([[j,0],[0,j]])
[(0.707106781186547 + 0.707106781186547j)                                       0.0]
[                                     0.0  (0.707106781186547 + 0.707106781186547j)]
\end{lstlisting}

A square root of a rotation matrix, giving the corresponding half-angle rotation matrix:

\lstset{language={Python}}
\begin{lstlisting}
>>> t1 = 0.75
>>> t2 = t1 * 0.5
>>> A1 = matrix([[cos(t1), -sin(t1)], [sin(t1), cos(t1)]])
>>> A2 = matrix([[cos(t2), -sin(t2)], [sin(t2), cos(t2)]])
>>> sqrtm(A1)
[0.930507621912314 -0.366272529086048]
[0.366272529086048 0.930507621912314]
>>> A2
[0.930507621912314 -0.366272529086048]
[0.366272529086048 0.930507621912314]
\end{lstlisting}

The identity $(A^2)^{1/2}$ does not necessarily hold:

\lstset{language={Python}}
\begin{lstlisting}
>>> A = matrix([[4,1,4],[7,8,9],[10,2,11]])
>>> sqrtm(A**2)
[ 4.0 1.0 4.0]
[ 7.0 8.0 9.0]
[10.0 2.0 11.0]
>>> sqrtm(A)**2
[ 4.0 1.0 4.0]
[ 7.0 8.0 9.0]
[10.0 2.0 11.0]
>>> A = matrix([[-4,1,4],[7,-8,9],[10,2,11]])
>>> sqrtm(A**2)
[ 7.43715112194995 -0.324127569985474 1.8481718827526]
[-0.251549715716942 9.32699765900402 2.48221180985147]
[ 4.11609388833616 0.775751877098258 13.017955697342]
>>> chop(sqrtm(A)**2)
[-4.0 1.0 4.0]
[ 7.0 -8.0 9.0]
[10.0 2.0 11.0]
\end{lstlisting}

For some matrices, a square root does not exist:

\lstset{language={Python}}
\begin{lstlisting}
>>> sqrtm([[0,1], [0,0]])
Traceback (most recent call last):
...
ZeroDivisionError: matrix is numerically singular
\end{lstlisting}

Two examples from the documentation for Matlab's sqrtm:

\lstset{language={Python}}
\begin{lstlisting}
>>> mp.dps = 15; mp.pretty = True
>>> sqrtm([[7,10],[15,22]])
[1.56669890360128 1.74077655955698]
[2.61116483933547 4.17786374293675]
>>>
>>> X = matrix(\
... [[5,-4,1,0,0],
... [-4,6,-4,1,0],
... [1,-4,6,-4,1],
... [0,1,-4,6,-4],
... [0,0,1,-4,5]])
>>> Y = matrix(\
... [[2,-1,-0,-0,-0],
... [-1,2,-1,0,-0],
... [0,-1,2,-1,0],
... [-0,0,-1,2,-1],
... [-0,-0,-0,-1,2]])
>>> mnorm(sqrtm(X) - Y)
4.53155328326114e-19
\end{lstlisting}


\newpage
\section{Matrix logarithm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{logm? mpNum? the matrix logarithm of a square matrix $A$}
	{A? mpNum? A real or complex matrix.}	
\end{mpFunctionsExtract}


A logarithm of the square matrix $A$ is a matrix $B$ such that $\exp(B)=A$. The logarithm of a matrix, if it exists, is not unique.

\vpara
\textbf{Examples}:

Logarithms of some simple matrices:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> X = eye(3)
>>> logm(X)
[0.0  0.0  0.0]
[0.0  0.0  0.0]
[0.0  0.0  0.0]
>>> logm(2*X)
[0.693147180559945                0.0                0.0]
[              0.0  0.693147180559945                0.0]
[              0.0                0.0  0.693147180559945]
>>> logm(expm(X))
[1.0  0.0  0.0]
[0.0  1.0  0.0]
[0.0  0.0  1.0]
\end{lstlisting}


A logarithm of a complex matrix:

\lstset{language={Python}}
\begin{lstlisting}
>>> X = matrix([[2+j, 1, 3], [1-j, 1-2*j, 1], [-4, -5, j]])
>>> B = logm(X)
>>> nprint(B)
[ (0.808757 + 0.107759j)    (2.20752 + 0.202762j)   (1.07376 - 0.773874j)]
[ (0.905709 - 0.107795j)  (0.0287395 - 0.824993j)  (0.111619 + 0.514272j)]
[(-0.930151 + 0.399512j)   (-2.06266 - 0.674397j)  (0.791552 + 0.519839j)]
>>> chop(expm(B))
[(2.0 + 1.0j)           1.0           3.0]
[(1.0 - 1.0j)  (1.0 - 2.0j)           1.0]
[        -4.0          -5.0  (0.0 + 1.0j)]
\end{lstlisting}


A matrix $X$ close to the identity matrix, for which $\log(\exp(X))=\exp(\log(X))=X$ holds:

\lstset{language={Python}}
\begin{lstlisting}
>>> X = eye(3) + hilbert(3)/4
>>> X
[              1.25             0.125  0.0833333333333333]
[             0.125  1.08333333333333              0.0625]
[0.0833333333333333            0.0625                1.05]
>>> logm(expm(X))
[              1.25             0.125  0.0833333333333333]
[             0.125  1.08333333333333              0.0625]
[0.0833333333333333            0.0625                1.05]
>>> expm(logm(X))
[              1.25             0.125  0.0833333333333333]
[             0.125  1.08333333333333              0.0625]
[0.0833333333333333            0.0625                1.05]
\end{lstlisting}

A logarithm of a rotation matrix, giving back the angle of the rotation:

\lstset{language={Python}}
\begin{lstlisting}
>>> t = 3.7
>>> A = matrix([[cos(t),sin(t)],[-sin(t),cos(t)]])
>>> chop(logm(A))
[             0.0  -2.58318530717959]
[2.58318530717959                0.0]
>>> (2*pi-t)
2.58318530717959
\end{lstlisting}

For some matrices, a logarithm does not exist:

\lstset{language={Python}}
\begin{lstlisting}
>>> logm([[1,0], [0,0]])
Traceback (most recent call last):
...
ZeroDivisionError: matrix is numerically singular
\end{lstlisting}

Logarithm of a matrix with large entries:

\lstset{language={Python}}
\begin{lstlisting}
>>> logm(hilbert(3) * 10**20).apply(re)
[ 45.5597513593433 1.27721006042799 0.317662687717978]
[ 1.27721006042799 42.5222778973542 2.24003708791604]
[0.317662687717978 2.24003708791604 42.395212822267]
\end{lstlisting}


\newpage
\section{Matrix power}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{powm? mpNum? $A^r=\exp(A \log r)$ for a matrix $A$ and complex number $r$}
	{A? mpNum? A real or complex matrix.}	
	{r? mpNum? A real or complex number.}	
\end{mpFunctionsExtract}

\vpara
Computes $A^r=\exp(A \log r)$ for a matrix $A$ and complex number $r$.

\vpara
\textbf{Examples}

Powers and inverse powers of a matrix:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import *
>>> mp.dps = 15; mp.pretty = True
>>> A = matrix([[4,1,4],[7,8,9],[10,2,11]])
>>> powm(A, 2)
[ 63.0 20.0 69.0]
[174.0 89.0 199.0]
[164.0 48.0 179.0]
>>> chop(powm(powm(A, 4), 1/4.))
[ 4.0 1.0 4.0]
[ 7.0 8.0 9.0]
[10.0 2.0 11.0]
>>> powm(extraprec(20)(powm)(A, -4), -1/4.)
[ 4.0 1.0 4.0]
[ 7.0 8.0 9.0]
[10.0 2.0 11.0]
>>> chop(powm(powm(A, 1+0.5j), 1/(1+0.5j)))
[ 4.0 1.0 4.0]
[ 7.0 8.0 9.0]
[10.0 2.0 11.0]
>>> powm(extraprec(5)(powm)(A, -1.5), -1/(1.5))
[ 4.0 1.0 4.0]
[ 7.0 8.0 9.0]
[10.0 2.0 11.0]
\end{lstlisting}

A Fibonacci-generating matrix:

\lstset{language={Python}}
\begin{lstlisting}
>>> powm([[1,1],[1,0]], 10)
[89.0  55.0]
[55.0  34.0]
>>> fib(10)
55.0
>>> powm([[1,1],[1,0]], 6.5)
[(16.5166626964253 - 0.0121089837381789j)  (10.2078589271083 + 0.0195927472575932j)]
[(10.2078589271083 + 0.0195927472575932j)  (6.30880376931698 - 0.0317017309957721j)]
>>> (phi**6.5 - (1-phi)**6.5)/sqrt(5)
(10.2078589271083 - 0.0195927472575932j)
>>> powm([[1,1],[1,0]], 6.2)
[ (14.3076953002666 - 0.008222855781077j)  (8.81733464837593 + 0.0133048601383712j)]
[(8.81733464837593 + 0.0133048601383712j)  (5.49036065189071 - 0.0215277159194482j)]
>>> (phi**6.2 - (1-phi)**6.2)/sqrt(5)
(8.81733464837593 - 0.0133048601383712j)
\end{lstlisting}



















\chapter{Eigensystems and related Decompositions}


\section{Singular value decomposition}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{svd? mpNum? the singular value decomposition of matrix A}
	{A? mpNum? A real or complex number.}
	{Keywords? String? compute\_uv = True.}	
\end{mpFunctionsExtract}

\vpara
The routines svd\_r and svd\_c compute the singular value decomposition of a real or complex matrix A. svd is an unified interface calling either svd\_r or svd\_c depending on whether $A$ is real or complex.

Given $A$, two orthogonal ($A$ real) or unitary ($A$ complex) matrices $U$ and $V$ are calculated such that

\begin{equation}
A=USV; \quad U'U=1; \quad VV'=1,
\end{equation}

where $S$ is a suitable shaped matrix whose off-diagonal elements are zero. Here ' denotes the hermitian transpose (i.e. transposition and complex conjugation). The diagonal elements of $S$ are the singular values of $A$, i.e. the square roots of the eigenvalues of $A'A$ or $AA'$.

Examples:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import mp
>>> A = mp.matrix([[2, -2, -1], [3, 4, -2], [-2, -2, 0]])
>>> S = mp.svd_r(A, compute_uv = False)
>>> print S
[6.0]
[3.0]
[1.0]
>>> U, S, V = mp.svd_r(A)
>>> print mp.chop(A - U * mp.diag(S) * V)
[0.0 0.0 0.0]
[0.0 0.0 0.0]
[0.0 0.0 0.0]
\end{lstlisting}





\newpage
\section{The Schur decomposition}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{schur? mpNum? the Schur decomposition of a square matrix $A$}
	{A? mpNum? A real or complex matrix.}	
\end{mpFunctionsExtract}


\vpara
This function computes the Schur decomposition of a square matrix $A$. Given $A$, a unitary matrix $Q$ is determined such that

\begin{equation}
Q'AQ=R; \quad Q'Q=QQ'=1,
\end{equation}

where $R$ is an upper right triangular matrix. Here ' denotes the hermitian transpose (i.e. transposition and conjugation).

Examples:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import mp
>>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])
>>> Q, R = mp.schur(A)
>>> mp.nprint(R, 3)
[2.0 0.417 -2.53]
[0.0 4.0 -4.74]
[0.0 0.0 9.0]
>>> print(mp.chop(A - Q * R * Q.transpose_conj()))
[0.0 0.0 0.0]
[0.0 0.0 0.0]
[0.0 0.0 0.0]
\end{lstlisting}




\newpage
\section{The eigenvalue problem}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{eig? mpNum? the solution of the (ordinary) eigenvalue problem for a real or complex square matrix $A$}
	{A? mpNum? A real or complex number.}
	{Keywords? String? left = False, right = False.}	
\end{mpFunctionsExtract}

\vpara
The routine eig solves the (ordinary) eigenvalue problem for a real or complex square matrix $A$. Given $A$, a vector $E$ and matrices $ER$ and $EL$ are calculated such that

\lstset{language={Python}}
\begin{lstlisting}
A ER[:,i] = E[i] ER[:,i]
EL[i,:] A = EL[i,:] E[i]
\end{lstlisting}

$E$ contains the eigenvalues of $A$. The columns of $ER$ contain the right eigenvectors of $A$ whereas the rows of $EL$ contain the left eigenvectors.

\vpara
\textbf{Examples}

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import mp
>>> A = mp.matrix([[3, -1, 2], [2, 5, -5], [-2, -3, 7]])
>>> E, ER = mp.eig(A)
>>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))
[0.0]
[0.0]
[0.0]
>>> E, EL, ER = mp.eig(A,left = True, right = True)
>>> E, EL, ER = mp.eig_sort(E, EL, ER)
>>> mp.nprint(E)
[2.0, 4.0, 9.0]
>>> print(mp.chop(A * ER[:,0] - E[0] * ER[:,0]))
[0.0]
[0.0]
[0.0]
>>> print(mp.chop( EL[0,:] * A - EL[0,:] * E[0]))
[0.0 0.0 0.0]
\end{lstlisting}


\newpage
\section{The symmetric eigenvalue problem}


\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{eigh? mpNum? the solution of the (ordinary) eigenvalue problem for a real symmetric or complex hermitian square matrix $A$}
	{A? mpNum? A real or complex number.}
	{Keywords? String? eigvals\_only = False.}	
\end{mpFunctionsExtract}

\vpara
The routines eigsy and eighe solve the (ordinary) eigenvalue problem for a real symmetric or complex hermitian square matrix $A$. eigh is an unified interface for these two functions calling either eigsy or eighe depending on whether $A$ is real or complex.

Given $A$, an orthogonal ($A$ real) or unitary matrix $Q$ ($A$ complex) is calculated which diagonalizes $A$:

\begin{equation}
Q'AQ = \text{diag}(E); \quad Q'Q=Q'Q=1.
\end{equation}

Here diag($E$) a is diagonal matrix whose diagonal is $E$. ' denotes the hermitian transpose (i.e. ordinary transposition and complex conjugation).

The columns of $Q$ are the eigenvectors of $A$ and $E$ contains the eigenvalues:

\lstset{language={Python}}
\begin{lstlisting}
A Q[:,i] = E[i] Q[:,i]
\end{lstlisting}

Examples:

\lstset{language={Python}}
\begin{lstlisting}
>>> from mpFormulaPy import mp
>>> A = mp.matrix([[3, 2], [2, 0]])
>>> E = mp.eigsy(A, eigvals_only = True)
>>> print E
[-1.0]
[ 4.0]
>>> A = mp.matrix([[1, 2], [2, 3]])
>>> E, Q = mp.eigsy(A)                     # alternative: E, Q = mp.eigh(A)
>>> print mp.chop(A * Q[:,0] - E[0] * Q[:,0])
[0.0]
[0.0]
>>> A = mp.matrix([[1, 2 + 5j], [2 - 5j, 3]])
>>> E, Q = mp.eighe(A)                     # alternative: E, Q = mp.eigh(A)
>>> print mp.chop(A * Q[:,0] - E[0] * Q[:,0])
[0.0]
[0.0]
\end{lstlisting}



