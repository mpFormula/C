
\chapter{GMP, MPD,  and related libraries: an overview}




\section{Integer Types and Fractions}

\section{FloatingPoint Types}
\label{FloatingPointTypes}

\subsection{Fixed Single Precision}
The IEEE 754 standard specifies a binary32 as having:

Sign bit: 1 bit
Exponent width: 8 bits
Significand precision: 24 (23 explicitly stored)
This gives from 6 to 9 significant decimal digits precision (if a decimal string with at most 6 significant decimal is converted to IEEE 754 single precision and then converted back to the same number of significant decimal, then the final string should match the original; and if an IEEE 754 single precision is converted to a decimal string with at least 9 significant decimal and then converted back to single, then the final number must match the original [3]).

Sign bit determines the sign of the number, which is the sign of the significand as well. Exponent is either an 8 bit signed integer from −128 to 127 (2's Complement) or an 8 bit unsigned integer from 0 to 255 which is the accepted biased form in IEEE 754 binary32 definition. For this case an exponent value of 127 represents the actual zero.

The true significand includes 23 fraction bits to the right of the binary point and an implicit leading bit (to the left of the binary point) with value 1 unless the exponent is stored with all zeros. Thus only 23 fraction bits of the significand appear in the memory format but the total precision is 24 bits (equivalent to log10(224) ≈ 7.225 decimal digits).  See \cite{Kahan_1997}.


\subsection{Fixed Double Precision}
Double-precision binary floating-point is a commonly used format on PCs, due to its wider range over single-precision floating point, in spite of its performance and bandwidth cost. As with single-precision floating-point format, it lacks precision on integer numbers when compared with an integer format of the same size. It is commonly known simply as double. The IEEE 754 standard specifies a binary64 as having:

Sign bit: 1 bit
Exponent width: 11 bits
Significand precision: 53 bits (52 explicitly stored)
This gives from 15–17 significant decimal digits precision. If a decimal string with at most 15 significant digits is converted to IEEE 754 double precision representation and then converted back to a string with the same number of significant digits, then the final string should match the original; and if an IEEE 754 double precision is converted to a decimal string with at least 17 significant digits and then converted back to double, then the final number must match the original (see \cite{Kahan_1997}).







\section{Arithmetic Operators}
\label{FpArithmeticOperators}

\subsection{Addition }
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator \textbf{+}}\index{Multiprecision Functions!+} \\
	\midrule
	\textsf{Function \textbf{.Plus}(\textbf{a} As mpNum, \textbf{b} As mpNum) As mpNum}\index{Multiprecision Functions!.Plus} \\
	\textsf{Function \textbf{.PlusInt}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.PlusInt} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary operator + is used to return the sum of the 2 operands $a$ and $b$, and assign the result to $c$: \textsf{c = a + b}.

For languages not supporting operator overloading, the function \textsf{.Plus} can be used to achieve the same: \textsf{c = a.Plus(b)}

The function \textsf{.PlusInt}  can be used if the second operand is an integer: \textsf{c = a.PlusInt(b)}



\subsection{Substraction}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator \textbf{$-$}}\index{Multiprecision Functions!$-$} \\
	\midrule
	\textsf{Function \textbf{.Minus}(\textbf{a} As mpNum, \textbf{b} As mpNum) As mpNum}\index{Multiprecision Functions!.Minus} \\
	\textsf{Function \textbf{.MinusInt}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.MinusInt} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary operator $-$ is used to return the difference of the 2 operands $a$ and $b$, and assign the result to $c$: \textsf{c = a - b}.

For languages not supporting operator overloading, the function \textsf{.Minus} can be used to achieve the same: \textsf{c = a.Minus(b)}

The function \textsf{.MinusInt}  can be used if the second operand is an integer: \textsf{c = a.MinusInt(b)}






\subsection{Multiplication (Scalars, Vectors and Matrices)}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator \textbf{*}}\index{Multiprecision Functions!*} \\
	\midrule
	\textsf{Function \textbf{.Times}(\textbf{a} As mpNum, \textbf{b} As mpNum) As mpNum}\index{Multiprecision Functions!.Times} \\
	\textsf{Function \textbf{.TimesInt}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.TimesInt} \\
	
	\textsf{Function \textbf{.TimesMat}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.TimesMat} \\
	\textsf{Function \textbf{.DotProd}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.DotProd} \\
	\textsf{Function \textbf{.LSH}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.LSH} \\
	
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary operator $*$ is used to return the product of the 2 operands $a$ and $b$, and assign the result to $c$: \textsf{c = a * b}.

For languages not supporting operator overloading, the function \textsf{.Times} can be used to achieve the same: \textsf{c = a.Times(b)}

The function \textsf{.TimesInt}  can be used if the second operand is an integer: \textsf{c = a.TimesInt(b)}






\subsection{Scalar Division }
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator \textbf{/}}\index{Multiprecision Functions!/} \\
	\midrule
	\textsf{Function \textbf{.Div}(\textbf{a} As mpNum, \textbf{b} As mpNum) As mpNum}\index{Multiprecision Functions!.Div} \\
	\textsf{Function \textbf{.DivInt}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.DivInt} \\
	\textsf{Function \textbf{.RSH}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.RSH} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary operator $/$ is used to return the quotient of the 2 operands $a$ and $b$, and assign the result to $c$: \textsf{c = a / b}.

For languages not supporting operator overloading, the function \textsf{.Div} can be used to achieve the same: \textsf{c = a.Div(b)}

The function \textsf{.DivInt}  can be used if the second operand is an integer: \textsf{c = a.DivInt(b)}





\subsection{Modulo }
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator \textbf{mod}}\index{Multiprecision Functions!mod} \\
	\midrule
	\textsf{Function \textbf{.Mod}(\textbf{a} As mpNum, \textbf{b} As mpNum) As mpNum}\index{Multiprecision Functions!.Mod} \\
	\textsf{Function \textbf{.ModInt}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.ModInt} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary operator \textsf{mod} is used to return the modulo of the 2 operands $a$ and $b$, and assign the result to $c$: \textsf{c = a mod b}.

For languages not supporting operator overloading, the function \textsf{.Mod} can be used to achieve the same: \textsf{c = a.Mod(b)}

The function \textsf{.ModInt}  can be used if the second operand is an integer: \textsf{c = a.ModInt(b)}





\subsection{Power}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator \textbf{\^}}\index{Multiprecision Functions!\^} \\
	\midrule
	\textsf{Function \textbf{.Pow}(\textbf{a} As mpNum, \textbf{b} As mpNum) As mpNum}\index{Multiprecision Functions!.Pow} \\
	\textsf{Function \textbf{.PowInt}(\textbf{a} As mpNum, \textbf{b} As Integer) As mpNum}\index{Multiprecision Functions!.PowInt} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary operator \textsf{\^} is used to return $a$ raised to the power of $b$, and assign the result to $c$:

\textsf{c = a} \textsf{\^} \textsf{b}.

For languages not supporting operator overloading, the function \textsf{.Pow} can be used to achieve the same: \textsf{c = a.Pow(b)}

The function \textsf{.PowInt}  can be used if the second operand is an integer: \textsf{c = a.PowInt(b)}









\section{Comparison Operators and Sorting}
\label{FpComparisonOperators}




\subsection{Equal}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator $\boldsymbol{=}$} (VB.NET)\index{Multiprecision Functions!=} \\
	\textsf{Operator $\boldsymbol{==}$} (C\#)\index{Multiprecision Functions!=} \\
	\midrule
	\textsf{Function \textbf{.EQ}(\textbf{a} As mpNum, \textbf{b} As mpNum) As Boolean}\index{Multiprecision Functions!.EQ} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary logical operator \textsf{=} returns TRUE if  $a = b$ and FALSE otherwise, e.g.: 

\textsf{if (a = b) then}

For languages not supporting operator overloading, the function \textsf{.EQ} can be used to achieve the same, e.g.: 

\textsf{if a.EQ(b) then}






\subsection{Greater or equal}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator $\boldsymbol{>=}$}\index{Multiprecision Functions!=} \\
	\midrule
	\textsf{Function \textbf{.GE}(\textbf{a} As mpNum, \textbf{b} As mpNum) As Boolean}\index{Multiprecision Functions!.GE} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary logical operator $\boldsymbol{>=}$ returns TRUE if  $a \geq b$ and FALSE otherwise, e.g.: 

\textsf{if (a $>$= b) then}

For languages not supporting operator overloading, the function \textsf{.GE} can be used to achieve the same, e.g.: 

\textsf{if a.GE(b) then}




\subsection{Greater than}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator $\boldsymbol{>}$}\index{Multiprecision Functions!=} \\
	\midrule
	\textsf{Function \textbf{.GT}(\textbf{a} As mpNum, \textbf{b} As mpNum) As Boolean}\index{Multiprecision Functions!.GT} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary logical operator $\boldsymbol{>}$ returns TRUE if  $a > b$ and FALSE otherwise, e.g.: 

\textsf{if (a $>$ b) then}

For languages not supporting operator overloading, the function \textsf{.GT} can be used to achieve the same, e.g.: 

\textsf{if a.GT(b) then}






\subsection{Less or equal}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator $\boldsymbol{<=}$}\index{Multiprecision Functions!=} \\
	\midrule
	\textsf{Function \textbf{.LE}(\textbf{a} As mpNum, \textbf{b} As mpNum) As Boolean}\index{Multiprecision Functions!.LE} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary logical operator $\boldsymbol{<=}$ returns TRUE if  $a \leq b$ and FALSE otherwise, e.g.: 

\textsf{if (a $<$= b) then}

For languages not supporting operator overloading, the function \textsf{.LE} can be used to achieve the same, e.g.: 

\textsf{if a.LE(b) then}






\subsection{Less than}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator $\boldsymbol{<}$}\index{Multiprecision Functions!=} \\
	\midrule
	\textsf{Function \textbf{.LT}(\textbf{a} As mpNum, \textbf{b} As mpNum) As Boolean}\index{Multiprecision Functions!.LT} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary logical operator $\boldsymbol{>}$ returns TRUE if  $a < b$ and FALSE otherwise, e.g.: 

\textsf{if (a $<$ b) then}

For languages not supporting operator overloading, the function \textsf{.LT} can be used to achieve the same, e.g.: 

\textsf{if a.LT(b) then}




\subsection{Not equal}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Operator $\boldsymbol{<>}$} (VB.NET)\index{Multiprecision Functions!=} \\
	\textsf{Operator $\boldsymbol{!=}$} (C\#)\index{Multiprecision Functions!=} \\
	\midrule
	\textsf{Function \textbf{.NE}(\textbf{a} As mpNum, \textbf{b} As mpNum) As Boolean}\index{Multiprecision Functions!.NE} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
The binary logical operator $\boldsymbol{<>}$ returns TRUE if  $a \neq b$ and FALSE otherwise, e.g.: 

\textsf{if (a $<>$ b) then}

For languages not supporting operator overloading, the function \textsf{.NE} can be used to achieve the same, e.g.: 

\textsf{if a.NE(b) then}


%
%
%\subsection{GESTEP}
%\label{GESTEP} \index{Spreadsheet Functions!GESTEP}
%\begin{tabular}{p{481pt}}
%\toprule
%\textsf{Function \textbf{GESTEP}(\textbf{Number} as mpNum, \textbf{Step} as mpNum) As mpNum}\index{Multiprecision Functions!GESTEP} \\
%\bottomrule
%\end{tabular}
%
%\vspace{0.3cm}
%The function \textsf{GESTEP} returns 1 if number $\geq$ step; returns 0 (zero) otherwise. Use this function to filter a set of values. For example, by summing several GESTEP functions you calculate the count of values that exceed a threshold.
%
%Number: The value to test against step.
%
%Step:  Optional. The threshold value. If you omit a value for step, GESTEP uses zero.
%
%
%
%
%
%\subsection{DELTA}
%\label{DELTA} \index{Spreadsheet Functions!DELTA}
%\begin{tabular}{p{481pt}}
%\toprule
%\textsf{Function \textbf{DELTA}(\textbf{Number1} as mpNum, \textbf{Number2} as mpNum) As mpNum) As mpNum}\index{Multiprecision Functions!DELTA} \\
%\bottomrule
%\end{tabular}
%
%\vspace{0.3cm}
%The function \textsf{DELTA} tests whether two values are equal. Returns 1 if Number1 = 
%Number2; returns 0 otherwise. Use this function to filter a set of values. For example, by summing several DELTA functions you calculate the count of equal pairs. This function is also known as the Kronecker Delta function.
%
%



\subsection{IsApproximate}
\lipsum[3]


\subsection{IsSmall}
\lipsum[3]




\section{Vectors, Matrices and Tables}
\label{TableProperties}

\subsection{Dimension (Vectors and Matrices)}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Property \textbf{.Rows}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Rows} \\
	\textsf{Property \textbf{.Cols}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Cols} \\
	\textsf{Property \textbf{.Size}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Size} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
\lipsum[2]



\subsection{Precision}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Property \textbf{.Prec10}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Prec10} \\
	\textsf{Property \textbf{.Prec2}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Prec2} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
\lipsum[2]



\subsection{Item}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Property \textbf{.Item}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Item} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
\lipsum[2]



\subsection{Row}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Property \textbf{.Row}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Row} \\
	\textsf{Property \textbf{.TopRows}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.TopRows} \\
	\textsf{Property \textbf{.MiddleRows}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.MiddleRows} \\
	\textsf{Property \textbf{.BottomRows}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.BottomRows} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
\lipsum[2]




\subsection{Column}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Property \textbf{.Col}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Col} \\
	\textsf{Property \textbf{.LeftCols}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.LeftCols} \\
	\textsf{Property \textbf{.MiddleCols}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.MiddleCols} \\
	\hypertarget{RightCols_HT}{}
	\textsf{Property \textbf{.RightCols}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.RightCols} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
\lipsum[2]



\hypertarget{FillLinearByStep_HT}{}
\hypertarget{SetRandomSymmetric_HT}{}
\subsection{Matrix}
\begin{tabular}{p{481pt}}
	\toprule
	
	\textsf{Property \textbf{.FillLinearByStep}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.FillLinearByStep} \\
	
	\textsf{Property \textbf{.SetRandomSymmetric}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.SetRandomSymmetric} \\
	
	
	\textsf{Property \textbf{.Block}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Block} \\
	\hypertarget{TopLeftCorner_HT}{}
	\textsf{Property \textbf{.TopLeftCorner}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.TopLeftCorner} \\
	
	\textsf{Property \textbf{.TopRightCorner}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.TopRightCorner} \\
	\textsf{Property \textbf{.BottomLeftCorner}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.BottomLeftCorner} \\
	\textsf{Property \textbf{.BottomRightCorner}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.BottomRightCorner} \\
	\textsf{Property \textbf{.Diagonal}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Diagonal} \\
	\textsf{Property \textbf{.TriangularView}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.TriangularView} \\
	\textsf{Property \textbf{.Adjoint}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.Adjoint} \\
	\textsf{Property \textbf{.AsDiagonal}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Properties!.AsDiagonal} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
\lipsum[2]





\subsection{Sorting}
\begin{tabular}{p{481pt}}
	\toprule
	\textsf{Function \textbf{.Sorted}($\boldsymbol{a}\ As\ mpNum$, $\boldsymbol{b}\ As\ mpNum$) As mpNum}\index{Multiprecision Functions!.Sorted} \\
	\bottomrule
\end{tabular}

\vspace{0.3cm}
\lipsum[1]




\subsection{Table}
\lipsum[1]


\subsection{List of Tables}
\lipsum[1]




\chapter{FMPZ}




\section{Multiprecision Rational Numbers (GMP: MPQ)}

The GMP reference is \cite{Granlund12}


GMP is a free library for arbitrary precision arithmetic, operating on signed integers, rational numbers and floating point numbers. There is no practical limit on the precision except the ones implied by the available memory in the machine GMP runs on. 

The GNU Multiple Precision Arithmetic Library (GMP) is a free library for arbitrary-precision arithmetic, operating on signed integers, rational numbers, and floating point numbers.[2] There are no practical limits to the precision except the ones implied by the available memory in the machine GMP runs on (operand dimension limit is 232-1 bits on 32-bit machines and 237 bits on 64-bit machines).[3] GMP has a rich set of functions, and the functions have a regular interface. The basic interface is for C but wrappers exist for other languages including Ada, C++, C\#, OCaml, Perl, PHP, and Python. In the past, the Kaffe Java virtual machine used GMP to support Java built-in arbitrary precision arithmetic. This feature has been removed from recent releases, causing protests from people who claim that they used Kaffe solely for the speed benefits afforded by GMP.[4] As a result, GMP support has been added to GNU Classpath.[5]

The main target applications of GMP are cryptography applications and research, Internet security applications, and computer algebra systems.

GMP aims to be faster than any other bignum library for all operand sizes. Some important factors in doing this are:

Using full words as the basic arithmetic type.
Using different algorithms for different operand sizes; algorithms that are faster for very big numbers are usually slower for small numbers.
Highly optimized assembly language code for the most important inner loops, specialized for different processors.
The first GMP release was made in 1991. It is constantly developed and maintained.[1]

GMP is part of the GNU project (although its website being off gnu.org may cause confusion), and is distributed under the GNU Lesser General Public License (LGPL).

GMP is used for integer arithmetic in many computer algebra systems such as Mathematica[6] and Maple.[7] It is also used in the Computational Geometry Algorithms Library (CGAL) because geometry algorithms tend to 'explode' when using ordinary floating point CPU math.[8]

GMP is needed to build the GNU Compiler Collection (GCC).[9]



\subsubsection{mpz input}

int mpz\_set\_str (mpz t rop, const char *str, int base)
Set the value of rop from str, a null-terminated C string in base base. White space is allowed
in the string, and is simply ignored.
The base may vary from 2 to 62, or if base is 0, then the leading characters are used: 0x and
0X for hexadecimal, 0b and 0B for binary, 0 for octal, or decimal otherwise.
For bases up to 36, case is ignored; upper-case and lower-case letters have the same value. For
bases 37 to 62, upper-case letter represent the usual 10..35 while lower-case letter represent
36..61.
This function returns 0 if the entire string is a valid number in base base. Otherwise it returns
−1.


\subsubsection{mpz output}

char * mpz\_get\_str (char *str, int base, const mpz t op)
Convert op to a string of digits in base base. The base argument may vary from 2 to 62 or
from −2 to −36.
For base in the range 2..36, digits and lower-case letters are used; for −2..−36, digits and
upper-case letters are used; for 37..62, digits, upper-case letters, and lower-case letters (in
that signifi cance order) are used.

If str is NULL, the result string is allocated using the current allocation function (see
Chapter 13 [Custom Allocation], page 86). The block will be strlen(str)+1 bytes, that
being exactly enough for the string and null-terminator.
If str is not NULL, it should point to a block of storage large enough for the result, that being
mpz\_sizeinbase (op, base) + 2. The two extra bytes are for a possible minus sign, and the
null-terminator.
A pointer to the result string is returned, being either the allocated block, or the given str.




%\chapter{Elementary Functions Related To Integers}
\label{FunctionsReturningIntegers} 
%\lipsum[2-3]

Book reference: \cite{Shoup2009}

Background on discrete applied algebra: \cite{Hardy_2009}





\section{Arithmetic Operators }
\label{ArithmeticOperatorsInt}



\subsection{Unary Minus}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intNeg? mpNum?  $-n$}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}



\subsection{Addition}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intAdd? mpNum?  $n_1 + n_2.$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The function \textsf{intAdd$(n_1, n_2)$} returns the sum of $n_1$ and $n_2$: 
\begin{equation}
	\textsf{intAdd}(n_1, n_2) =n_1 + n_2.
\end{equation}



\subsection{Subtraction}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intSub? mpNum?  $n_1 - n_2.$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The function \textsf{intSub$(n_1, n_2)$} returns the difference of $n_1$ and $n_2$: 
\begin{equation}
	\textsf{intSub}(n_1, n_2) =n_1 - n_2.
\end{equation}



\subsection{Multiplication}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intMul? mpNum?  $n_1  \times n_2$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The function \textsf{intMul$(n_1, n_2)$} returns the product of $n_1$ and $n_2$: 
\begin{equation}
	\textsf{intMul}(n_1, n_2) =n_1 \times n_2.
\end{equation}



\subsection{Fused-Multiply-Add fma}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intFma? mpNum? $(n_1 \times n_2) + n_3$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
	{n3? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The function \textsf{intFma$(n_1, n_2, n_3)$} returns the product of $n_1$ and $n_2$, plus $n_3$: 
\begin{equation}
	\textsf{intFma}(n_1, n_2, n_3) =(n_1 \times n_2) + n_3.
\end{equation}




\subsection{Fused-Multiply-Subtract fms}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intFms? mpNum? $(n_1 \times n_2) - n_3$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
	{n3? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The function \textsf{intFms$(n_1, n_2, n_3)$} returns the product of $n_1$ and $n_2$, minus $n_3$: 
\begin{equation}
	\textsf{intFms}(n_1, n_2, n_3) =(n_1 \times n_2) - n_3.
\end{equation}



\subsection{Multiplication by multiples of 2 (LSH)}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intLSH? mpNum? the product of $n$ and $2^k$}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The function \textsf{intLSH$(n, k)$} returns the product of $n$ and $2^k$: 
\begin{equation}
	\textsf{intLSH}(n, k) =n \times 2^k.
\end{equation}
This operation can also be defined as a left shift by $k$ bits.





\subsection{Division by multiples of 2 (RSH)}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intRSH? mpNum? the quotient of $n$ and $2^k$}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The function \textsf{intRSH$(n, k)$} returns the quotient of $n$ and $2^k$: 
\begin{equation}
	\textsf{intRSH}(n, k) =n \div 2^k.
\end{equation}
This operation can also be defined as a right shift by $k$ bits.





\subsection{Exact Division}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intDivExact? mpNum? $n/d$}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns $n/d$. This function produces correct results only when it is known in advance that $d$ divides $n$. This routine is much faster than the other division functions, and is the best choice when exact division is known to occur, for example reducing a rational to lowest terms.


\subsection{Modulo Division}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intMod? mpNum? $n$ mod $d$.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
The sign of the divisor is ignored; the result is always non-negative.





\section{Divisions, forming quotients and/or remainder}
\label{DivisionsInt}

Division is undefined if the divisor is zero. Passing a zero divisor to the division or modulo
functions (including the modular powering functions), will cause an intentional division by zero. This lets a program handle arithmetic exceptions in these functions the same way as for normal integer arithmetic.

The following routines calculate $n$ divided by $d$, forming a quotient $q$ and/or remainder $r$. For the 2exp functions, $d = 2^b$ . The rounding is in three styles, each suiting different applications.


\begin{itemize}
	\item cdiv rounds $q$ up towards $+\infty$, and $r$ will have the opposite sign to $d$. The c stands for "ceil".
	\item fdiv rounds $q$ down towards $-\infty$, and $r$ will have the same sign as $d$. The f stands for "floor".
	\item tdiv rounds $q$ towards zero, and $r$ will have the same sign as $n$. The t stands for "truncate".
\end{itemize}

In all cases $q$ and $r$ will satisfy $n = qd + r$, and $r$ will satisfy $0 \leq |r| < |d|$.
The $q$ functions calculate only the quotient, the $r$ functions only the remainder, and the $qr$ functions calculate both. Note that for $qr$ the same variable cannot be passed for both $q$ and $r$, or results will be unpredictable.


\subsection{Quotient only, rounded up}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intCDivQ? mpNum? the quotient of $n$ and $d$, rounded up towards $+\infty$.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intCDivQ}
	\textsf{intCDivQ}(n, d) =\left\lceil n \div d\right\rceil.
\end{equation}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intCDivQ2exp? mpNum? the quotient of $n$ and $2^b$, rounded up towards $+\infty$.}
	{n? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intCDivQ2exp}
	\textsf{intCDivQ2exp}(n, b) =\left\lceil n \div 2^b\right\rceil.
\end{equation}





\subsection{Remainder only (Quotient rounded up)}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intCDivR? mpNum? the remainder, once the quotient of $n$ and $d$, rounded up towards $+\infty$, has been obtained.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intCDivR}
	\textsf{intCDivR}(n, d) =n - d \times \left\lceil n \div d\right\rceil.
\end{equation}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intCDivR2exp? mpNum? the remainder, once the quotient of $n$ and $2^b$, rounded up towards $+\infty$, has been obtained.}
	{n? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intCDivR2exp}
	\textsf{intCDivR2exp}(n, d) =n - 2^b \times \left\lceil n \div 2^b\right\rceil.
\end{equation}





\subsection{Quotient and Remainder,  Quotient rounded up}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intCDivQR? mpNumList[2]? the quotient of $n$ and $d$, rounded up towards $+\infty$, and the remainder.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\textsf{intCDivQR}[1] returns \textsf{intCDivQ$(n, k)$} as defined in equation \ref{eq:intCDivQ}, and \textsf{intCDivQR}[2] returns \textsf{intCDivR$(n, k)$} as defined in in equation \ref{eq:intCDivR}.





\subsection{Quotient only, rounded down}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intFDivQ? mpNum? the quotient of $n$ and $d$, rounded down towards $-\infty$.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intFDivQ}
	\textsf{intFDivQ}(n, d) =\left\lfloor n \div d\right\rfloor.
\end{equation}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intFDivQ2exp? mpNum? the quotient of $n$ and $2^b$, rounded down towards $-\infty$.}
	{n? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intFDivQ2exp}
	\textsf{intFDivQ2exp}(n, d) =\left\lfloor n \div 2^b\right\rfloor.
\end{equation}






\subsection{Remainder only (Quotient rounded down)}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intFDivR? mpNum? the remainder, once the quotient of $n$ and $d$, rounded down towards $-\infty$, has been obtained.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intFDivR}
	\textsf{intFDivR}(n, d) =n - d \times \left\lfloor n \div d\right\rfloor.
\end{equation}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intFDivR2exp? mpNum? the remainder, once the quotient of $n$ and $2^b$, rounded down towards $-\infty$, has been obtained.}
	{n? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intFDivR2exp}
	\textsf{intFDivR2exp}(n, d) =n - 2^b \times \left\lfloor n \div 2^b\right\rfloor.
\end{equation}





\subsection{Quotient and Remainder,  Quotient rounded down}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intFDivQR? mpNumList[2]? the quotient of $n$ and $d$, rounded down towards $-\infty$, and the remainder.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\textsf{intFDivQR}[1] returns \textsf{intFDivQ$(n, k)$} as defined in equation \ref{eq:intFDivQ}, and \textsf{intFDivQR}[2] returns \textsf{intFDivR$(n, k)$} as defined in in equation \ref{eq:intFDivR}.






\subsection{Quotient only, Quotient truncated}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intTDivQ? mpNum? the quotient of $n$ and $d$, rounded towards zero.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intTDivQ}
	\textsf{intTDivQ}(n, d) =\left\lfloor n \div d\right\rfloor.
\end{equation}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intTDivQ2exp? mpNum? the quotient of $n$ and $2^b$, rounded towards zero.}
	{n? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intTDivQ2exp}
	\textsf{intTDivQ2exp}(n, d) =\left\lfloor n \div 2^b\right\rfloor.
\end{equation}






\subsection{Remainder only (Quotient  truncated)}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intTDivR? mpNum? the remainder, once the quotient of $n$ and $d$,rounded towards zero, has been obtained.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intTDivR}
	\textsf{intTDivR}(n, d) =n - d \times \left[ n \div d\right].
\end{equation}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intTDivR2exp? mpNum? the remainder, once the quotient of $n$ and $2^b$, rounded towards zero, has been obtained.}
	{n? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\begin{equation}
	\label{eq:intTDivR2exp}
	\textsf{intTDivR2exp}(n, d) =n - 2^b \times \left[ n \div 2^b\right].
\end{equation}





\subsection{Quotient and Remainder,  Quotient truncated}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intTDivQr? mpNumList[2]? the quotient of $n$ and $d$, rounded towards zero, and the remainder.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\textsf{intTDivQR}[1] returns \textsf{intTDivQ$(n, k)$} as defined in equation \ref{eq:intTDivQ}, and \textsf{intTDivQR}[2] returns \textsf{intTDivR$(n, k)$} as defined in in equation \ref{eq:intTDivR}.




\section{Logical Operators }
\label{LogicalOperatorsInt}



\subsection{Bitwise AND}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intAND? mpNum? $n_1$ bitwise-and $n_2$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}






\subsection{Bitwise Inclusive OR}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intIOR? mpNum? $n_1$ bitwise-inclusive-or $n_2$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}





\subsection{Bitwise Exclusive OR}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intXOR? mpNum? $n_1$ bitwise-exclusive-or $n_2$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}








\section{Bit-Oriented Functions}
\label{BitOrientedFunctions}


\subsection{Complement}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intComplement? mpNum? the one's complement of $n$.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}




\subsection{Hamming Distance}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intHamDist? mpNum? the hamming distance between the two operands}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
If $n_1$ and $n_2$ are both $\geq 0$ or both $< 0$, return the hamming distance between the two operands, which is the number of bit positions where $n_1$ and $n_2$ have different bit values. If one operand is $\geq 0$ and the other $< 0$ then the number of bits different is infinite, and the return value is the largest possible mp\_bitcnt\_t.



\subsection{Testing , setting, and clearing a Bit}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intTestBit? mpNum? 1 or 0 according to whether bit $k$ in $n$ is set or not.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intComBit? mpNum? n with the complement bit $k$ set in $n$.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intClearBit? mpNum? $n$ with the bit $k$ cleared in $n$.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intSetBit? mpNum? $n$ with the bit $k$ set in $n$.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}




\subsection{Scanning for 0 or 1}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intScan0? mpNum? the index of the found bit 0, starting from bit $k$.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intScan1? mpNum? the index of the found bit 1, starting from bit $k$.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
Scan $n$, starting from bit $k$, towards more significant bits, until the first 0 or 1 bit (respectively) is found. Return the index of the found bit.

If the bit at starting bit is already what’s sought, then $k$ is returned.
If there’s no bit found, then the largest possible mp\_bitcnt\_t is returned. This will happen
in mpz\_scan0 past the end of a negative number, or mpz\_scan1 past the end of a nonnegative
number.



\subsection{Population Count}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intPopCount? mpNum? the population count of $n$.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
If $n \geq 0$, return the population count of $n$, which is the number of 1 bits in the binary
representation. If $n < 0$, the number of 1s is infinite, and the return value is the largest
possible mp\_bitcnt\_t.






\section{Sign, Powers and Roots}
\label{PowersAndRootsInt}


\subsection{Sign}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intSgn? mpNum? the sign of $n$.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}





\subsection{Absolute value}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intAbs? mpNum? the absolute value of $n$.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}





\subsection{\texorpdfstring{$\text{Power Function: }n^k; \quad n, k \in  \mathbb{Z}$}{powerxk}}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intPow? mpNum? the value of $n^k$. The case $0^0$ yields 1.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}





\subsection{\texorpdfstring{$\text{Power Function modulo m: }n^k \mod m;  \quad m, n, k \in  \mathbb{Z}$}{powerxk}}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intPowMod? mpNum? the value of $n^k \text{ mod } m$.}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
	{m? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns the value of $n^k \text{ mod } m;   \quad m, n, k \in  \mathbb{Z}$.

Negative $k$ is supported if an inverse $n^{-1} \text{ mod } m$ exists (see mpz\_invert in Section 5.9 [Number Theoretic Functions], page 36). If an inverse does not exist then a divide by zero is raised.



\subsection{\texorpdfstring{$\text{Truncated integer part of the square root: }\lfloor\sqrt{n}\rfloor$}{sqrt}}

\label{intSqrt}
\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intSqrt? mpNum? the truncated integer part of the square root of $n$.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns $\lfloor\sqrt{m}\rfloor$,  the truncated integer part of the square root of $m$.




\subsection{\texorpdfstring{$\text{Truncated integer part of the square root: }\lfloor\sqrt{m}\rfloor\text{, with remainder}$}{sqrt}}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intSqrtRem? mpNumList[2]? the truncated integer part of the square root of $n$, and the remainder.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\textsf{intSqrtRem}[1] returns $s = $\textsf{intSqrt$(n)$} as defined in section \ref{intSqrt}, and \textsf{intSqrtRem}[2] returns  the remainder $(m - s^2)$, which will be
zero if $m$ is a perfect square.




\subsection{\texorpdfstring{$\text{Truncated integer part of the nth root: }\lfloor\sqrt[n]{m}\rfloor$}{sqrt}}

\label{intRoot}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intRoot? mpNum? the truncated integer part of the $n^{th}$ root of $m$}
	{n? mpNum? An Integer.}
	{m? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns $\lfloor\sqrt[n]{m}\rfloor$,  the truncated integer part of the $n^{th}$ root of $m$.




\subsection{\texorpdfstring{$\text{Truncated integer part of the nth root: }\lfloor\sqrt[n]{m}\rfloor\text{, with remainder}$}{sqrt}}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intRootRem? mpNumList[2]? the truncated integer part of the $n^{th}$ root of $m$, with remainder}
	{n? mpNum? An Integer.}
	{m? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
\textsf{intRootRem}[1] returns $s = $\textsf{intSqrt$(m,n)$} as defined in section \ref{intRoot}, and \textsf{intRootRem}[2] returns  the remainder $(m - s^2)$.







\section{Numbertheoretic Functions}
\label{NumbertheoreticFunctions}



\subsection{Factorial}


\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intFactorial? mpNum?  $n!$, the factorial of $n$}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}





\subsection{Binomial Coefficient, Combinations}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intBinCoeff? mpNum? the binomial coefficient}
	{n? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns the binomial coefficient, $\binom{n}{k}$. Negative values of $n$ are supported, using the identity
\begin{equation}
	\binom{-n}{k} = (-1)^k \binom{n+k-1}{k}.
\end{equation}





\subsection{Next Prime}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intNextprime? Integer?  the next prime greater than $n$.}
	{n? Integer? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns the next prime greater than $n$. This function uses a probabilistic algorithm to identify primes. The chance of a composite passing will be extremely small.



\subsection{Greatest Common Divisor (GCD)}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intGcd? mpNum? the greatest common divisor of $n_1$ and $n_2$}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
The result is always positive even if
one or both input operands are negative. Except if both inputs are zero; then this function
defines \textsf{intGcd}(0, 0) = 0.



\subsection{Greatest Common Divisor, Extended}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intGcdExt? mpNumList[3]? the extended greatest common divisor of $n_1$ and $n_2$}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
Set \textsf{intGcdExt}[1] $=g$ to the greatest common divisor of $a$ and $b$, and in addition set \textsf{intGcdExt}[2] $=s$ and \textsf{intGcdExt}[3] $=t$ to coefficients satisfying $as + bt = g$. The value in $g$ is always positive, even if one or both of $a$ and $b$ are negative (or zero if both inputs are zero). The values in $s$ and $t$ are chosen such that normally, $|s| < |b|/(2g)$ and $|t| < |a|/(2g)$, and these relations define $s$ and $t$ uniquely. There are a few exceptional cases:

\vspace{0.3cm}
If $|a| = |b|$, then $s = 0, t = sgn(b)$.

\vspace{0.3cm}
Otherwise, $s = sgn(a)$ if $b = 0$ or $|b| = 2g$, and $t = sgn(b)$ if $a = 0$ or $|a| = 2g$.

\vspace{0.3cm}
In all cases, $s = 0$ if and only if $g = |b|$, i.e., if $b$ divides $a$ or $a = b = 0$.




\subsection{Least Common Multiple (LCM)}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intLcm? mpNum? the least common multiple of $n_1$ and $n_2$.}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}


\vspace{0.3cm}
Returns the least common multiple of $n_1$ and $n_2$. The returned value is always positive, irrespective of the signs of $n_1$ and $n_2$. The returned value  will be zero if either $n_1$ or $n_2$ is zero.





\subsection{Inverse Modulus}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intInvertMod? mpNum? the inverse of $n_1$ modulo $n_2$}
	{n1? mpNum? An Integer.}
	{n2? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns the inverse of $n_1$ modulo $n_2$. If the inverse exists, the indicator value is non-zero and the returned value will satisfy $0 < rop < |n_2|$. If an inverse does not exist the
indicator value is zero and rop is undefined. The behaviour of this function is undefined when
$n_2$ is zero.


\subsection{Remove Factor}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intRemoveFactor? mpNum? $n$ with all occurrences of the factor $f$ removed from $n$.}
	{n? mpNum? An Integer.}
	{f? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Remove all occurrences of the factor $f$ from $n$ and return the result in \textsf{intRemoveFactor}[1]. 

\textsf{intRemoveFactor}[2] contains how many such occurrences were removed.




\subsection{Legendre Symbol}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intLegendreSymbol? mpNum? the Legendre symbol $\left(\frac{a}{p}\right)$.}
	{a? mpNum? An Integer.}
	{p? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Calculate the Legendre symbol $\left(\frac{a}{p}\right)$. This is defined only for $p$ an odd positive prime, and for such $p$ it is identical to the Jacobi symbol.





\subsection{Jacobi Symbol}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intJacobiSymbol? mpNum? the Jacobi symbol $\left(\frac{a}{b}\right)$}
	{a? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Calculate the Jacobi symbol $\left(\frac{a}{b}\right)$ . This is defined only for $b$ odd.





\subsection{Kronecker Symbol}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intKroneckerSymbol? mpNum? the Kronecker symbol $\left(\frac{a}{b}\right)$}
	{a? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Calculate the Jacobi symbol $\left(\frac{a}{b}\right)$ with the Kronecker extension $\left(\frac{a}{2}\right)$ = $\left(\frac{2}{a}\right)$ when $a$ odd, or when a odd,  $\left(\frac{a}{2}\right)=0$ when $a$ even.
When $b$ is odd the Jacobi symbol and Kronecker symbol are identical.





\subsection{Fibonacci Numbers}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intFibonacci? mpNum? the $n^{th}$ Fibonacci number.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}




\subsection{Lucas Numbers}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intLucas? mpNum? the $n^{th}$ Lucas number.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}







\section{Additional Numbertheoretic Functions}
\label{AdditionalNumbertheoreticFunctions}

\subsection{Pseudoprimes}

An overview is provided by \cite{Grantham_2001}.

\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intIsBpswPrp? mpNum? True if n is a Baillie-Pomerance-Selfridge-Wagstaff probable prime.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

%is\_bpsw\_prp(...)
%
is\_bpsw\_prp(n) will return True if n is a Baillie-Pomerance-Selfridge-Wagstaff probable prime.
A BPSW probable prime passes the is\_strong\_prp() test with base 2 and the
is\_selfridge\_prp() test.


\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intIsEulerPrp? mpNum? True if n is an Euler (also known as Solovay-Strassen) probable}
	{n? mpNum? An Integer.}
	{a? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_euler\_prp(n,a) will return True if n is an Euler (also known as Solovay-Strassen) probable
prime to the base a.

Assuming:
gcd(n, a) == 1
n is odd

Then an Euler probable prime requires:

a**((n-1)/2) == 1 (mod n)


\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intIsExtraStrongLucasPrp? mpNum? True if n is an extra strong Lucas probable prime}
	{n? mpNum? An Integer.}
	{p? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_extra\_strong\_lucas\_prp(n,p) will return True if n is an extra strong Lucas probable prime
with parameters (p,1).
Assuming:
n is odd
D = p*p - 4, D != 0
gcd(n, 2*D) == 1
n = s*(2**r) + Jacobi(D,n), s odd

Then an extra strong Lucas probable prime requires:

lucasu(p,1,s) == 0 (mod n)
or
lucasv(p,1,s) == +/-2 (mod n)
or
lucasv(p,1,s*(2**t)) == 0 (mod n) for some t, 0 <= t < r




\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intIsFermatPrp? mpNum? True if n is a Fermat probable prime to the base a}
	{n? mpNum? An Integer.}
	{a? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_fermat\_prp(n,a) will return True if n is a Fermat probable prime to the base a.

Assuming:
gcd(n,a) == 1
Then a Fermat probable prime requires:
a**(n-1) == 1 (mod n)






\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intIsFibonacciPrp? mpNum? True if n is an Fibonacci probable prime with parameters (p,q).}
	{n? mpNum? An Integer.}
	{p? mpNum? An Integer.}
	{q? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_fibonacci\_prp(n,p,q) will return True if n is an Fibonacci probable prime with parameters
(p,q).
Assuming:
n is odd
p > 0, q = +/-1
p*p - 4*q != 0

Then a Fibonacci probable prime requires:
lucasv(p,q,n) == p (mod n).





\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intIsLucasPrp? mpNum? True if n is a Lucas probable prime with parameters (p,q).}
	{n? mpNum? An Integer.}
	{p? mpNum? An Integer.}
	{q? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_lucas\_prp(n,p,q) will return True if n is a Lucas probable prime with parameters (p,q).

Assuming:
n is odd
D = p*p - 4*q, D != 0
gcd(n, 2*q*D) == 1

Then a Lucas probable prime requires:

lucasu(p,q,n - Jacobi(D,n)) == 0 (mod n)



\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intIsSelfridgePrp? mpNum? True if n is a Lucas probable prime with Selfidge parameters (p,q).}
	{a? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_selfridge\_prp(n) will return True if n is a Lucas probable prime with Selfidge parameters
(p,q). The Selfridge parameters are chosen by finding the first element D in the sequence {5,
	-7, 9, -11, 13, ...} such that Jacobi(D,n) == -1. Let p=1 and q = (1-D)/4 and then perform a
Lucas probable prime test.



\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intIsStrongBpswPrp? mpNum? True if n is a strong Baillie-Pomerance-Selfridge-Wagstaff probable prime}
	{a? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_strong\_bpsw\_prp(n) will return True if n is a strong Baillie-Pomerance-Selfridge-Wagstaff
probable prime. A strong BPSW probable prime passes the is\_strong\_prp() test with base 2
and the is\_strongselfridge\_prp() test.



\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intIsStrongLucasPrp? mpNum? True if n is a strong Lucas probable prime with parameters (p,q).}
	{n? mpNum? An Integer.}
	{p? mpNum? An Integer.}
	{q? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_strong\_lucas\_prp(n,p,q) will return True if n is a strong Lucas probable prime with
parameters (p,q).

Assuming:
n is odd
D = p*p - 4*q, D != 0

gcd(n, 2*q*D) == 1
n = s*(2**r) + Jacobi(D,n), s odd
Then a strong Lucas probable prime requires:

lucasu(p,q,s) == 0 (mod n)
or
lucasv(p,q,s*(2**t)) == 0 (mod n) for some t, 0 <= t < r







\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{intIsStrongPrp? mpNum? True if n is an strong (also known as Miller-Rabin) probable prime}
	{n? mpNum? An Integer.}
	{a? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_strong\_prp(n,a) will return True if n is an strong (also known as Miller-Rabin) probable prime
to the base a.

Assuming:
gcd(n,a) == 1
n is odd
n = s*(2**r) + 1, with s odd

Then a strong probable prime requires one of the following is true:
a**s == 1 (mod n)
or
a**(s*(2**t)) == -1 (mod n) for some t, 0 <= t < r.



\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intIsStrongSelfridgePrp? mpNum? True if n is a strong Lucas probable prime with Selfidge parameters}
	{a? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

is\_strong\_selfridge\_prp(n) will return True if n is a strong Lucas probable prime with Selfidge
parameters (p,q). The Selfridge parameters are chosen by finding the first element D in the
sequence {5, -7, 9, -11, 13, ...} such that Jacobi(D,n) == -1. Let p=1 and q = (1-D)/4 and then
perform a strong Lucas probable prime test.



\subsection{Lucas Sequences}

An overview is provided by \cite{Joye_1996}.

\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intLucasU? mpNum? the k-th element of the Lucas U sequence defined by p,q}
	{p? mpNum? An Integer.}
	{q? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

lucasu(p,q,k) will return the k-th element of the Lucas U sequence defined by p,q. p*p - 4*q
must not equal 0; k must be greater than or equal to 0.




\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionFour
	{intLucasModU? mpNum? the k-th element of the Lucas U sequence defined by p,q (mod n)}
	{p? mpNum? An Integer.}
	{q? mpNum? An Integer.}
	{k? mpNum? An Integer.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}


lucasu\_mod(p,q,k,n) will return the k-th element of the Lucas U sequence defined by p,q (mod
n). p*p - 4*q must not equal 0; k must be greater than or equal to 0; n must be greater than 0.


\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionThree
	{intLucasV? mpNum? the k-th element of the Lucas V sequence defined by p,q}
	{p? mpNum? An Integer.}
	{q? mpNum? An Integer.}
	{k? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

lucasv(p,q,k) will return the k-th element of the Lucas V sequence defined by parameters (p,q).
p*p - 4*q must not equal 0; k must be greater than or equal to 0.




\vspace{0.6cm}
\begin{mpFunctionsExtract}
	\mpFunctionFour
	{intLucasModV? mpNum? the k-th element of the Lucas V sequence defined by p,q (mod n)}
	{p? mpNum? An Integer.}
	{q? mpNum? An Integer.}
	{k? mpNum? An Integer.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

lucasv\_mod(p,q,k,n) will return the k-th element of the Lucas V sequence defined by
parameters (p,q) (mod n). p*p - 4*q must not equal 0; k must be greater than or equal to 0; n
must be greater than 0.





\section{Random Numbers}
\label{intRandomNumbers}



\subsection{intUrandomb}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intUrandomb? mpNum? a uniformly distributed random integer in the range 0 to $2^n - 1$, inclusive.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}



\subsection{intUrandomm}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intUrandomm? mpNum? a uniformly distributed random integer in the range 0 to $n - 1$, inclusive.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}




\subsection{intRrandomb}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{intRrandomb? mpNum? a random integer with long strings of zeros and ones in the binary representation.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Useful for testing functions and algorithms, since this kind of random numbers have proven
to be more likely to trigger corner-case bugs. The random number will be in the range 0 to
$2^n - 1$, inclusive.




\section{Information Functions for Integers}
\label{InformationFunctionsForIntegers}





\subsection{Congruence: IsCongruent(\textit{n}, \textit{c}, \textit{d})}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{IsCongruent? mpNum? TRUE if $n$ is congruent to $c$ modulo $d$, and FALSE otherwise.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
	{m? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns TRUE if $n$ is congruent to $c$ modulo $d$, and FALSE otherwise.

$n$ is congruent to $c$ mod $d$ if there exists an integer $q$ satisfying $n = c + qd$. 

Unlike the other division functions, $d = 0$ is accepted and following the rule it can be seen that $n$ and $c$ are considered congruent mod 0 only when exactly equal.




\subsection{Congruence 2n: IsCongruent2exp(\textit{n}, \textit{c}, \textit{b})}

\begin{mpFunctionsExtract}
	\mpFunctionThree
	{IsCongruent2exp? mpNum? TRUE if $n$ is congruent to $c$ modulo $d$, and FALSE otherwise.}
	{n? mpNum? An Integer.}
	{c? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

$n$ is congruent to $c$ mod $d$ if there exists an integer $q$ satisfying $n = c + qd$. 

Unlike the other division functions, $d = 0$ is accepted and following the rule it can be seen that $n$ and $c$ are considered congruent mod 0 only when exactly equal.




\subsection{Primality Testing: IsProbablyPrime(\textit{n}, \textit{reps})}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{IsProbablyPrime? mpNum? 2 if $n$ is definitely prime, returns 1 if $n$ is probably prime (without being certain), and returns 0 if n is definitely composite.}
	{n? mpNum? An Integer.}
	{reps? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
This function does some trial divisions, then some Miller-Rabin probabilistic primality tests.

The argument $reps$ controls how many such tests are done; a higher value will reduce the chances of a composite being returned as “probably prime”. 25 is a reasonable number; a composite number will then be identified as a prime with a probability of less than $2^{-50}$. Miller-Rabin and similar tests can be more properly called compositeness tests. Numbers which fail are known to be composite but those which pass might be prime or might be composite. Only a few composites pass, hence those which pass are considered probably prime.




\subsection{Divisibility: IsDivisible(\textit{n}, \textit{d})}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{IsDivisible? mpNum? TRUE if $n$ is exactly divisible by $d$.}
	{n? mpNum? An Integer.}
	{d? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

$n$ is divisible by $d$ if there exists an integer $q$ satisfying $n = qd$. 

Unlike the other division functions, $d = 0$ is accepted and following the rule it can be seen that only 0 is considered divisible by 0.





\subsection{Divisibility by (2 pow b): IsDivisible2exp(\textit{n}, \textit{b})}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{IsDivisible2exp? mpNum? TRUE if $n$ is exactly divisible by $2^b$.}
	{n? mpNum? An Integer.}
	{b? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}

$n$ is divisible by $d$ if there exists an integer $q$ satisfying $n = qd$. 

Unlike the other division functions, $d = 0$ is accepted and following the rule it can be seen that only 0 is considered divisible by 0.




\subsection{Perfect Power: IsPerfectPower(\textit{n})}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{IsPerfectPower? mpNum? TRUE if $n$ is a perfect power.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns TRUE if $n$ is a perfect power, i.e., if there exist integers $a$ and $b$, with $b > 1$, such that $n = a^b$.
Under this definition both 0 and 1 are considered to be perfect powers. Negative values of $n$ are accepted, but of course can only be odd perfect powers.





\subsection{Perfect Square: IsPerfectSquare(\textit{n})}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{IsPerfectSquare? mpNum? non-zero if $n$ is a perfect square.}
	{n? mpNum? An Integer.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns non-zero if $n$ is a perfect square, i.e., if the square root of $n$ is an integer. Under this definition both 0 and 1 are considered to be perfect squares.








\chapter{FMPQ}
\lipsum[1]



\subsubsection{mpq input}
[Function] int mpq\_set\_str (mpq t rop, const char *str, int base)
Set rop from a null-terminated string str in the given base.

The string can be an integer like “41” or a fraction like “41/152”. The fraction must be
in canonical form (see Chapter 6 [Rational Number Functions], page 45), or if not then
mpq\_canonicalize must be called.

The numerator and optional denominator are parsed the same as in mpz\_set\_str (see
Section 5.2 [Assigning Integers], page 30). White space is allowed in the string, and is simply
ignored. The base can vary from 2 to 62, or if base is 0 then the leading characters are used:

0x or 0X for hex, 0b or 0B for binary, 0 for octal, or decimal otherwise. Note that this is done
separately for the numerator and denominator, so for instance 0xEF/100 is 239/100, whereas
0xEF/0x100 is 239/256.

The return value is 0 if the entire string is a valid number, or −1 if not.



\subsubsection{mpq output}

[Function] char * mpq\_get\_str (char *str, int base, const mpq t op)
Convert op to a string of digits in base base. The base may vary from 2 to 36. The string
will be of the form ‘num/den’, or if the denominator is 1 then just ‘num’.
If str is NULL, the result string is allocated using the current allocation function (see
Chapter 13 [Custom Allocation], page 86). The block will be strlen(str)+1 bytes, that
being exactly enough for the string and null-terminator.
If str is not NULL, it should point to a block of storage large enough for the result, that being
mpz\_sizeinbase (mpq\_numref(op), base)
+ mpz\_sizeinbase (mpq\_denref(op), base) + 3
The three extra bytes are for a possible minus sign, possible slash, and the null-terminator.
A pointer to the result string is returned, being either the allocated block, or the given str.


%
%\chapter{MPD}
%
%The MPD reference is \cite{mpd_2012}
%
%\lipsum[1]
%
%
%\section{Multiprecision Decimal Numbers (MPD)}
%\lipsum[5]
%
%
%
%\section{MPD Context}
%
%Explanation of decimal context
%
%\lipsum[1]
%
%
%
%\chapter{MPFR}
%
%
%
%\section{Multiprecision with correct rounding (MPFR)}
%Provides a library for multiple-precision floating-point computation with exact rounding. The computation is both efficient and has a well-defined semantics. It copies the good ideas from the ANSI/IEEE-754 standard for double-precision floating-point arithmetic. 
%
%
%
%GNU MPFR (for GNU Multiple Precision Floating-Point Reliably[1]) is a portable C library for arbitrary-precision binary floating-point computation with correct rounding, based on GNU Multi-Precision Library. The computation is both efficient and has a well-defined semantics: the functions are completely specified on all the possible operands and the results do not depend on the platform. This is done by copying the ideas from the ANSI/IEEE-754 standard for fixed-precision floating-point arithmetic (correct rounding and exceptions, in particular). More precisely, its main features are:
%
%Support for special numbers: signed zeros (−0), infinities and not-a-number (a single NaN is currently supported).
%Each number has its own precision (in bits since MPFR uses radix 2). The floating-point results are correctly rounded to the precision of the target variable, in any of the four IEEE-754 rounding modes.
%Supported functions: MPFR implements all mathematical functions from C99: the logarithm and exponential in natural base, base 2 and base 10, the log(1+x) and exp(x)-1 functions (log1p and expm1), the six trigonometric and hyperbolic functions and their inverses, the gamma, zeta and error functions, the arithmetic geometric mean, the power (xy) function. All those functions are correctly rounded over their complete range.
%Subnormals are not supported, but can be emulated with the mpfr\_subnormalize function.
%MPFR is not able to track the accuracy of numbers in a whole program or expression; this is not its goal. Interval arithmetic packages like MPFI, or Real RAM implementations like iRRAM, which may be based on MPFR, can do that for the user.
%
%
%
%
%\section{MPFR Context}
%\label{MPFRContext}
%
%MPFR is a portable library written in C for arbitrary precision arithmetic on floating-point numbers. Version 3.0.0 is used. MPFR is based on the GNU multiprecision library.
%
%\vspace{0.3cm}
%The MPFR code is portable, i.e. the result of any operation does not depend (or should not) on the machine word size mp\_bits\_per\_limb (32 or 64 on most machines); 
%the precision in bits can be set exactly to any valid value for each variable (including very small precision); 
%MPFR provides the four rounding modes from the IEEE 754-1985 standard. 
%In particular, with a precision of 53 bits, MPFR should be able to exactly reproduce all computations with double-precision machine floating-point numbers (e.g., double type in C, with a C implementation that rigorously follows Annex F of the ISO C99 standard and FP\_CONTRACT pragma set to OFF) on the four arithmetic operations and the square root, except the default exponent range is much wider and subnormal numbers are not implemented (but can be emulated). 
%
%\vspace{0.3cm}
%There is one significant characteristic of floating-point numbers that has motivated a difference between this function class and other GNU MP function classes: the inherent inexactness of floating-point arithmetic. The user has to specify the precision for each variable. A computation that assigns a variable will take place with the precision of the assigned variable; the cost of that computation should not depend from the precision of variables used as input (on average). 
%
%\vspace{0.3cm}
%The semantics of a calculation in MPFR is specified as follows: Compute the requested operation exactly (with "infinite accuracy"), and round the result to the precision of the destination variable, with the given rounding mode. The MPFR floating-point functions are intended to be a smooth extension of the IEEE 754-1985 arithmetic. The results obtained on one computer should not differ from the results obtained on a computer with a different word size. 
%
%\vspace{0.3cm}
%MPFR does not keep track of the accuracy of a computation. This is left to the user or to a higher layer. As a consequence, if two variables are used to store only a few significant bits, and their product is stored in a variable with large precision, then MPFR will still compute the result with full precision. 
%
%
%
%\subsection{Nomenclature and Types}
%
%A floating-point number as used in this chapter is an arbitrary precision significand (also called mantissa) with a limited precision exponent. The type for such objects is mp\_fr. A floating-point number can have three special values: Not-a-Number (NaN) or plus or minus Infinity. NaN represents an uninitialized object, the result of an invalid operation (like 0 divided by 0), or a value that cannot be determined (like +Infinity minus +Infinity). Moreover, like in the IEEE 754-1985 standard, zero is signed, i.e. there are both +0 and -0; the behavior is the same as in the IEEE 754-1985 standard and it is generalized to the other functions supported by MPFR. 
%
%\vspace{0.3cm}
%The precision is the number of bits used to represent the significand of a floating-point number. The precision can be any integer between mp\_fr\_PREC\_MIN and mp\_fr\_PREC\_MAX. In the current implementation, mp\_fr\_PREC\_MIN is equal to 2. 
%
%\vspace{0.3cm}
%Note: MPFR needs to increase the precision internally, in order to provide accurate results (and in particular, correct rounding). Do not attempt to set the precision to any value near mp\_fr\_PREC\_MAX, otherwise MPFR will abort due to an assertion failure. Moreover, you may reach some memory limit on your platform, in which case the program may abort, crash or have undefined behavior. 
%
%\vspace{0.3cm}
%The rounding mode specifies the way to round the result of a floating-point operation, in case the exact result can not be represented exactly in the destination significand; the corresponding VBA data type is mp\_rnd\_t. 
%
%\vspace{0.3cm}
%A limb means the part of a multi-precision number that fits in a single word. (We chose this word because a limb of the human body is analogous to a digit, only larger, and containing several digits.) Normally a limb contains 32 or 64 bits.
%
%There is only one class of functions in the MPFR library: 
%
%1. Functions for floating-point arithmetic, with names beginning with mp\_fr\_. The associated type is mp\_fr\_t. 
%
%
%
%\subsection{Precision}
%
%Sub mp\_fr\_set\_default\_prec(prec As Long) 
%
%Set the default precision to be exactly prec bits. The precision of a variable means the number of bits used to store its significand. All subsequent calls to mp\_fr\_init will use this precision, but previously initialized variables are unaffected. This default precision is set to 53 bits initially. The precision can be any integer between mp\_fr\_PREC\_MIN and mp\_fr\_PREC\_MAX. 
%
%\vspace{0.3cm}
%Function mp\_fr\_get\_default\_prec() As Long 
%
%Return the default MPFR precision in bits. 
%
%\vspace{0.3cm}
%The following functions are useful for changing the precision during a calculation. A typical use would be for adjusting the precision gradually in iterative algorithms like Newton-Raphson, making the computation precision closely match the actual accurate part of the numbers. 
%
%\vspace{0.3cm}
%Sub mp\_fr\_set\_prec(x As mp\_fr, prec As Long) 
%
%Reset the precision of x to be exactly prec bits, and set its value to NaN. The previous value stored in x is lost. It is equivalent to a call to mp\_fr\_clear(x) followed by a call to mp\_fr\_init2(x, prec), but more efficient as no allocation is done in case the current allocated space for the significand of x is enough. The precision prec can be any integer between mp\_fr\_PREC\_MIN and mp\_fr\_PREC\_MAX. 
%In case you want to keep the previous value stored in x, use mp\_fr\_prec\_round instead. 
%
%\vspace{0.3cm}
%Function mp\_fr\_get\_prec(x As mp\_fr\_t) As Long 
%Return the precision actually used for assignments of x, i.e. the number of bits used to store its significand. 
%
%
%\subsection{Rounding}
%The following four rounding modes are supported: 
%
%\vspace{0.3cm}
%Enum mp\_fr\_rnd\_t 
%
%mp\_fr\_RNDN: round to nearest. 
%
%mp\_fr\_RNDZ: round toward zero. 
%
%mp\_fr\_RNDU: round toward plus infinity. 
%
%mp\_fr\_RNDD: round toward minus infinity. 
%
%End Enum
%
%\vspace{0.3cm}
%The "round to nearest" mode works as in the IEEE 754-1985 standard: in case the number to be rounded lies exactly in the middle of two representable numbers, it is rounded to the one with the least significant bit set to zero. For example, the number 5/2, which is represented by (10.1) in binary, is rounded to (10.0) = 2 with a precision of two bits, and not to (11.0) = 3. This rule avoids the drift phenomenon mentioned by Knuth in volume 2 of The Art of Computer Programming (Section 4.2.2). 
%
%\vspace{0.3cm}
%Most MPFR functions take as first argument the destination variable, as second and following arguments the input variables, as last argument a rounding mode, and have a return value of type mp\_fr\_status\_t, called the ternary value.
%
%\vspace{0.3cm}
%Enum mp\_fr\_status\_t 
%
%mp\_fr\_BELOW: the returned value is below the exact value. 
%
%mp\_fr\_EXACT: the returned value is exact. 
%
%mp\_fr\_ABOVE: the returned value is above the exact value. 
%
%End Enum
%
%\vspace{0.3cm}
%The value stored in the destination variable is correctly rounded, i.e. MPFR behaves as if it computed the result with an infinite precision, then rounded it to the precision of this variable. The input variables are regarded as exact (in particular, their precision does not affect the result). 
%
%\vspace{0.3cm}
%As a consequence, in case of a non-zero real rounded result, the error on the result is less or equal to 1/2 ulp (unit in the last place) of the target in the rounding to nearest mode, and less than 1 ulp of the target in the directed rounding modes (a ulp is the weight of the least significant represented bit of the target after rounding). 
%
%\vspace{0.3cm}
%If the ternary value is zero, it means that the value stored in the destination variable is the exact result of the corresponding mathematical function. If the ternary value is positive (resp. negative), it means the value stored in the destination variable is greater (resp. lower) than the exact result. For example with the GMP\_RNDU rounding mode, the ternary value is usually positive, except when the result is exact, in which case it is zero. In the case of an infinite result, it is considered as inexact when it was obtained by overflow, and exact otherwise. A NaN result (Not-a-Number) always corresponds to an exact return value. The opposite of a returned ternary value is guaranteed to be representable in an int. 
%
%\vspace{0.3cm}
%Unless documented otherwise, functions returning a 1 (or any other value specified in this manual) for special cases (like acos(0)) should return an overflow or an underflow if 1 is not representable in the current exponent range. 
%
%\vspace{0.3cm}
%Sub mp\_fr\_set\_default\_rounding\_mode([rnd As mp\_fr\_rnd\_t = GMP\_RNDN]) 
%
%Set the default rounding mode to rnd. The default rounding mode is to nearest initially. 
%
%\vspace{0.3cm}
%Function mp\_fr\_get\_default\_rounding\_mode() As mp\_fr\_rnd\_t 
%
%Get the default rounding mode. 
%
%\vspace{0.3cm}
%Function mp\_fr\_prec\_round(x As mp\_fr, prec As Long, [rnd As mp\_fr\_rnd\_t = GMP\_RNDN]) As mp\_fr\_status\_t 
%
%Round x according to rnd with precision prec, which must be an integer between mp\_fr\_PREC\_MIN and mp\_fr\_PREC\_MAX (otherwise the behavior is undefined). If prec is greater or equal to the precision of x, then new space is allocated for the significand, and it is filled with zeros. Otherwise, the significand is rounded to precision prec with the given direction. In both cases, the precision of x is changed to prec. 
%
%\vspace{0.3cm}
%Function mp\_fr\_print\_rnd\_mode([rnd As mp\_fr\_rnd\_t = GMP\_RNDN]) As String 
%
%Return the input string (GMP RNDD, GMP RNDU, GMP RNDN, GMP RNDZ) corresponding to the rounding mode rnd . 
%
%
%
%
%\subsection{Exponent}
%
%
%\vspace{0.3cm}Function mp\_fr\_get\_exp(x As mp\_fr, [rnd As mp\_fr\_rnd\_t = GMP\_RNDN]) As Long 
%
%Get the exponent of x, assuming that x is a non-zero ordinary number and the significand is chosen in [1/2,1). The behavior for NaN, infinity or zero is undefined. 
%
%\vspace{0.3cm}
%Function mp\_fr\_set\_exp(x As mp\_fr, e As Long, [rnd As mp\_fr\_rnd\_t = GMP\_RNDN]) As mp\_fr\_status\_t 
%
%Set the exponent of x if e is in the current exponent range, and return 0 (even if x is not a non-zero ordinary number); otherwise, return a non-zero value. The significand is assumed to be in [1/2,1). 
%
%\vspace{0.3cm}
%Function mp\_fr\_get\_emin() As Long 
%
%Function mp\_fr\_get\_emax() As Long 
%
%Return the (current) smallest and largest exponents allowed for a floating-point variable. The smallest positive value of a floating-point variable is ½ × 2emin and the largest value has the form (1 − ε) × 2emax. 
%
%\vspace{0.3cm}
%Function mp\_fr\_set\_emin(exp As Long) As mp\_fr\_status\_t 
%
%Function mp\_fr\_set\_emax(exp As Long) As mp\_fr\_status\_t 
%
%Set the smallest and largest exponents allowed for a floating-point variable. Return a non-zero value when exp is not in the range accepted by the implementation (in that case the smallest or largest exponent is not changed), and zero otherwise. If the user changes the exponent range, it is her/his responsibility to check that all current floating-point variables are in the new allowed range (for example using mp\_fr\_check\_range), otherwise the subsequent behavior will be undefined, in the sense of the ISO C standard. 
%
%\vspace{0.3cm}
%Function mp\_fr\_get\_emin\_min() As Long 
%
%Function mp\_fr\_get\_emin\_max() As Long 
%
%Function mp\_fr\_get\_emax\_min() As Long 
%
%Function mp\_fr\_get\_emax\_max() As Long 
%
%Return the minimum and maximum of the smallest and largest exponents allowed for mp\_fr\_set\_emin and mp\_fr\_set\_emax. These values are implementation dependent; it is possible to create a non portable program by writing mp\_fr\_set\_emax(mp\_fr\_get\_emax\_max()) and mp\_fr\_set\_emin(mp\_fr\_get\_emin\_min()) since the values of the smallest and largest exponents become implementation dependent. 
%
%\vspace{0.3cm}
%Function mp\_fr\_check\_range(x As mp\_fr, t As Long, [rnd As mp\_fr\_rnd\_t = GMP\_RNDN]) As mp\_fr\_status\_t 
%
%This function forces x to be in the current range of acceptable values, t being the current ternary value: negative if x is smaller than the exact value, positive if x is larger than the exact value and zero if x is exact (before the call). It generates an underflow or an overflow if the exponent of x is outside the current allowed range; the value of t may be used to avoid a double rounding. This function returns zero if the rounded result is equal to the exact one, a positive value if the rounded result is larger than the exact one, a negative value if the rounded result is smaller than the exact one. Note that unlike most functions, the result is compared to the exact one, not the input value x, i.e. the ternary value is propagated. 
%
%\vspace{0.3cm}
%Note: If x is an infinity and t is different from zero (i.e., if the rounded result is an inexact infinity), then the overflow flag is set. This is useful because mp\_fr\_check\_range is typically called (at least in MPFR functions) after restoring the flags that could have been set due to internal computations. 
%
%\vspace{0.3cm}
%Function mp\_fr\_subnormalize(x As mp\_fr, t As Long, [rnd As mp\_fr\_rnd\_t = GMP\_RNDN]) As mp\_fr\_status\_t 
%
%This function rounds x emulating subnormal number arithmetic: if x is outside the subnormal exponent range, it just propagates the ternary value t; otherwise, it rounds x to precision EXP(x)-emin+1 according to rounding mode rnd and previous ternary value t, avoiding double rounding problems. More precisely in the subnormal domain, denoting by e the value of emin, x is rounded in fixed-point arithmetic to an integer multiple of 2e − 1; as a consequence, 1.5e − 1 when t is zero is rounded to 2e with rounding to nearest. 
%
%\vspace{0.3cm}
%PREC(x) is not modified by this function. rnd and t must be the used rounding mode for computing x and the returned ternary value when computing x. The subnormal exponent range is from emin to emin+PREC(x)-1. If the result cannot be represented in the current exponent range (due to a too small emax), the behavior is undefined. Note that unlike most functions, the result is compared to the exact one, not the input value x, i.e. the ternary value is propagated. This is a preliminary interface. 
%
%\vspace{0.3cm}
%This is an example of how to emulate double IEEE-754 arithmetic using MPFR: 
%
%\begin{verbatim}
%{
%mp_fr xa, xb;
%int i;
%volatile double a, b;
%mp_fr_set_default_prec (53);
%mp_fr_set_emin (-1073);
%mp_fr_set_emax (1024);
%mp_fr_init (xa); mp_fr_init (xb);
%b = 34.3; mp_fr_set_d (xb, b, GMP_RNDN);
%a = 0x1.1235P-1021; mp_fr_set_d (xa, a, GMP_RNDN);
%a /= b;
%i = mp_fr_div (xa, xa, xb, GMP_RNDN);
%i = mp_fr_subnormalize (xa, i, GMP_RNDN);
%mp_fr_clear (xa); mp_fr_clear (xb);
%} 
%\end{verbatim}
%
%
%
%
%\subsection{Status Flags}
%
%
%Sub mp\_fr\_clear\_underflow() 
%
%Sub mp\_fr\_clear\_overflow() 
%
%Sub mp\_fr\_clear\_nanflag() 
%
%Sub mp\_fr\_clear\_inexflag() 
%
%Sub mp\_fr\_clear\_erangeflag() 
%
%Clear the underflow, overflow, invalid, inexact and erange flags. 
%
%\vspace{0.3cm}
%Sub mp\_fr\_set\_underflow() 
%
%Sub mp\_fr\_set\_overflow() 
%
%Sub mp\_fr\_set\_nanflag() 
%
%Sub mp\_fr\_set\_inexflag() 
%
%Sub mp\_fr\_set\_erangeflag() 
%
%Set the underflow, overflow, invalid, inexact and erange flags. 
%
%\vspace{0.3cm}
%Sub mp\_fr\_clear\_flags() 
%
%Clear all global flags (underflow, overflow, inexact, invalid, erange). 
%
%\vspace{0.3cm}
%Function mp\_fr\_underflow\_p() As Boolean 
%
%Function mp\_fr\_overflow\_p() As Boolean 
%
%Function mp\_fr\_nanflag\_p() As Boolean 
%
%Function mp\_fr\_inexflag\_p() As Boolean 
%
%Function mp\_fr\_erangeflag\_p() As Boolean 
%
%Return TRUE if the corresponding (underflow, overflow, invalid, inexact, erange) flag is set. 
%
%
%
%\subsection{Exceptions}
%MPFR supports 5 exception types: 
%
%\vspace{0.3cm}
%Underflow: An underflow occurs when the exact result of a function is a non-zero real number and the result obtained after the rounding, assuming an unbounded exponent range (for the rounding), has an exponent smaller than the minimum exponent of the current range. In the round-to-nearest mode, the halfway case is rounded toward zero. Note: This is not the single definition of the underflow. MPFR chooses to consider the underflow after rounding. The underflow before rounding can also be defined. For instance, consider a function that has the exact result 7 × 2e−4, where e is the smallest exponent (for a significand between 1/2 and 1) in the current range, with a 2-bit target precision and rounding toward plus infinity. The exact result has the exponent e−1. With the underflow before rounding, such a function call would yield an underflow, as e−1 is outside the current exponent range. However, MPFR first considers the rounded result assuming an unbounded exponent range. The exact result cannot be represented exactly in precision 2, and here, it is rounded to 0.5 × 2e, which is representable in the current exponent range. As a consequence, this will not yield an underflow in MPFR. 
%
%\vspace{0.3cm}
%Overflow: An overflow occurs when the exact result of a function is a non-zero real number and the result obtained after the rounding, assuming an unbounded exponent range (for the rounding), has an exponent larger than the maximum exponent of the current range. In the round-to-nearest mode, the result is infinite. 
%
%\vspace{0.3cm}
%NaN: A NaN exception occurs when the result of a function is a NaN. 
%
%\vspace{0.3cm}
%Inexact: An inexact exception occurs when the result of a function cannot be represented exactly and must be rounded. 
%
%\vspace{0.3cm}
%Range error: A range exception occurs when a function that does not return a MPFR number (such as comparisons and conversions to an integer) has an invalid result (e.g. an argument is NaN in mp\_fr\_cmp or in a conversion to an integer). 
%
%\vspace{0.3cm}
%MPFR has a global flag for each exception, which can be cleared, set or tested by functions described in Section 42.19 [Exception Related Functions].
%
%\vspace{0.3cm}
%Differences with the ISO C99 standard: 
%
%In C, only quiet NaNs are specified, and a NaN propagation does not raise an invalid exception. Unless explicitly stated otherwise, MPFR sets the NaN flag whenever a NaN is generated, even when a NaN is propagated (e.g. in NaN + NaN), as if all NaNs were signaling. 
%
%An invalid exception in C corresponds to either a NaN exception or a range error in MPFR. 
%
%
%
%
%
%The MPFR reference is \cite{MPFR_2007}
%
%The Brent reference is \cite{Brent2010}
%
%The Holoborodko reference is \cite{Holoborodko2012}
%
%The Wilkening reference is \cite{Wilkening2008}
%
%\lipsum[1]
%
%
%\subsubsection{mpfr input}
%
%[Function] int mpfr\_strtofr (mpfr t rop, const char *nptr, char **endptr, int base,
%mpfr rnd t rnd)
%
%Read a fl oating-point number from a string nptr in base base, rounded in the direction rnd;
%base must be either 0 (to detect the base, as described below) or a number from 2 to 62
%(otherwise the behavior is undefi ned). If nptr starts with valid data, the result is stored in
%rop and *endptr points to the character just after the valid data (if endptr is not a null
%pointer); otherwise rop is set to zero (for consistency with strtod) and the value of nptr
%is stored in the location referenced by endptr (if endptr is not a null pointer). The usual
%ternary value is returned.
%
%Parsing follows the standard C strtod function with some extensions. After optional leading
%whitespace, one has a subject sequence consisting of an optional sign (+ or -), and either nu-
%meric data or special data. The subject sequence is defi ned as the longest initial subsequence
%of the input string, starting with the fi rst non-whitespace character, that is of the expected
%form.
%
%The form of numeric data is a non-empty sequence of signifi cand digits with an optional
%decimal point, and an optional exponent consisting of an exponent prefi x followed by an
%optional sign and a non-empty sequence of decimal digits. A signifi cand digit is eithera
%decimal digit or a Latin letter (62 possible characters), with A = 10, B = 11, . . ., Z = 35;
%case is ignored in bases less or equal to 36, in bases larger than 36, a = 36, b = 37, . . ., z
%= 61. The value of a signifi cand digit must be strictly less than the base. The decimal point
%can be either the one defi ned by the current locale or the period (the fi rst one is accepted
%for consistency with the C standard and the practice, the second one is accepted to allow the
%programmer to provide MPFR numbers from strings in a way that does not depend on the
%current locale). The exponent prefi x can be e or E for bases up to 10, or @ in any base; it
%indicates a multiplication by a power of the base. In bases 2 and 16, the exponent prefi x can
%also be p or P, in which case the exponent, called binary exponent, indicates a multiplication
%by a power of 2 instead of the base (there is a diff erence only for base 16); in base 16 for
%example 1p2 represents 4 whereas 1@2 represents 256. The value of an exponent is always
%written in base 10.
%
%If the argument base is 0, then the base is automatically detected as follows. If the signifi cand
%starts with 0b or 0B, base 2 is assumed. If the signifi cand starts with 0x or 0X, base 16 is
%assumed. Otherwise base 10 is assumed.
%
%Note: The exponent (if present) must contain at least a digit. Otherwise the possible exponent
%prefi x and sign are not part of the number (which ends with the signifi cand). Similarly,if 0b,
%0B, 0x or 0X is not followed by a binary/hexadecimal digit, then the subject sequence stops
%at the character 0, thus 0 is read.
%
%Special data (for infi nities and NaN) can be @inf@ or @nan@(n-char-sequence-opt), and
%if base ≤ 16, it can also be infinity, inf, nan or nan(n-char-sequence-opt), all case
%insensitive. A n-char-sequence-opt is a possibly empty string containing only digits, Latin
%letters and the underscore (0, 1, 2, . . ., 9, a, b, . . ., z, A, B, . . ., Z, ). Note: one has
%an optional sign for all data, even NaN. For example, -@nAn@(This\_Is\_Not\_17) is a valid
%representation for NaN in base 17.
%
%
%
%\subsubsection{mpfr output}
%char * mpfr\_get\_str (char *str, mpfr exp t *expptr, int b, size t n,
%mpfr t op, mpfr rnd t rnd)
%Convert op to a string of digits in base b, with rounding in the direction rnd, where n is
%either zero (see below) or the number of signifi cant digits output in the string; in the latter
%case, n must be greater or equal to 2. The base may vary from 2 to 62. If the input number
%is an ordinary number, the exponent is written through the pointer expptr (for input 0, the
%current minimal exponent is written).
%The generated string is a fraction, with an implicit radix point immediately to the left of the
%fi rst digit. For example, the number −3.1416 would be returned as "−31416" in the string and
%1 written at expptr. If rnd is to nearest, and op is exactly in the middle of two consecutive
%possible outputs, the one with an even signifi cand is chosen, where both signifi cands are
%considered with the exponent of op. Note that for an odd base, this may not correspond to
%an even last digit: for example with 2 digits in base 7, (14) and a half is rounded to (15)
%which is 12 in decimal, (16) and a half is rounded to (20) which is 14 in decimal, and (26)
%and a half is rounded to (26) which is 20 in decimal.
%If n is zero, the number of digits of the signifi cand is chosen large enough so that re-reading
%the printed value with the same precision, assuming both output and input use rounding
%to nearest, will recover the original value of op. More precisely, in most cases, the chosen
%precision of str is the minimal precision m depending only on p = PREC(op) and b that
%satisfi es the above property, i.e., m = 1 + dp
%log 2
%log b
%e, with p replaced by p−1 if b is a power
%of 2, but in some very rare cases, it might be m + 1 (the smallest case for bases up to 62 is
%when p equals 186564318007 for bases 7 and 49).
%If str is a null pointer, space for the signifi cand is allocated using the current allocation
%function, and a pointer to the string is returned. To free the returned string, you must use
%mpfr\_free\_str.
%If str is not a null pointer, it should point to a block of storage large enough for the signifi cand,
%i.e., at least max(n + 2, 7). The extra two bytes are for a possible minus sign, and for the
%terminating null character, and the value 7 accounts for -@Inf@ plus the terminating null
%character.
%A pointer to the string is returned, unless there is an error, in which case a null pointer is
%returned.
%
%
%%\chapter{Elementary Functions Returning Real Numbers}
%\label{ElementaryFunctions} 
%
%
%
%\section{Constants}
%\label{Constants}
%
%
%\subsection{Log2}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{ConstLog2? mpNum? the value of the natural logarithm of 2, $\ln(2) = 0.69314718055994...$.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{Pi}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{Pi? mpNum? the value of $\pi = 3.1415926535897932...$.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Catalan}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{Catalan? mpNum? the value of Catalan's constant, $G = 0.9159655941772190...$.}
%\end{mpFunctionsExtract}            
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{Euler's Gamma}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{EulerGamma? mpNum? the value of Euler's Gamma, $\gamma = 0.57721566490153286...$.}
%\end{mpFunctionsExtract}              
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{Machine Epsilon}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{MachineEpsilon? mpNum? the value of the Machine Epsilon in the current precision}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{MaxReal}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{MaxReal? mpNum? the value of the largest representable real number in the current precision.}
%\end{mpFunctionsExtract}
%
%
%Implemented in double, MPFR, MPFI.
%
%
%
%\subsection{MaxInteger}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{MaxInteger? mpNum? the value of the largest representable integer in the current precision.}
%\end{mpFunctionsExtract}
%
%
%Implemented in double, MPFR, MPFI.
%
%
%
%\subsection{MinReal}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{MinReal? mpNum? the value of the smallest representable positive real number in the current precision.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR, MPFI.
%
%
%\subsection{MinInteger}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{MinInteger? mpNum? the value of the smallest representable positive integer in the current precision.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR, MPFI.
%
%
%\subsection{Positive Infinity}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{PosInf? mpNum? the value of the representation of  $+\infty$ in the current precision.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR, MPFI.
%
%
%
%\subsection{Negative Infinity}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{NegInf? mpNum? the value of the representation of  $-\infty$ in the current precision.}
%\end{mpFunctionsExtract}
%
%
%Implemented in double, MPFR, MPFI.
%
%
%
%\subsection{Not-a-Number: NaN}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionZero
%	{NaN? mpNum? the value of the representation of Not a Number (NaN) in the current precision.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR, MPFI.
%
%
%
%
%
%\section{Sign, Powers and Roots}
%\label{Roots}
%
%
%\subsection{Sign}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sign? mpNum? the value of the sign of $x, \text{sign}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Copysign}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Copysign? mpNum? $|x|\cdot \text{sign(y)}$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Absolute Value: } |x| = \sqrt{x^2}$}{Abs}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Abs? mpNum? the absolute value of $x$, $|x| = \sqrt{x^2}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Reciprocal: } 1/x = x^{-1}$}{reci}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Reci? mpNum? the absolute value of the reciprocal of $x,  1/x = x^{-1}$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Square: }x^2$}{Square}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Square? mpNum? the absolute value of the square of $x,  x^2$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\begin{extract}
%	Additional HTML Comment only in extracted file
%\end{extract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Power Function with Integer Exponent: }x^k, k \in  \mathbb{Z}$}{powerxk}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Power\_k? mpNum? the value of $x^k, k \in  \mathbb{Z}$}
%	{x? mpNum? A real number.}
%	{k? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Power Function with Real Exponent: }x^y, y \in  \mathbb{R}$}{powerxy}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Power? mpNum? the value of $x^y, y \in  \mathbb{R}$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }x^y-1$}{Powm1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Powm1? mpNum? the value of $x^y-1, y \in  \mathbb{R}$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }x^2+y^2$}{x2py2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{X2pY2? mpNum? the value of $x^2+y^2$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }x^2-y^2$}{x2my2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{X2mY2? mpNum? the value of $x^2-y^2$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Square Root: }\sqrt{x}$}{sqrt}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sqrt? mpNum? the absolute value of the square root of $x, \sqrt{x}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Square Root of a nonnegative Integer: }\sqrt{n}, n \in  \mathbb{N}$}{sqrt}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sqrt\_n? mpNum? the absolute value of the square root of a nonnegative Integer$n, \sqrt{n}$.}
%	{x? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Reciprocal Square Root: }1/\sqrt{x}$}{recsqrt}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{ReciSqrt? mpNum? the absolute value of the reciprocal square root of $x, \sqrt{x}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Cube Root: }\sqrt[3]{x}$}{Cbrt}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Cbrt? mpNum? the absolute value of the cube root of $x, \sqrt[3]{x}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\sqrt{x+1}-1$}{sqrtp1m1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sqrtp1m1? mpNum? the value of $\sqrt{x+1}-1$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\sqrt{1+x^2}$}{sqrt1px2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sqrt1px2? mpNum? the value of $\sqrt{1+x^2}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\sqrt{1-x^2}$}{sqrt1mx2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sqrt1mx2? mpNum? the value of $\sqrt{1-x^2}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\sqrt{x^2-1}$}{sqrtx2m1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sqrtx2m1? mpNum? the value of $\sqrt{x^2-1}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\sqrt{x^2+y^2}$}{Hypot}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Hypot? mpNum? the value of $\sqrt{x^2+y^2}$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Nth Root: }\sqrt[n]{x}, n=2,3,...$}{nthRoot}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{NthRoot? mpNum? the value of the $n^{th}$ root of $x$, $\sqrt[n]{x}, n=2,3,...$.}
%	{n? mpNum? An integer.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\lstset{language={[Visual]Basic}}
%\lstset{morekeywords={Imports, Module, New, As}}
%
%
%
%
%\section{Exponential, Logarithmic, and Lambert Functions}
%%\label{ExponentialFunctions}
%
%\subsection{\texorpdfstring{$\text{Exponential Function }e^x = \exp(x)$}{exp}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Exp? mpNum? the value of the exponential function,  $\text{exp}(x) = e^x = \exp(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Exponential Function }10^x = \exp_{10}(x)$}{exp10}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Exp10? mpNum? the value of the exponential function, $\text{exp10}(x) = 10^x = \exp_{10}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Exponential Function }2^x = \exp_2(x)$}{exp2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Exp2? mpNum? the value of the exponential function, $\text{exp2}(x) = 2^x = \exp_2(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }e^{x}-1$}{expm1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Expm1? mpNum? the value of the function $\text{expm1}(x) = e^{x}-1$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }e^{x^2}$}{expx2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Expx2? mpNum? the value of the function $\text{expx2}(x) = e^{x^2}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%Implemented in double, MPFR and MPFI.
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }e^{x^2}-1$}{expx2m1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Expx2m1? mpNum? the value of the function $\text{expx2m1}(x) = e^{x^2}-1$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }e^{-x^2}$}{expmx2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Expmx2? mpNum? the value of the function $\text{expmx2}(x) = e^{-x^2}$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }e^{-x^2}-1$}{expmx2m1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Expmx2m1? mpNum? the value of the function $\text{expmx2m1}(x) = e^{-x^2}-1$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%Implemented in double, MPFR and MPFI.
%
%
%
%\subsection{\texorpdfstring{$\text{Natural logarithm  }\ln(x) = \log_e(x)$}{ln}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Ln? mpNum? the value of the natural logarithm $\text{ln}(x) = \log_e(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%Implemented in double, MPFR and MPFI.
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\ln(1+x)$}{lnp1}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Lnp1? mpNum? the value of the function $\ln(1+x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%Implemented in double, MPFR and MPFI.
%
%
%\subsection{\texorpdfstring{$\text{Common (decadic) logarithm }\log_{10}(x)$}{log10}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Log10? mpNum? the value of the decadic logarithm $\text{log10}(x) = \log_{10}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Binary logarithm }\log_2(x)$}{log22}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Log2? mpNum? the value of the binary logarithm $\text{log2}(x) = \log_{2}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Logarithm to base b: }\log_b(x)$}{logb}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Log? mpNum? the value of the logarithm  to base $b$: $\text{logb}(x) = \log_{b}(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\ln(\cos(x))$}{LnCos}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LnCos? mpNum? the value of the logarithm of the cosine of $x$: $\text{LnCos}(x) =\ln(\cos(x))$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\ln(\sin(x))$}{LnSin}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LnSin? mpNum? the value of the logarithm of the sine of $x$: $\text{LnSin}(x) =\ln(\sin(x))$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%Implemented in double, MPFR and MPFI.
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\ln \left(\sqrt{x^2+y^2} \right)$}{LnSqrtx2y2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{LnSqrtx2y2? mpNum? the value of the function $\text{LnSqrtx2y2}(x) =\ln \left(\sqrt{x^2+y^2} \right)$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{\texorpdfstring{$\text{Auxiliary Function }\ln \left(\sqrt{(x+1)^2+y^2} \right)$}{LnSqrtxp1T2y2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{LnSqrtxp1T2y2? mpNum? the value of the function $\text{LnSqrtxp1T2y2}(x) =\ln \left(\sqrt{(x+1)^2+y^2} \right)$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Lambert Functions }W_0(x) \text{ and }W_{-1}(x)$}{Lambert functions}}
%
%The multivalued Lambert W function is defined as a solution of
%\begin{equation}
%	W(x) e ^{W (x)} = x.
%\end{equation}
%
%This function has two real branches for $x < 0$ with a branch point at $x = -1/e$.
%
%LambertW0$(x)$ = $W_0 (x)$ is the principal branch with $W_0 (x) \geq -1$ for $x < 0$, and
%
%LambertWm1$(x)$ = $W_{-1} (x)$ is the other real branch with $W_{-1}(x) \leq -1$ for $x < 0$.
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LambertW0? mpNum? the value of the Lambert functions $W_0(x)$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{LambertWm1? mpNum? the value of the Lambert functions $W_{-1}(x)$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%See \cite{Corless96onthe}
%
%
%
%
%
%\section{Trigonometric Functions}
%\label{TrigonometricFunctions}
%
%
%\subsection{\texorpdfstring{$\text{Sine: }\sin(x)$}{sin}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sin? mpNum? the value of the sine of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{SinDeg? mpNum? the value of the sine of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{\texorpdfstring{$\text{Cosine: }\cos(x)$}{cos}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Cos? mpNum? the value of the cosine of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CosDeg? mpNum? the value of the cosine of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Tangent: }\tan(x)$}{tan}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Tan? mpNum? the value of the tangent of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TanDeg? mpNum? the value of the tangent of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Cosecant: }\csc(x) = 1/\sin(x)$}{csc}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Csc? mpNum? the value of the cosecant of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CscDeg? mpNum? the value of the cosecant of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Secant: }\sec(x) = 1/\cos(x)$}{sec}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sec? mpNum? the value of the secant of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{SecDeg? mpNum? the value of the secant of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Cotangent: }\cot(x) = 1/\tan(x)$}{cot}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Cot? mpNum? the value of the cotangent of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CotDeg? mpNum? the value of the cotangent of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Sinus Cardinal: Sinc}{}_a(x)$}{Sinca}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sinca? mpNum? the sinus cardinal function}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The sinus cardinal function is defined as
%\begin{equation}
%	\text{sinc}_a(x) = \sin \left( \frac{\pi x}{a} \right) \frac{a}{\pi x}
%\end{equation}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Sine: }\sinh(x)$}{sinh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sinh? mpNum? the value of the hyperbolic sine of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{SinhDeg? mpNum? the value of the hyperbolic sine of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Cosine: }\cosh(x)$}{cosh}}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Cosh? mpNum? the value of the hyperbolic cosine of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CoshDeg? mpNum? the value of the hyperbolic cosine of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Tangent: }\tanh(x)$}{tanh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Tanh? mpNum? the value of the hyperbolic cosine of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{TanhDeg? mpNum? the value of the hyperbolic cosine of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Cosecant: csch}(x) = 1/\sinh(x)$}{csch}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Csch? mpNum? the value of the hyperbolic cosecant of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CschDeg? mpNum? the value of the hyperbolic cosecant of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Secant: sech}(x) = 1/\cosh(x)$}{sech}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sech? mpNum? the value of the hyperbolic cosecant of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{SechDeg? mpNum? the value of the hyperbolic cosecant of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Cotangent: }\coth(x) = 1/\tanh(x)$}{coth}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Coth? mpNum? the value of the hyperbolic cotangent of $x$, with $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{CothDeg? mpNum? the value of the hyperbolic cotangent of $x$, with $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Sinus Cardinal: Sinhc}{}_a(x)$}{Sinhca}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Sinhca? mpNum? the hyperbolic sinus cardinal function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The hyperbolic sinus cardinal function is defined as
%\begin{equation}
%	\text{sinhc}_a(x) = \sinh \left( \frac{\pi x}{a} \right) \frac{a}{\pi x}
%\end{equation}
%
%Implemented in double, MPFR and MPFI.
%
%
%
%
%
%
%
%
%
%
%
%
%\section{Inverse Trigonometric Functions}
%\label{InverseTrigonometricFunctions}
%
%
%\subsection{\texorpdfstring{$\text{Arc-sine: asin}(x)$}{asin}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Asin? mpNum? the value of the arc-sine of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AsinDeg? mpNum? the value of the arc-sine of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Arc-cosine: acos}(x)$}{acos}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Acos? mpNum? the value of the arc-cosine of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AcosDeg? mpNum? the value of the arc-cosine of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Arc-tangent: atan}(x)$}{atan}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Atan? mpNum? the value of the arc-tangent of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AtanDeg? mpNum? the value of the arc-tangent of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Arc-tangent, version with 2 arguments: atan2}(x,y)$}{atan2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Atan2? mpNum? the value of the arc-tangent of $x$ in radians.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Atan2Deg? mpNum? the value of the arc-tangent of $x$ in degrees}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Arc-cotangent: acot}(x)$}{acot}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Acot? mpNum? the value of the arc-cotangent of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AcotDeg? mpNum? the value of the arc-cotangent of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Arc-sine: asinh}(x)$}{asinh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Asinh? mpNum? the value of the hyperbolic arc-sine  of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AsinhDeg? mpNum? the value of hyperbolic arc-sine  of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Arc-cosine: acosh}(x)$}{acosh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Acosh? mpNum? the value of the hyperbolic arc-cosine  of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AcoshDeg? mpNum? the value of hyperbolic arc-cosine  of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Arc-tangent: atanh}(x)$}{atanh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Atanh? mpNum? the value of the hyperbolic arc-tangent  of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AtanhDeg? mpNum? the value of hyperbolic arc-tangent  of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Hyperbolic Arc-cotangent: acoth}(x)$}{acoth}}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Acoth? mpNum? the value of the hyperbolic arc-cotangent  of $x$ in radians.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{AcothDeg? mpNum? the value of hyperbolic arc-cotangent  of $x$ in degrees}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%
%
%\section{Elementary Functions of Mathematical Physics}
%
%\subsection{\texorpdfstring{$\text{Bessel Function }J_0(x)$}{J0x}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{BesselJ0? mpNum? $J_0(x)$, the Bessel function of the 1st kind, order zero.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{\texorpdfstring{$\text{Bessel Function }J_1(x)$}{J1x}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{BesselJ1? mpNum? $J_1(x)$, the Bessel function of the 1st kind, order one.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Bessel Function }J_n(x)$}{Jnx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{BesselJn? mpNum? $J_n(x)$, the Bessel function of the 1st kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Bessel function of the 1st kind, order $n$ is defined as
%\begin{equation}
%	J_n(x) = \left(\tfrac{1}{2}x \right)^n \sum_{k=0}^\infty (-1)^k \frac{\left(\tfrac{1}{4}x^2\right)^k}{k!(n+k)!}, \quad J_{-n}(x)=(-1)^n J_n(x).
%\end{equation}
%
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Bessel Function }Y_0(x)$}{Y0x}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{BesselY0? mpNum? $Y_0(x)$, the Bessel function of the second kind, order zero.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{\texorpdfstring{$\text{Bessel Function }Y_1(x)$}{Y1x}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{BesselY1? mpNum? $Y_1(x)$, the Bessel function of the second kind, order one.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{\texorpdfstring{$\text{Bessel Function }Y_n(x)$}{Ynx}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{BesselYn? mpNum? $Y_n(x)$, the Bessel function of the second kind, order $n$.}
%	{x? mpNum? A real number.}
%	{n? mpNum? An Integer.}
%\end{mpFunctionsExtract}
%
%
%
%\vspace{0.3cm}
%The Bessel function of the second kind of order $n$ is defined as
%\begin{equation}
%	Y_{n}(x)  = \frac{J_{n}(x) \cos(n \pi) - J_{-n}(x)}{ \sin(n \pi)}
%\end{equation}
%
%
%
%
%
%
%
%\subsection{Error Function erf}
%\label{Error Function erf}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Erf? mpNum? the value of the error function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The error function is defined by
%\begin{equation}
%	\text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_0^x e^{-x^2} dt,
%\end{equation}
%
%
%
%\subsection{Complementary Error Function}
%\label{Complementary Error Function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Erfc? mpNum? the value of the complementary error function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The complementary error function is defined by
%\begin{equation}
%	\text{erfc}(x) = 1-\text{erf}(x) = \frac{2}{\sqrt{\pi}} \int_x^\infty e^{-x^2} dt,
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Gamma function }\Gamma(x)$}{TGamma}}
%\nomenclature{$\Gamma(x)$}{Gamma Function}
%\label{GammaFunction}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Tgamma? mpNum? the gamma function for $x \neq 0, -1, -2,\ldots$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The gamma function for $x \neq 0, -1, -2,\ldots$ is defined by
%\begin{equation}
%	\Gamma(x)  = \int_{0}^{\infty} t^{x-1} e^{-t} dt \quad (x>0),
%\end{equation}
%and by analytic continuation if $x<0$, using the reflection formula
%\begin{equation}
%	\Gamma(x) \Gamma(1-x)  = \pi / \sin(\pi x).
%\end{equation}
%
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Lgamma? mpNum? the logarithm of the gamma function.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes $\ln|\Gamma(x)|$ for $x \neq 0, -1, -2, \ldots$. If $x<0$ the function uses the logarithm of the reflection formula.
%
%
%
%
%\subsection{Pochhammer symbol}
%\label{PochhammerSymbol}
%\nomenclature{$(a)_n$}{Pochhammer symbol}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Pochhammer? mpNum? the Pochhammer symbol.}
%	{a? mpNum? An integer.}
%	{x? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Pochhammer symbol is defined as
%\begin{equation}
%	(a)_x = \frac{\Gamma(a+x)}{\Gamma(a)}.
%\end{equation}
%In the special case that $x=n$ is a positive integer, $(a)_n = a(a+1)(a+2) \cdots (a+n-1)$ is often called "`rising factorial"'. By convention $(a)_0 = 1$.
%
%
%
%
%
%\subsection{Beta Function B(a,b)}
%\label{BetaFunction}
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Beta? mpNum? the Beta function.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function computes $B(a,b)$ for $a, b \neq 0, -1, -2, \ldots$. 
%
%
%
%
%\subsection{Logarithm of  B(a, b)}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{LnBetaBoost? mpNum? the logarithm of the beta function $\ln B(a,b)|$ with $a,b \neq 0,-1,-2,\ldots$.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%The alogorithm is implemented as in \cite{DiDonato_1987}
%
%\subsection{Normalised incomplete beta functions}
%\label{sec:IncompleteBetaFunctionBoost}
%\label{sec:NormalisedIncompleteBetaFunction}
%\nomenclature{$I_x(a,b)$}{Normalised incomplete beta function}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetaBoost? mpNum? the normalised incomplete beta function.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the normalised incomplete beta function $I_x(a,b)$ for $a>0$, $b>0$, and $0 \leq x \leq 1$:
%\begin{equation}
%	I_x(a,b) = \frac{B_x(a,b)}{B(a,b)}, \quad B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt.
%\end{equation}
%There are some special cases
%\begin{equation}
%	I_0(a,b)=0, \quad I_1(a,b)=1, \quad I_x(a,1)=x^a,
%\end{equation}
%and the symmetry relation $I_x(a,b)=1-I_{1-x}(b,a)$, which is used for $x>a/(a+b)$.
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetacBoost? mpNum? the normalised complement of the incomplete beta function, $1 - I_x(a,b)$.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Non-Normalised incomplete beta functions}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetaNonNormalizedBoost? mpNum? the non-normalised incomplete beta function.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns the non-normalised incomplete beta function $B_x(a,b)$ for $a>0$, $b>0$, and $0 \leq x \leq 1$:
%\begin{equation}
%	B_x(a,b) = \int_0^x t^{a-1} (1-t)^{b-1} dt.
%\end{equation}
%There are some special cases
%\begin{equation}
%	B_0(a,b)=0, \quad B_1(a,b)=B(a,b), \quad B_x(a,1)= \frac{x^a}{a}, \quad B_x(1,b)= \frac{1-(1-x)^b}{b},
%\end{equation}
%and the relation $B_{1-x}(a,b)=B(a,b)-B_x(b,a)$, which is used if $x>a/(a+b)$. 
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetacNonNormalizedBoost? mpNum? the non-normalised complement of the incomplete beta function, $1 - B_x(a,b)$.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\subsection{Inverse normalised incomplete beta functions}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetaInvBoost? mpNum? the inverse of the normalised incomplete beta function $I_x(a,b)$.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{p? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function calculates $x$ such that $I_x(a,b) = p$. The input parameters are $a, b>0$, $p \geq 0$,  and $p+q=1$. 
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetacInvBoost? mpNum? the inverse of the complement of the normalised incomplete beta function $1 - I_x(a,b)$.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%This function calculates $x$ such that $1 - I_x(a,b) = q$. The input parameters are $a, b>0$, $q \geq 0$, and $p+q=1$. 
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetaInvaBoost? mpNum? the parameter $a$ of the normalised incomplete beta function $I_x(a,b)$, such that $I_x(a,b) = p$.}
%	{x? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{p? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetacInvaBoost? mpNum? the parameter $a$ of the complement of the normalised incomplete beta function $1-I_x(a,b)$, such that $1-I_x(a,b) = q$.}
%	{x? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetaInvbBoost? mpNum? the parameter $b$ of the normalised incomplete beta function $I_x(a,b)$, such that $I_x(a,b) = p$.}
%	{x? mpNum? A real number.}
%	{a? mpNum? A real number.}
%	{p? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetacInvbBoost? mpNum? the parameter $b$ of the complement of the normalised incomplete beta function $1-I_x(a,b)$, such that $1-I_x(a,b) = q$.}
%	{x? mpNum? A real number.}
%	{a? mpNum? A real number.}
%	{q? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{Derivative of the Normalised Incomplete beta Function}
%\label{sec:DerivativeNormalisedIncompleteBetaFunction}
%\nomenclature{$I'_x(a,b)$}{Derivative of the normalised incomplete beta function}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{IBetaDerivativeBoost? mpNum? the partial derivative with respect to $x$ of the incomplete beta function.}
%	{x? mpNum? A real number.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The partial derivative with respect to $x$ of the incomplete beta function is defined as:
%\begin{equation}
%	\frac{\partial}{\partial x}I_x(a,b) = \frac{(1-x)^{b-1} x^{a-1}}{B(a,b)}.
%\end{equation}
%
%
%
%
%
%
%PLACEHOLDER: Incomplete Betafunction
%
%\label{sec:IncompleteBetaFunction}
%
%
%\subsection{\texorpdfstring{$\text{Riemann }\zeta(s)\text{ function}$}{RiemannZeta}}
%\label{RiemannZeta}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RiemannZeta? mpNum? the Riemann zeta function.}
%	{s? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The Riemann zeta function $\zeta(s)$ for $s \neq 1$ is defined as
%\begin{equation}
%	\zeta(s) = \sum_{k=1}^\infty \frac{1}{k^s}, \quad s>1.
%\end{equation}
%If $s<0$, the reflection formula is used:
%\begin{equation}
%	\zeta(s) = 2(2\pi)^{s-1} \sin\left(\tfrac{1}{2} \pi s\right) \Gamma(1-s) \zeta(1-s)
%\end{equation}
%
%
%
%\subsection{Dilogarithm Function}
%\label{DiGammaFunction}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Dilogarithm? mpNum? the dilogarithm function $\text{Li}_2(x)$.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%This function returns the dilogarithm function
%\begin{equation}
%	\text{dilog}(x) = \Re \text{Li}_2(x) = -\Re \int_0^x \frac{\ln(1-t)}{t}dt.
%\end{equation}
%Note that there is some confusion about the naming: some authors and/or computer algebra systems use $\text{dilog}(x) = \text{Li}_2(1-x)$ and then call $\text{Li}_2(x)$ Spence function/integral or similar.
%
%
%
%
%
%\section{Integer and Remainder Related Functions}
%\label{IntegerandRemainderRelatedFunctions}
%
%
%\subsection{Nearest integer: Round(\textit{x})}
%
%
%ROUND rounds to the nearest representable integer, rounding halfway cases away from zero (as in the roundTiesToAway mode of IEEE 754-2008).
%
%The returned indicator value is zero when the result is exact, positive when it is greater than the
%original value of op, and negative when it is smaller. More precisely, the returned value is
%0 when op is an integer representable in rop, 1 or -1 when op is an integer that is not
%representable in rop, 2 or -2 when op is not an integer.
%
%Note that mpfr\_round is different from mpfr\_rint called with the rounding to nearest mode
%(where halfway cases are rounded to an even integer or significand). Note also that no double
%rounding is performed; for instance, 10.5 (1010.1 in binary) is rounded by mpfr\_rint with
%rounding to nearest to 12 (1100 in binary) in 2-bit precision, because the two enclosing
%numbers representable on two bits are 8 and 12, and the closest is 12. (If one first rounded
%to an integer, one would round 10.5 to 10 with even rounding, and then 10 would be rounded
%to 8 again with even rounding.)
%
%
%\subsection{Next higher or equal integer: Ceil(\textit{x})}
%
%
%\vspace{0.3cm}
%CEILING rounds to the next higher or equal representable integer.
%
%
%
%
%\subsection{Next lower or equal integer: Floor(\textit{x})}
%
%
%\vspace{0.3cm}
%
%FLOOR rounds to the next lower or equal representable integer.
%
%
%
%\subsection{Next integer, rounded toward zero: Trunc(\textit{x})}
%
%
%TRUNC rounds to the next representable integer toward zero.
%
%
%
%\subsection{Nearest integer, rounded  in a given direction: Rint(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Rint? mpNum? the rounded value of $x$.}
%	{x? mpNum? A real number.}
%	{RoundingMode? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Rint rounds to the nearest representable integer in the given direction RoundingMode.
%
%
%
%\subsection{Nearest integer, followed by rint: RintRound(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RintRound? mpNum? the rounded value of $x$, rounded to the nearest integer, rounding halfway cases away from zero.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%
%mpfr\_rint\_round rounds to the nearest integer, rounding halfway cases away from zero.
%
%If the result is not representable, it is rounded in the direction rnd. The
%returned value is the ternary value associated with the considered round-to-integer function
%(regarded in the same way as any other mathematical function). 
%
%Contrary to mpfr\_rint, those functions do perform a double rounding: first op is rounded to the nearest integer in
%the direction given by the function name, then this nearest integer (if not representable) is
%rounded in the given direction rnd. 
%
%For example, mpfr\_rint\_round with rounding to nearest
%and a precision of two bits rounds 6.5 to 7 (halfway cases away from zero), then 7 is rounded
%to 8 by the round-even rule, despite the fact that 6 is also representable on two bits, and is
%closer to 6.5 than 8.
%
%
%\subsection{Next higher or equal integer, followed by rint: RintCeil(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RintCeil? mpNum? the rounded value of $x$, rounded to the next higher or equal integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%
%mpfr\_rint\_ceil rounds to the next higher or equal integer.
%
%
%\subsection{Next lower or equal integer, followed by rint: RintFloor(\textit{x})}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RintFloor? mpNum? the rounded value of $x$, rounded to the next lower or equal integer.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%
%mpfr\_rint\_floor rounds to the next lower or equal integer.
%
%
%\subsection{Next integer, rounded toward zero, followed by Rint: RintTrunc(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{RintTrunc? mpNum? the rounded value of $x$, rounded to the next integer toward zero.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%
%mpfr\_rint\_trunc rounds to the next integer toward zero. 
%
%
%
%
%\subsection{Fractional Part: Frac(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Frac? mpNum? the fractional part of $x$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Returns the fractional part of op, having the same sign as op, rounded in the direction rnd (unlike in mpfr\_rint, rnd affects only how the exact fractional part is rounded, not how the fractional part is generated).
%
%
%
%
%\subsection{Next integer rounded toward zero, with fractional part: Modf(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Modf? mpNumList? simultaneously the integer and fractional part of $x$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%Set simultaneously iop to the integral part of op and fop to the fractional part of op, rounded in the direction rnd with the corresponding precision of iop and fop (equivalent to mpfr\_trunc(iop, op, rnd) and mpfr\_frac(fop, op, rnd)). The variables iop and fop must be different. Return 0 iff both results are exact (see mpfr\_sin\_cos for a more detailed description of the return value).
%
%
%
%\subsection{\texorpdfstring{$\text{Floating Point Modulo: Fmod}(x, y)$}{fmod}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Fmod? mpNum? the remainder of $x/y$}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%\vspace{0.3cm}
%Returns the value of $x-ny, \quad n=\lfloor x/y\rfloor$, i.e. rounded according to the direction $rnd$, where $n$ is the integer quotient of $x$ divided by $y$,  rounded toward zero.
%See also section \ref{Remquo}.
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Floating Point Remainder: Remainder}(x, y)$}{Remainder}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Remainder? mpNum? the remainder of $x/y$}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Returns the value of $x-ny, \quad n=\text{round}(x/y)$, i.e. rounded according to the direction $rnd$, where $n$ is the integer quotient of $x$ divided by $y$,  rounded toward zero.
%See also section \ref{Remquo}.
%
%
%
%
%\subsection{Remainder and Quotient: Remquo(\textit{x, y})}
%\label{Remquo}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Remquo? mpNum? the remainder of $x/y$}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Returns the value of $x - ny$, rounded according to the direction $rnd$, where $n$ is the integer quotient of $x$ divided by $y$, defined as follows: $n$ is rounded toward zero for mpfr\_fmod, and to the nearest integer (ties rounded to even) for mpfr\_remainder and mpfr\_remquo.
%
%\vspace{0.3cm}
%Special values are handled as described in Section F.9.7.1 of the ISO C99 standard: If $x$ is infinite or $y$ is zero, $r$ is NaN. If $y$ is infinite and $x$ is finite, $r$ is $x$ rounded to the precision of $r$. If $r$ is zero, it has the sign of $x$. The return value is the ternary value corresponding to $r$.
%
%\vspace{0.3cm}
%Additionally, mpfr\_remquo stores the low significant bits from the quotient $n$ in *$q$ (more precisely the number of bits in a long minus one), with the sign of $x$ divided by $y$ (except if those low bits are all zero, in which case zero is returned). Note that $x$ may be so large in magnitude relative to $y$ that an exact representation of the quotient is not practical. The mpfr\_remainder and mpfr\_remquo functions are useful for additive argument reduction.
%
%
%
%
%\subsection{INT(\textit{x})}
%
%
%\vspace{0.3cm}
%Rounds a number down to the nearest integer.
%
%
%
%
%
%\section{Miscellaneous Functions}
%
%\subsection{Next representable value from \textit{x} toward y: Nexttoward(\textit{x}, \textit{y})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Nexttoward? mpNum? the next floating-point number (with the precision of $x$ and the current exponent range) in the direction of $y$}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%If $x$ or $y$ is NaN, set $x$ to NaN. If $x$ and $y$ are equal, $x$ is unchanged. Otherwise, if $x$ is different from $y$, replace $x$ by the next floating-point number (with the precision of $x$ and the current exponent range) in the direction of $y$ (the infinite values are seen as the smallest and largest floating-point numbers). If the result is zero, it keeps the same sign. No underflow or overflow is generated.
%
%
%
%
%\subsection{Next representable value above \textit{x}: Nextabove(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Nextabove? mpNum? the next floating-point number (with the precision of $x$ and the current exponent range) in the direction of plus infinity.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Equivalent to Nexttoward where $y$ is plus infinity.
%
%
%
%
%\subsection{Next representable value below \textit{x}: Nextbelow(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Nextbelow? mpNum? the next floating-point number (with the precision of $x$ and the current exponent range) in the direction of minus infinity.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Equivalent to Nexttoward where $y$ is minus infinity.
%
%
%
%
%\subsection{Significand and Exponent: Frexp(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{Frexp? mpNumList? returns simultaneously significand and exponent of $x$}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Set exp (formally, the value pointed to by exp) and y such that $0.5 \leq |y| < 1$ and $y \times 2^{exp}$ equals $x$ rounded to the precision of $y$, using the given rounding mode. If $x$ is zero, then $y$ is set to a zero of the same sign and exp is set to 0. If $x$ is NaN or an infinity, then $y$ is set to the same value and exp is undefined.
%
%
%
%\subsection{Number generated from Significand and Exponent: Ldexp(\textit{x}, \textit{y})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{Ldexp? mpNum? $x \cdot 2^{y}$}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%Returns the result of multiplying $x$ (the significand) by 2 raised to the power of $y$ (the exponent): 
%
%$\text{Ldexp}(x,y) = x \cdot 2^{y}$.
%
%
%
%
%\subsection{Fused-Multiply-Add Fma}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{Fma? mpNum? $(a \times b) + c$.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{c? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns $(a \times b) + c$.
%
%
%
%
%\subsection{Fused-Multiply-Subtract Fms}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionThree
%	{Fms? mpNum? $(a \times b) - c$.}
%	{a? mpNum? A real number.}
%	{b? mpNum? A real number.}
%	{c? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%This function returns $(a \times b) - c$.
%
%
%
%
%
%
%
%%\chapter{Information Functions}
%%\label{InformationFunctions} 
%
%
%
%
%\section{Numerical Information Functions}
%\label{NumericalInformationFunctions}
%
%
%
%\subsection{Infinity (positive or negative): IsInf(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsInf? Boolean? TRUE if $x$ is infinity (positive or negative), and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Integer: IsInteger(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsInteger? Boolean? TRUE if $x$ is an integer, and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Not-a-Number: IsNan(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsNan? Boolean? TRUE if $x$ is an NaN (Not a Number), and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Negative Number: IsNeg(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsNeg? Boolean? TRUE if $x$ is negative, and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Non-Negative Number: IsNonNeg(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsNonNeg? Boolean? TRUE if $x \geq 0$, and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Non-Positive Number: IsNonPos(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsNonPos? Boolean? TRUE if $x \leq 0$, and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%\subsection{Positive Number: IsPos(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsPos? Boolean? TRUE if $x > 0$, and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Regular Number: IsRegular(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsRegular? Boolean? TRUE if $x$ is an regular number (i.e. neither NaN nor an infinity nor zero), and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Unordered Comparison: IsUnordered(\textit{x}, \textit{y})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{IsUnordered? Boolean? TRUE if $x$ or $y$ is NaN (i.e. they cannot be compared), and FALSE otherwise.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Number is Zero: IsZero(\textit{x})}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{IsZero? Boolean? TRUE if $x = 0$, and FALSE otherwise.}
%	{x? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%
%
%
%
%\chapter{MPC}
%
%
%\section{Complex Multiprecision Numbers (MPC)}
%GNU MPC is a C library for the arithmetic of complex numbers with arbitrarily high precision and correct rounding of the result. It extends the principles of the IEEE-754 standard for fixed precision real floating point numbers to complex numbers, providing well-defined semantics for every operation. At the same time, speed of operation at high precision is a major design goal
%
%The MPC reference is \cite{mpc_2012}
%
%\lipsum[1]
%
%
%
%
%\subsubsection{mpc input}
%[Function] int mpc\_strtoc (mpc t rop, const char *nptr, char **endptr, int base,
%mpc rnd t rnd)
%
%Read a complex number from a string nptr in base base, rounded to the precision of rop
%with the given rounding mode rnd. The base must be either 0 or a number from 2 to 36
%(otherwise the behaviour is undefi ned). If nptr starts with valid data, the result is stored in
%rop, the usual inexact value is returned (see [Return Value], page 7) and, if endptr is not the
%null pointer, *endptr points to the character just after the valid data. Otherwise, rop is set
%to NaN + i * NaN, -1 is returned and, if endptr is not the null pointer, the value of nptr is
%stored in the location referenced by endptr.
%
%The expected form of a complex number string is either a real number (an optional leading
%whitespace, an optional sign followed by a fl oating-point number), or a pair of real numbers
%in parentheses separated by whitespace. If a real number is read, the missing imaginary part
%is set to +0. The form of a fl oating-point number depends on the base and is described in the
%documentation of mpfr\_strtofr in the GNU MPFR manual. For instance, "3.1415926",
%"(1.25e+7 +.17)", "(@nan@ 2)" and "(-0 -7)" are valid strings for base = 10. If base = 0,
%then a prefi x may be used to indicate the base in which the fl oating-point number is written.
%Use prefi x ’0b’ for binary numbers, prefi x ’0x’ for hexadecimal numbers, and no prefix for
%decimal numbers. The real and imaginary part may then be written in diff erent bases. For
%instance, "(1.024e+3 +2.05e+3)" and "(0b1p+10 +0x802)" are valid strings for base=0 and
%represent the same value.
%
%
%
%\subsubsection{mpc output}
%char * mpc\_get\_str (int b, size t n, mpc t op, mpc rnd t rnd)
%
%Convert op to a string containing its real and imaginary parts, separated by a space and
%enclosed in a pair of parentheses. The numbers are written in base b (which may vary from 2
%to 36) and rounded according to rnd. The number of signifi cant digits, at least 2, is given by
%n. It is also possible to let n be zero, in which case the number of digits is chosen large enough
%so that re-reading the printed value with the same precision, assuming both output and input
%use rounding to nearest, will recover the original value of op. Note that mpc\_get\_str uses
%the decimal point of the current locale if available, and ‘.’ otherwise.
%
%The string is generated using the current memory allocation function (malloc by default,
%unless it has been modifi ed using the custom memory allocation interface of gmp); once it is
%not needed any more, it should be freed by calling mpc\_free\_str.
%
%
%
%
%%\chapter{Elementary Functions Returning Complex Numbers}
%\label{FunctionsReturningComplexNumbers} 
%
%In the following, we assume $z=x+iy$, $z_1=x_1+iy_1$, $z_2=x_2+iy_2$, etc.
%
%
%
%\section{Conversion between Real and Complex Numbers}
%
%
%\subsection{Building a Complex Number from Real Components}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxRect? mpNum? a complex number $z$ build from the real components $x$ and $y$ as $z=x+iy$.}
%	{x? mpNum? A real number.}
%	{y? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%
%
%
%\newpage
%\subsection{Real Component}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxReal? mpNum? the real component $x$ of $z=x+iy$.}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%
%
%
%
%\subsection{Imaginary Component}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxImag? mpNum? the imaginary component $y$ of $z=x+iy$.}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Absolute Value}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxAbs? mpNum? the absolute value of $z=x+iy$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The absolute value of $z=x+iy$ is calculated as
%\begin{equation}
%	|z|=\sqrt{x^2+y^2}.
%\end{equation}
%
%
%
%\subsection{Argument}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxArg? mpNum? the argument of $z=x+iy$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%
%\vspace{0.3cm}
%The argument $\theta$ of $z=x+iy$, is defined such that
%\begin{equation}
%	z=x+iy = |x+iy|e^{\theta} = |x+iy|(\cos(\theta)+ i \sin(\theta)).
%\end{equation}
%\textsf{cplxArg$(z)$} is calculated as
%\begin{equation}
%	\textsf{cplxArg$(z)$}  = \arctan\left(\frac{y}{x} \right) = \theta, \text{ where } \theta \in (-\pi;\pi].
%\end{equation}
%
%
%
%
%
%
%
%\section{Unary and Arithmetic Operators }
%\label{ArithmeticOperatorsCplx}
%
%\subsection{Unary Minus and Conjugate}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxNeg? mpNum?  $-z=-x-iy$.}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxConj? mpNum? the conjugate of $z$, $\overline{z}=x-iy$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Addition and Sum}
%
%\begin{tabular}{p{481pt}}
%	\toprule
%	\textsf{Operator \textbf{+}} \\
%	\bottomrule
%\end{tabular}
%
%\vspace{0.3cm}
%The operator $+$ returns the sum of $z1$ and $z2$.
%
%\vspace{0.3cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxAdd? mpNum?  $-z=-x-iy$.}
%	{z1? mpNum? A complex number.}
%	{z2? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxAdd$(z1, z2)$} returns the sum of $z1$ and $z2$: 
%\begin{equation}
%	z_1 + z_2 =(x_1 + x_2) + i(y_1 + y_2).
%\end{equation}
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxSum? mpNum? the sum of up to 255 complex numbers.}
%	{z? mpNum[]? An array of complex numbers.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Subtraction}
%
%\begin{tabular}{p{481pt}}
%	\toprule
%	\textsf{Operator \textbf{$-$}} \\
%	\bottomrule
%\end{tabular}
%
%\vspace{0.3cm}
%The operator $-$ returns the difference of $z1$ and $z2$.
%
%\vspace{0.3cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxSub? mpNum? the difference of $z1$ and $z2$.}
%	{z1? mpNum? A complex number.}
%	{z2? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxSub$(z1, z2)$} returns the difference of $z1$ and $z2$: 
%\begin{equation}
%	z_1 - z_2 =(x_1 - x_2) + i(y_1 - y_2).
%\end{equation}
%
%
%
%
%
%\subsection{Multiplication}
%
%\begin{tabular}{p{481pt}}
%	\toprule
%	\textsf{Operator \textbf{$\times$}} \\
%	\bottomrule
%\end{tabular}
%
%\vspace{0.3cm}
%The operator $+$ returns the product of $z1$ and $z2$.
%
%\vspace{0.3cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxMul? mpNum? the product of $z1$ and $z2$.}
%	{z1? mpNum? A complex number.}
%	{z2? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxMul$(z1, z2)$} returns the product of $z1$ and $z2$: 
%\begin{equation}
%	z_1 \cdot z_2 =(x_1 x_2 - y_1 y_2) + i(x_1 y_2 + x_2 y_1).
%\end{equation}
%
%\vspace{0.6cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxProduct? mpNum? the product of up to 255 complex numbers.}
%	{z? mpNum[]? An array of complex numbers.}
%\end{mpFunctionsExtract}
%
%
%
%
%\subsection{Division}
%
%\begin{tabular}{p{481pt}}
%	\toprule
%	\textsf{Operator \textbf{$/$}} \\
%	\bottomrule
%\end{tabular}
%
%\vspace{0.3cm}
%The operator $-$ returns the quotient of $z1$ and $z2$.
%
%\vspace{0.3cm}
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxDiv? mpNum? the difference of $z1$ and $z2$.}
%	{z1? mpNum? A complex number.}
%	{z2? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxDiv$(z1, z2)$} returns the quotient of $z1$ and $z2$: 
%\begin{equation}
%	\frac{z_1}{z_2} = \frac{x_1 x_2 + y_1 y_2 + i(x_2 y_1 - x_1 y_2)}{x_2^2 + y_2^2}
%\end{equation}
%
%
%
%
%
%\section{Roots and Power Functions}
%\label{RootsAndPowersCplx}
%
%
%\subsection{\texorpdfstring{$\text{Square: }z^2$}{Square}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxSqr? mpNum? the square of $z$.}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxSqr$(z1, z2)$} returns the square of $z$: 
%\begin{equation}
%	z^2 = x^2-y^2 + i(2xy).
%\end{equation}
%
%
%
%\subsection{\texorpdfstring{$\text{Power Function with Integer Exponent: }z^k, k \in  \mathbb{Z}$}{powerxk}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxPower? mpNum? an integer power of $z$}
%	{z? mpNum? A complex number.}
%	{k? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxPower$(z, k)$} returns an integer power of $z$: 
%\begin{equation}
%	z^k = r^k \cos(k \theta) + i(r^k \sin(k \theta)), \quad  k \in  \mathbb{Z},
%\end{equation}
%where $r=\sqrt{x^2+y^2}$, and $\theta=\arctan(y/x)$.
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Power Function with Real Exponent: }z^a, a \in  \mathbb{R}$}{powerxy}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxPowR? mpNum? an real power of $z$}
%	{z? mpNum? A complex number.}
%	{a? mpNum? A real number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxPowR$(z, k)$} returns a real power of $z$: 
%\begin{equation}
%	z^a = r^a \cos(a \theta) + i(r^a \sin(a \theta)), \quad  a \in  \mathbb{R},
%\end{equation}
%where $r=\sqrt{x^2+y^2}$, and $\theta=\arctan(y/x)$.
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Power Function with Complex Exponent: }z_1^{z_2}, z_2 \in  \mathbb{C}$}{powerxy}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxPowC? mpNum? an complex power of $z$}
%	{z1? mpNum? A complex number.}
%	{z2? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxPowC$(z, k)$} returns a complex power of $z_1$: 
%\begin{equation}
%	z_1^{z_2} = \exp(\ln(z_1) z_2) , \quad  z_1, z_2 \in  \mathbb{C}.
%\end{equation}
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Square Root: }\sqrt{z}$}{sqrt}}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxSqrt? mpNum? the square root of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxSqrt$(z)$} returns the square root of $z$: 
%\begin{equation}
%	\sqrt{z} = \sqrt{r} \cos\left(\tfrac{1}{2}\theta\right) + i  \sqrt{r} \sin\left(\tfrac{1}{2}\theta\right),
%\end{equation}
%where $r=\sqrt{x^2+y^2}$, and $\theta=\arctan(y/x)$.
%
%
%
%\subsection{\texorpdfstring{$\text{Nth Root: }\sqrt[n]{z}, n=2,3,...$}{nthRoot}}
%
%
%\begin{mpFunctionsExtract}
%	\mpFunctionTwo
%	{cplxNthRoot? mpNum? an integer power of $z$}
%	{z? mpNum? A complex number.}
%	{n? mpNum? An integer.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%\vspace{0.3cm}
%The function \textsf{cplxNthRoot$(z, n)$} returns the $n^{th}$ root of $z$: 
%\begin{equation}
%	\sqrt[n]{z} = z^{1/n} = \sqrt[n]{r}  \exp\left(\frac{i \theta}{n}\right), \quad  n \in  \mathbb{N},
%\end{equation}
%where $r=\sqrt{x^2+y^2}$, and $\theta=\arctan(y/x)$. This is the principal root if $-\pi<\theta \leq \pi$.
%The other roots are given by
%\begin{equation}
%	\sqrt[n]{z} = \sqrt[n]{r}  \exp\left(\frac{i (\theta+2\pi k)}{n}\right) , \quad  k=1, 2, \ldots, n-1.
%\end{equation}
%
%
%
%
%
%
%
%
%
%\section{Exponential and Logarithmic Functions}
%\label{ExponentialAndLogarithmCplx}
%
%
%\subsection{\texorpdfstring{$\text{Exponential Function }e^z = \exp(z)$}{exp}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxExp? mpNum? the complex exponential of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxExp$(z)$} returns the complex exponential function of $z$: 
%\begin{equation}
%	\exp(z) = e^x \cos(y) + i e^x \sin(y).
%\end{equation}
%
%
%
%
%\subsection{\texorpdfstring{$\text{Exponential Function }10^z = \exp_{10}(z)$}{exp10}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxExp10? mpNum?  $10^z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxExp10$(z)$} returns $10^z = \exp_{10}(z) = \exp(z \cdot \ln(10))$.
%
%
%
%
%\subsection{\texorpdfstring{$\text{Exponential Function }2^z = \exp_2(z)$}{exp2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxExp2? mpNum?  $2^z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxExp2$(z)$} returns $2^z = \exp_{2}(z) =  \exp(z \cdot \ln(2))$.
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Natural logarithm  }\ln(z) $}{ln}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxLn? mpNum? the complex natural logarithm of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxLn$(z)$} returns the complex natural logarithm of $z$: 
%\begin{equation}
%	\ln(z)= \log_e(z) = \ln(r) + i \theta,
%\end{equation}
%where $r=\sqrt{x^2+y^2}$, and $\theta=\arctan(y/x)$.
%
%
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Common (decadic) logarithm }\log_{10}(z)$}{log10}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxLog10? mpNum? $\log_{10}(z)$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxLn$(z)$} returns the complex natural logarithm of $z$: 
%\begin{equation}
%	\log_{10}(z) =  \ln(z)/\ln(10).
%\end{equation}
%
%
%
%
%
%\subsection{\texorpdfstring{$\text{Binary logarithm }\log_2(z)$}{log2}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxLog2? mpNum? $\log_{2}(z)$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxLn$(z)$} returns the complex natural logarithm of $z$: 
%\begin{equation}
%	\log_{2}(z) =  \ln(z)/\ln(2).
%\end{equation}
%
%
%
%
%
%
%
%\section{Trigonometric Functions}
%\label{TrigonometricFunctionsCplx}
%
%
%\subsection{\texorpdfstring{$\text{Sine: }\sin(z)$}{sin}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxSin? mpNum? complex sine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxSin$(z)$} returns the complex sine of $z$: 
%\begin{equation}
%	\sin(z) = \sin(x) \cosh(y) + i \cos(x) \sinh(y).
%\end{equation}
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Cosine: }\cos(z)$}{cos}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxCos? mpNum? complex cosine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxCos$(z)$} returns the complex cosine of $z$: 
%\begin{equation}
%	\cos(z) = \cos(x) \cosh(y) - i \sin(x) \sinh(y).
%\end{equation}
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Tangent: }\tan(z)$}{tan}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxTan? mpNum? complex tangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxTan$(z)$} returns the tangent tangent of $z$: 
%\begin{equation}
%	\tan(z) =\frac{\sin(z)}{\cos(z)} = \frac{\sin(2x)+i \sinh(2y)}{\cos(2x)+i \cosh(2y)}
%\end{equation}
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Secant: }\sec(z) = 1/\cos(z)$}{sec}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxSec? mpNum? the complex secant of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxSec$(z)$} returns the complex secant of $z$: 
%\begin{equation}
%	\sec(z) = 1/\cos(z).
%\end{equation}
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Cosecant: }\csc(z) = 1/\sin(z)$}{csc}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxCsc? mpNum? the complex cosecant of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxCsc$(z)$} returns the complex cosecant of $z$: 
%\begin{equation}
%	\sec(z) = 1/\sin(z).
%\end{equation}
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Cotangent: }\cot(z) = 1/\tan(z)$}{cot}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxCot? mpNum? the complex cotangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxCot$(z)$} returns the complex cotangent of $z$: 
%\begin{equation}
%	\cot(z) =\frac{\cos(z)}{\sin(z)} = \frac{\sin(2x)-i \sinh(2y)}{\cosh(2y)-i \cos(2x)}
%\end{equation}
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Hyperbolic Sine: }\sinh(z)$}{sinh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxSinh? mpNum? the complex hyperbolic sine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxSinh$(z)$} returns the complex hyperbolic sine of $z$: 
%\begin{equation}
%	\sinh(z) = \sinh(x) \cos(y) + i \cosh(x) \sin(y).
%\end{equation}
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Hyperbolic Cosine: }\cosh(z)$}{cosh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxCosh? mpNum? the complex hyperbolic cosine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxCosh$(z)$} returns the complex hyperbolic cosine of $z$: 
%\begin{equation}
%	\cosh(z) = \cosh(x) \cos(y) + i \sinh(x) \sin(y).
%\end{equation}
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Hyperbolic Tangent: }\tanh(z)$}{tanh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxTanh? mpNum? the complex hyperbolic tangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxTanh$(z)$} returns the complex hyperbolic tangent of $z$: 
%\begin{equation}
%	\tanh(z) =\frac{\sinh(z)}{\cosh(z)} = \frac{\sinh(2x)+i \sin(2y)}{\cosh(2x)+i \cos(2y)}
%\end{equation}
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Hyperbolic Secant: sech}(x) = 1/\cosh(z)$}{sech}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxSech? mpNum? the complex hyperbolic secant of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxSech$(z)$} returns the complex hyperbolic secant of $z$: 
%\begin{equation}
%	\text{sech}(z) = 1/\cosh(z).
%\end{equation}
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Hyperbolic Cosecant: csch}(x) = 1/\sinh(z)$}{csch}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxCsch? mpNum? the complex hyperbolic cosecant of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxCsch$(z)$} returns the complex hyperbolic cosecant of $z$: 
%\begin{equation}
%	\text{csch}(z) = 1/\sinh(z).
%\end{equation}
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Hyperbolic Cotangent: }\coth(x) = 1/\tanh(z)$}{coth}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxCoth? mpNum? the complex hyperbolic cotangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxCot$(z)$} returns the complex hyperbolic cotangent of $z$: 
%\begin{equation}
%	\coth(z) =\frac{\cosh(z)}{\sinh(z)} = \frac{\sinh(2x)-i \sin(2y)}{\cosh(2x)-i \cos(2y)}
%\end{equation}
%
%
%
%
%
%
%
%
%
%\section{Inverse Trigonometric Functions}
%\label{InverseTrigonometricFunctionsCplx}
%
%The formulas in section follow \cite{NIST}, equations 4.23.34 - 4.23.38 for sections \ref{inverse complex sine} - \ref{inverse complex tangent}, equation 4.23.9 for section \ref{inverse complex cotangent}, and \cite{abramowitz_handbook_1970}, equations 4.6.14 - 4.6.19 for sections \ref{inverse complex hyperbolic sine} - \ref{inverse complex hyperbolic cotangent}.
%
%\subsection{\texorpdfstring{$\text{Arcsine: asin}(z)$}{asin}}
%\label{inverse complex sine}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxASin? mpNum? the inverse complex sine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxASin$(z)$} returns the inverse complex sine of $z=x+iy$: 
%\begin{equation}
%	\arcsin(z) = \arcsin(\beta) + i \ln \left(\alpha + \sqrt{\alpha^2 -1}\right), \quad \text{where}
%\end{equation}
%\begin{equation}
%	\label{complexAlpha}
%	\alpha = \tfrac{1}{2} \sqrt{(x+1)^2 + y^2} + \tfrac{1}{2} \sqrt{(x-1)^2 + y^2},
%\end{equation}
%
%\begin{equation}
%	\label{complexBeta}
%	\beta = \tfrac{1}{2} \sqrt{(x+1)^2 + y^2} - \tfrac{1}{2} \sqrt{(x-1)^2 + y^2},
%\end{equation}
%and $x \in [-1,1]$.
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Arccosine: acos}(z)$}{acos}}
%\label{inverse complex cosine}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxACos? mpNum? the inverse complex cosine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxACos$(z)$} returns the inverse complex cosine of $z=x+iy$: 
%\begin{equation}
%	\arccos(z) = \arccos(\beta) - i \ln \left(\alpha + \sqrt{\alpha^2 -1}\right), \quad \text{where}
%\end{equation}
%$\alpha$ and $\beta$ are defined in equations \ref{complexAlpha} and \ref{complexBeta}, and $x \in [-1,1]$. 
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Arctangent: atan}(z)$}{atan}}
%\label{inverse complex tangent}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxATan? mpNum? the inverse complex tangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxATan$(z)$} returns the inverse complex tangent of $z=x+iy$: 
%\begin{equation}
%	\arctan(z) = \tfrac{1}{2}\arctan \left(\frac{2x}{1-x^2-y^2}\right) + \tfrac{1}{4} i \ln \left(\frac{x^2+(y+1)^2}{x^2+(y-1)^2}\right), \quad \text{where } |z|<1.
%\end{equation}
%
%
%
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Arccotangent: acot}(z)$}{acot}}
%\label{inverse complex cotangent}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxACot? mpNum? the inverse complex cotangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxACot$(z)$} returns the inverse complex cotangent of $z$: 
%\begin{equation}
%	\text{arccot}(z) = \arctan(1/z), \quad z \neq \pm i.
%\end{equation}
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Inverse Hyperbolic Sine: asinh}(z)$}{asinh}}
%\label{inverse complex hyperbolic sine}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxASinh? mpNum? the inverse complex hyperbolic sine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxASinh$(z)$} returns the inverse complex hyperbolic sine of $z$: 
%\begin{equation}
%	\text{arcsinh}(z) = -i \text{ arcsin}(iz),
%\end{equation}
%where $\text{arcsin}(z)$ is defined in section \ref{inverse complex sine}
%
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Inverse Hyperbolic Cosine: acosh}(z)$}{acosh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxACosh? mpNum? the inverse complex hyperbolic cosine of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxACosh$(z)$} returns the inverse complex hyperbolic cosine of $z$: 
%\begin{equation}
%	\text{arccosh}(z) = \pm i \text{ arccos}(z),
%\end{equation}
%where $\text{arccos}(z)$ is defined in section \ref{inverse complex cosine}
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Inverse Hyperbolic Tangent: atanh}(z)$}{atanh}}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxATanh? mpNum? the inverse complex hyperbolic tangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxATanh$(z)$} returns the inverse complex hyperbolic tangent of $z$: 
%\begin{equation}
%	\text{arctanh}(z) = -i \text{ arctan}(z),
%\end{equation}
%where $\text{arctan}(z)$ is defined in section \ref{inverse complex tangent}
%
%
%
%
%
%
%\newpage
%\subsection{\texorpdfstring{$\text{Inverse Hyperbolic Cotangent: acoth}(z)$}{acoth}}
%\label{inverse complex hyperbolic cotangent}
%
%\begin{mpFunctionsExtract}
%	\mpFunctionOne
%	{cplxACoth? mpNum? the inverse complex hyperbolic cotangent of $z$}
%	{z? mpNum? A complex number.}
%\end{mpFunctionsExtract}
%
%\vspace{0.3cm}
%The function \textsf{cplxACoth$(z)$} returns the inverse complex hyperbolic cotangent of $z$: 
%\begin{equation}
%	\text{arctanh}(z) = i \text{ arctan}(iz),
%\end{equation}
%where $\text{arctan}(z)$ is defined in section \ref{inverse complex cotangent}
%
%
%



\chapter{ARB}



\section{Multiprecision Ball Arithmetic (ARB)}
MPFI (Multiple Precision Floating-Point Interval Library) is a library for arbitrary precision interval arithmetic with intervals represented using MPFR reliable floating-point numbers. It is based on the GNU MP library and on the MPFR library. The purpose of an arbitrary precision interval arithmetic is on the one hand to get guaranteed results, thanks to interval computation, and on the other hand to obtain accurate results, thanks to multiple precision arithmetic. The MPFI library is built upon MPFR to benefit from the correct roundings provided by MPFR, it portability, and its compliance with the IEEE 754 standard for floating-point arithmetic

References for MPFI: \cite{MPFI_2005}, \cite{Moore_2009},  \cite{Hayer2003},  and \cite{INTLAB_1999}

References for C-XSC 2.0  \cite{Hofschuster2004}

Manual for MPFR/MPFI version: \cite{Blomquist2012}


C++ Toolbox for Verified Scientific Computing I:   \cite{Hammer1995}

C++ Toolbox for Verified Scientific Computing II:   \cite{Kramer1994} and \cite{Kramer2006}

PASCAL-XSC Language Reference: \cite{Klatte1991}

speziellen Funktionen der mathematischen Physik: \cite{Hofschuster2000}

Integration: \cite{Wedner2000}


A priori error estimates : \cite{Blomquist2005}

Other papers:    \cite{Blomquist2008a} and  \cite{Blomquist2008} with detailed description of extended complex interval arithmetic.

and   \cite{Kramer2012}





\subsubsection{mpfi input}
int mpfi\_set\_str (mpfi t rop, char *s, int base)

Sets rop to the value of the string s, in base base (between 2 and 36), outward rounded to
the precision of rop: op then belongs to rop. The exponent is read in decimal. The string
is of the form ‘number’ or ‘[ number1 , number 2 ]’. Each endpoint has the form ‘M@N’ or, if
the base is 10 or less, alternatively ‘MeN’ or ‘MEN’. ‘M’ is the mantissa and ‘N’ is the exponent.
The mantissa is always in the specified base. The exponent is in decimal. The argument base
may be in the ranges 2 to 36.

This function returns 1 if the input is incorrect, and 0 otherwise.




\subsubsection{mpfi output}
size\_t mpfi\_out\_str (FILE *stream, int base, size t n\_digits, mpfi t op)

Outputs op on stdio stream stream, as a string of digits in base base. The output is an
opening square bracket "[", followed by the lower endpoint, a separating comma, the upper
endpoint and a closing square bracket "]".

For each endpoint, the output is performed by mpfr\_out\_str. The following piece of in-
formation is taken from MPFR documentation. The base may vary from 2 to 36. For each
endpoint, it prints at most n digits signifi cant digits, or if n digits is 0, the maximum number
of digits accurately representable by op. In addition to the signifi cant digits, a decimal point
at the right of the fi rst digit and a trailing exponent, in the form‘ eNNN’, are printed. If base
is greater than 10, ‘@’ will be used instead of ‘e’ as exponent delimiter.

Returns the number of bytes written, or if an error occurred, return 0.

As mpfi\_out\_str outputs an enclosure of the input interval, and as mpfi\_inp\_str provides
an enclosure of the interval it reads, these functions are not reciprocal. More precisely, when
they are called one after the other, the resulting interval contains the initial one, and this
inclusion may be strict.



\section{Information Functions for Intervals}
\label{InformationFunctionsForIntervals}



\subsection{IsEmpty}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{IsEmpty? mpNum? TRUE  if $x$ is empty (its endpoints are in reverse order), and FALSE otherwise.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Nothing is done in arithmetic or special functions to handle empty intervals: it is the responsibility of the user to avoid computing with empty intervals.




\subsection{IsInside}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{IsInside? mpNum? TRUE  if $x$ is contained in $y$, and FALSE otherwise.}
	{x? mpNum? A real number.}
	{y? mpNum? A real number.}
\end{mpFunctionsExtract}

\vspace{0.3cm}
Returns FALSE if at least one argument is NaN or an invalid interval.




\subsection{IsStrictlyInside}

\begin{mpFunctionsExtract}
	\mpFunctionTwo
	{IsStrictlyInside? mpNum? TRUE  if the second interval $y$ is contained in the interior of $x$, and FALSE otherwise.}
	{x? mpNum? A real number.}
	{y? mpNum? A real number.}
\end{mpFunctionsExtract}




\subsection{IsStrictlyNeg}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{IsStrictlyNeg? mpNum? TRUE if $x$ contains only negative numbers, and FALSE otherwise.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}




\subsection{IsStrictlyPos}

\begin{mpFunctionsExtract}
	\mpFunctionOne
	{IsStrictlyPos? mpNum? TRUE if $x$ contains only positive numbers, and FALSE otherwise.}
	{x? mpNum? A real number.}
\end{mpFunctionsExtract}








\chapter{ACB}
\lipsum[1]
