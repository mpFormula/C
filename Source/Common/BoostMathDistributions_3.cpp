/* BoostMathDistributions.cpp: this file is part of the mpFormula Library
 *
 * Copyright (C) 2008, 2009, 2010 Dietrich Hadler
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or (at
 * your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
 */



#include "libBoostMath.h"



 void boost_bernoulli(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input p)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }

 void boost_betadist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input a, boost_mp_input b)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_binomialdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input n, boost_mp_input p)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_cauchydist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input location, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_cdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input nu)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_exponentialdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input lambda)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_extreme_valuedist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input location, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_fdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input mu, boost_mp_input nu)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_gammadist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input shape, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_hypergeometricdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input r_, boost_mp_input n_, boost_mp_input N_)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_inversechisquareddist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input df, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_inversegammadist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input shape, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_inversegaussiandist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input mean, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_laplacedist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input location, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
//
 void boost_logisticdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input location, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_lognormaldist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input location, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
//
 void boost_negative_binomialdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input n, boost_mp_input p)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
//
 void boost_ndist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input mean, boost_mp_input stdev)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_paretodist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input shape, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_poissondist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input nu)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_rayleighdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input nu)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_tdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input nu)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_triangulardist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input lower, boost_mp_input mode, boost_mp_input upper)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_weibulldist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input shape, boost_mp_input scale)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
//
 void boost_uniformdist(long Target, boost_mp_result y, boost_mp_input x, boost_mp_input lower, boost_mp_input upper)
 {
    mpfr_set_si(y, 2, mpfr_get_default_rounding_mode());
 }
//
